# ======css

#### 1.gird基础

```
1.采用网格布局的区域，称为"容器"（container）。容器内部采用网格定位的子元素，称为"项目"（item）。
2.单元格：正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。
3.网格线：n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线
```

#### 2.容器属性

```css
1.dispaly:grid 指定一个容器采用网格布局。
2.容器元素都是块级元素，但也可以设成行内元素
	div {
  		display: inline-grid;
	}
	为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、		vertical-align和column-*等设置都将失效
3.grid-template-columns 属性，grid-template-rows 属性
	.container {
  		display: grid;
  		grid-template-columns: 100px 100px 100px;
  		grid-template-rows: 100px 100px 100px;
	}
4.repeat函数减少重复写
    .container {
      display: grid;
      grid-template-columns: repeat(3, 33.33%);
      grid-template-rows: repeat(3, 33.33%);
    }
5.auto-fill 元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充
	.container {
  		display: grid;
  		grid-template-columns: repeat(auto-fill, 100px);
     }
6.fr 关键字
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
    }
    .container {
      display: grid;
      grid-template-columns: 150px 1fr 2fr;
    }
7.minmax()函数产生一个长度范围，表示长度就在这个范围之中
	grid-template-columns: 1fr 1fr minmax(100px, 1fr);
8.auto 关键字表示由浏览器自己决定长度。
	grid-template-columns: 100px auto 100px;
9.网格线的名称
    .container {
      display: grid;
      grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
      grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
    }
    上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。
	网格布局允许同一根线有多个名字，比如[fifth-line row-5]。
10.布局实例
	两栏式布局只需要一行代码
	.wrapper {
      display: grid;
      grid-template-columns: 70% 30%;
    }
	传统的十二网格布局，写起来也很容易
	grid-template-columns: repeat(12, 1fr);
11.grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）
    .container {
      grid-row-gap: 20px;
      grid-column-gap: 20px;
    }
    grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式
        grid-gap: <grid-row-gap> <grid-column-gap>;
		.container {
          grid-gap: 20px 20px;
        }
	根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和	row-gap，grid-gap写成gap。
    .container {
      row-gap: 20px;
      column-gap: 20px;
    }
12.grid-template-areas 属性 网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成
	.container {
      display: grid;
      grid-template-columns: 100px 100px 100px;
      grid-template-rows: 100px 100px 100px;
      grid-template-areas: 'a b c'
                           'd e f'
                           'g h i';
    }
13.grid-auto-flow 属性 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格 默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。
	grid-auto-flow: column;
	
	grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。设为row dense，	表示"先行后列"，并且尽可能紧密填满，尽量不出现空格	
	grid-auto-flow: row dense;
14.justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）
	.container {
      justify-items: start | end | center | stretch;
      align-items: start | end | center | stretch;
    }
	
	place-items属性是align-items属性和justify-items属性的合并简写形式
		place-items: start end;
15.justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。
	
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
	place-content属性是align-content属性和justify-content属性的合并简写形式
		place-content: space-around space-evenly;
```

#### 3.项目属性

```css
1.grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性
	项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线
	grid-column-start属性：左边框所在的垂直网格线
    grid-column-end属性：右边框所在的垂直网格线
    grid-row-start属性：上边框所在的水平网格线
    grid-row-end属性：下边框所在的水平网格线
    .item-1 {
      grid-column-start: 2;
      grid-column-end: 4;
    }
    .item-1 {
      grid-column-start: 1;
      grid-column-end: 3;
      grid-row-start: 2;
      grid-row-end: 4;
    }
    
    这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字
    .item-1 {
      grid-column-start: header-start;
      grid-column-end: header-end;
    }
    这四个属性的值还可以使用span关键字，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格	
    .item-1 {
      grid-column-start: span 2;
    }
2.grid-column 属性，grid-row 属性
	grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-	   start属性和grid-row-end的合并简写形式
	.item {
      grid-column: <start-line> / <end-line>;
      grid-row: <start-line> / <end-line>;
    }
    .item-1 {
      grid-column: 1 / 3;
      grid-row: 1 / 2;
    }
    /* 等同于 */
    .item-1 {
      grid-column-start: 1;
      grid-column-end: 3;
      grid-row-start: 1;
      grid-row-end: 2;
    }
3.grid-area 属性 grid-area属性指定项目放在哪一个区域。
    .item-1 {
      grid-area: e;
    }
    grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置
    .item {
      grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
    }
    .item-1 {
      grid-area: 1 / 1 / 3 / 3;
    }
4.justify-self 属性，align-self 属性，place-self 属性
    justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。

    align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目
	.item {
      justify-self: start | end | center | stretch;
      align-self: start | end | center | stretch;
    }
```



# ======js

## js 基础

### 1.JS 中的变量 varliable

> 变量:就是可变的量用来存储和代表不同值的东西

```
//创建变量的几种方式
//1.var
//2.const,let
//3.创建函数也相当于创建变量
function(){

}
//4.创建类也是创建了一个变量
class Person{}

```

### 2.js 中常用的数据类型

- 基本数据类型
  - boolean
  - string
  - number
    常规数字 NaN
  - 空指针 null
  - undefined
  - symbol 唯一值 
  - bigint
- 引用数据类型
  - 对象数据类型 Object
    - {} 普通对象
    - [] 数组对象
    - // 正则对象
    - Math 数学对象
    - 日期对象
  - 函数数据类型 function

#### 2.1 数字类型

- 数字类型
  - NaN 不是一个数，它属于数字类型
  - NaN 与任何值都不相等于自己也不相等 :NaN!=NaN
  - isNaN 检测一个值是否为有效数字,如果不是有效数字返回 true,反之 false
  - isNaN(10) false 是有效数字
  - isNaN('sdf') true 不是有效数字
  - isNaN('10') false 是有效数字(有内部转化机制)
  - Number('sdf') =>NaN isNaN(NaN) => true

##### 数字类型转化

- 把字符串转化为数字类型 只要有一个非数字就是 NaN（第一个点除外）
  - Number('12.5')=> 数字类型
  - Number('12.55.5') => NaN
- Boolean 转化成数字类型
  - Number(true) =>1
  - Number(false) => 0
  - isNaN(true) => false 是数字类型
  - **Number(null) => 0**
  - Number(undefined) => NaN
- 对象类型转化成数字类型
  - 引用类型都要通过 tostring 进行转换
  - Number({}) => NaN
  - {}.tostring =>Object
  - Number([]) =>0
  - [].tostring =>''=>0
  - Number([12]) =>12
  - [12].tostring =>'12'=>12
  - Number([12,24]) => NaN
  - [12,24].tostring =>'12,24'=>NaN
- parse 转化数字类型
  - parseInt('12.5px') =>12
  - parseFloat('12.5px') =>12.5
  - parseInt('width:12.5px') => NaN 对于字符串来说他是依次从左到右查找有效数字字符，直到遇到非数字字符停止查找，把找到的当作数字返回
- 浏览器默认转换是 Number 转换，不是 parse
- '=='比较时可能存在类型转换

#### 2.2 字符串数据类型

##### 其它类型转化成字符串

    + toString()
    + 字符串拼接

```
// null和undefined是禁止直接转化成toString，有定义但禁止使用
//   字符串拼接：除加法之外其它都是数学计算   有字符串+是字符串拼接
// 只要遇到字符串就是字符串拼接
//字符串+对象类型  对象类型要tostring转化

let a =10+null+true+[]+undefined+'珠峰'+null+[]+10+false
Number(null) =>0
Number(true) =>1
Number([])=>''就是一个字符串了
'11undefined珠峰null'+[] =>"11undefined珠峰null"
=>'11undefinded珠峰null10false'

注意如果数字遇到NaN就转化为NaN
12.5+NaN=>NaN
```

#### 2.3 Boolean 类型

#### boolean 类型转换

> 只有 0,NaN,'',null,undefined 五个值会转化成 false,其余都转换为 true,没有任何特殊情况

> 转换 Boolean 类型方式

- Boolean()
- !或！！
- if()条件
- if(1){console.log('true')}

#### 2.4 对象类型 所有的对象类型都是键值对方式存储

- 普通类型 Obj

```
let Person ={
    name:'zs',
    weight:156
}
//删除属性
//真删除：属性彻底删调
delete Person[1]
//假删除：属性还在，值为空
Person.weight = null

```

- 数组类型
  - 1.数组有 index 代表每一项
  - 2.length 是固有属性 x

#### 2.5symbol

```
1.symbol代表一个唯一值
console.log(Symbol('AA') === Symbol('AA')); //false
let symb = Symbol('BB');
console.log(symb === symb); //true 
```

#### 2.6bigint

```
bigint大数据值
当数值为number类型的时候有一个安全值Number.MAX_SAFE_INTEGER  9007199254740991

在对这个最大安全值进行运算时会不准确
9007199254740991+6
=》9007199254740996
这里就要用到bigint 已数字类型n结尾进行运算
9007199254740996n+6n
9007199254741002n
```



### 3.堆栈底层机制

> 栈内存

- 1.从电脑内存中分配出一块内存 ，用来执行代码

- 2.分配一个主线程用来自上而下执行代码

  > 栈内存中又开辟 变量存储空间 和 值存储空间

```
//创建一个变量的过程
let a=12
将a放到栈内存的变量存储空间
创建一个值为12把它放到当前栈内存当中的值存储空间中
=赋值其实就是让值和变量相互关联的过程

//基本类型：都是按值操作，所以也叫做值类型
//引用类型：操作的是对内存的地址（按引用地址操作的）
```

1.计算机会开辟一个栈内存供代码执行的环境称为执行环境栈

2.EC(G)全局对象，是一个全局执行的上下文

3.VO全局变量对象用来存放变量和值的地方

4.普通类型值直接存储在栈内存

5.引用类型对象栈内存中存储的是引用地址，真正的值存储在堆内存中

![image-20210604125849072](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210604125849072.png)



### 4.数据类型检测

- typeof [val] :用来检测数据类型得运算符
- instanceof: 用来检测当前是否属于某个类
- constructor :基于够着函数检测数据类型（也基于类得方式）
- Object.prototype.toString.call():检测数据类型得最好方法

> typeof:无法区分普通对象和引用对象类型

```html
typeof typeof typeof []
typeof[]=>'Object'
typeof 'Object'=>'string'
typeof "string" => "string"



typeof undefined => "undefined"
```

### 5.dom 操作

```
元素对象.style.xxx=xxx（js操作）   修改一个元素得值时如果行内元素没有定义，那么获取不到样式值

元素对象.style.xxx就是获取一个元素样式，如果没有在行内定义，获取不到
```

### 6.for 循环

```
for（var i=0;i<4;i+=2）{}
先执行条件，在指定循环体，在执行i+=2

关键词
continue:结束当前这轮循环（continue后面得代码不在执行）,继续执行下一轮循环

break:强制结束整个循环（break后面得代码不在执行）,结束整个循环
```

### 7.元素对象 Dom

```
console.dir(box)可以获取box得详细信息基本属性：id:操作元素得id值className:操作元素样式类innerHTML：含标签得元素值value:指定得元素值style:操作行内样式tagName:获取元素得标签名
```

### 8.function 类型

```
typeof undefined => undefined null==undefined =>true 双等号是null==undefined若没有传递实参那么形参就是undefinedfunction sum(n,m){    if(n===undefined){        n=0;    }    if(typeof m==='undefined'){        m=0;    }}//选项卡案例只有代码加载完才能看到页面，只有用户看到才能点击由于页面加载完,用户才可以点击,那么for循环在加载时就执行完了,最后索引变成了length,数组没有这个值解决方法：1.自定义元素属性item[i].index=i2.bind()函数3.闭包解决4.var改成let()()
```

### 9.关键字和保留字

```
关键字：    break    continue    if    else    for    switch    var    let    const    class    import    instanceof    typeof    this    return保留字：    boolean    float    int    double    long    char    debugger
```

### 10.常用得输出方式

- console.log/dir/table table 把数组以表格得形式输出出来
- 浏览器窗口弹窗 alert/confirm/prompt

```
三种方式都必须经过toString 转化为字符串三种方式会阻断代码得执行，必须点检过后才会执行
```

- document.write 和 alert 一样

```
console.log(alert(1))alert(1)表示执行函数，但没有返回值，所以alert得值为undefined
```

### 11.Number 和 parseInt 和 parseFloat 得区别

```
1.默认转化是用Number
2.Number转化采用c++机制如果有非数字字符=>NaN
3.parse采用先转化为字符串，从做向右查找如果遇到非数字就结束，最后返回查找得内容，如果一个都没有返回undefined
4.eg:Number('12px') =>NaN 
parseInt('12px') =>12
parseInt('adf123') =>undefined
parseInt('123adf') =>123
isNaN(null)=>false
Number(null)=>0
Number("")=>undefined
parseInt(null) => NaN
parseInt("") =>NaN
isNaN("") => false   ""=>0=>false
```

### 12.i++ ++i

let i ='10'
i=i+1 => '101'
i+=1 =>'101'
i++ => 11 i++和上述的完全不同是纯粹的数字运算

### 13.难度加大例题

```
> !(!"Number(undefined)")  =>true遇到!就要转换为bool类型没有包含 0,NaN,'',null,undefined五个值 所以 返回值为true> isNaN(parseInt(new Date()))+Number([1])+typeof undefined> Boolean(Number(""))+!NaN(Number(null))+Boolean("parseInt([])")+ typeof !(null) =>"2Boolean"> ！typeof parseFloat("0")parseFloat("0") =>0 typeof 0 =>"Number" =>!"Number" 除了 0,NaN,'',null,undefined这个五个值返回false，其它为true =>false
```

### 14.函数的底层机制

- 栈内存：储各种基本类型的变量，包括 Boolean、Number、String、Undefined、Null，\*\*以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。
- 堆内存：堆内存主要负责像对象Object这种变量类型的存储（引用类型）
- 堆：保存堆内存的代码字符串（比如函数体中的代码字符串）

### 15arugments 函数内置实参集合

```js
1.类型数组集合，集合中存储着，所有函数执行时传递点的实参信息2.无论是否设置形参，arguments都存在3.无论是否传递实参，arguments也都存在eg:任意数求和function sum(){    let total =null    for(var i=0;i<arguments.length,i++){    let item = Number(arguments[i])    if(isNaN(item)){        continue    }    total+=item    return item    }}sum(10,20,30)sum('10',20)
```

### 16.箭头函数

```js
var sum = (m,n) =>{    return m+n}var sum = (m,n) => m+n//赋值形参var sum = (m=0,n=0) => m+n//箭头函数没有arguments//但是有剩余运算符  ...arg是一个数组var sum =(...arg) => eval(arg.join('+'))
```

### 17.Math函数

>数学函数：它不是一个函数，它是一个对象，对象中存储许多操作数学的函数属性

##### Math中常用的属性和方法

Math.abs()
Math.PI;

//数字类型
Math.abs(-12.5) => 12.5
//传递的不是一个数字类型:先用number转换
console.log(Math.abs('-1')) =>1
console.log(Math.ads('-1px')) =>NaN

//向上取整和向下取整
Math.ceil()向上
MAth.foolr()向下

//最大值和最小值
Math.max()
Math.min()

//四舍五入
Math.round()

//开平方和计算次幂
Math.sqrt(9)
Math.pow(2,10)=>1024

//Math.random()随机数

//获取范围内的随机整数
   //获取n~m之间的随机整数
   Math.round(Math.random()*(m-n)+n)


### 18.数组

##### 18.1数组的增删改查

+ push最后插入 ary.push(30,'AA')可以插入多个值
+ unshift 开头插入第一项
+ pop末尾删除  delete也可以实现删除，但是数组的长度不会发生变化
+ ary.length-- 利用原生js也可以删除最后一向
+ shift 开头删除

+ splice方法实现数组的增加删除和修改
  splice(m,n) 从m开始删除，删除n个,没有n删除到末尾,返回删除掉的一个数组
  splice(m,n,x) 删除掉的部分会被x占据

```js
//清空数组var ary=[10,20,30,40,50]ary.splice(0)  console.log(ary)=>[20,30,40,50]
//删除最后一项ary.splice(ary.length-1)
//删除第一项ary.splice(0,1)
//增加ary.splice(1,0,'小李子')  => console.log(ary)  =>[20,'小李子'，30，40，50]ary.splice(1,0,'小李子'，'哈哈哈')  => console.log(ary)  =>[20,'小李子'，'哈哈哈'，30，40，50]
//向数组末尾增加ary.splice(ary.length,0,'aaa') =>ary =>[10,20,30,40,50,'aaa']
//向数组头添加ary.splice(0,0,'aaa')=> ary =>['aaa',10,20,30,40,50]
//向数组末尾增加方法1.ary.push2.原生ary[length]='aa'3.splice(ary.length,0,'aaa')
//向数组头添加1.ary.unshift2.ary.splice(0,0,'aaa')
//删除末尾1.ary.pop()2.ary.length--3.ary.splice(ary.length-1,1)
//删除第一项1.ary.shift2.ary.splice(0,1)
```

##### 18.2数组的查询和拼接

slice(m,n) 从索引m开始找到n(不包含n这一项)，把找到的以数组的形式返回
n不写找到末尾

```js
//数组的克隆var cloneAry = ary.slice(0)
```

##### 18.3数组的拼接concat

let ary1=[10,20]
let ary2=[50,60]
ary1.concat('aaa',ary2)   ary1=>[10,20,'aaa',50,60]

##### 18.4把数组转化为字符串toString  原数组不变

```js
let ary =[10,20]
let res = ary.toString()  res=>10,20 
```

##### 18.5join也可以把数组转化为字符串

```js
let ary =[10,20]
let res = ary.join('') 
res=> 1020let res = ary.join(' ') 
res=>10 20let res = ary.join('|') 
res=>10,20let res = ary.join('+')  
res => 10+20  
eval(res) =>res=>30   eval可以把字符串转化js表达式
```

##### 18.6 检测数组是否包含某一项

```
indexOf lastIndexOf检测当前项在数组中第一次或者最后一次出现位置的索引值，有就返回索引值，没有返回-1
includes(es6) 有就返回true，没有就返回false
```

##### 18.7 数组排序

```js
//revese把数组倒叙，排列后的新数组，原数组改变
//sort 排序var ary =[10,23,8,6]ary.sort() ary=>[10,23,6,8] sort如果没有传参，无法处理两位数以上的数字，会以第一位数字来排序
//a,b是相邻两项  return a-b实现升序有小到大，b-a实现降序由大到小ary.sort((a,b)=>{    return a-b })
```

##### 18.8遍历数组的方法

forEach、map、filter、find、reduce、every、some

+ forEach
  ary.forEach((item,index)=>{

}) 

```js
1.forEach:arr.forEach( function(item){            console.log(item)        } )
2.map：映射,将循环每一项，返回处理后的每一项，形成新数组var newArr = arr.map( function(value,index){    console.log(value + '---' + index)    return value + 10})
3.filter 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。	array.filter(function(currentValue,index,arr), thisValue)	array.filter(item=>{        return item>10    })
4.find find()方法返回数组中符合测试函数条件的第一个元素。否则返回undefined arr.find((item)=>{	return item.age == '18'})
5.reduce  表示arr.reduce(function(prev,cur,index,arr){...}, init);prev 表示上一次调用回调时的返回值，或者初始值 init;cur 表示当前正在处理的数组元素；index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；init 表示初始值。eg:求数组项之和var sum = arr.reduce(function (prev, cur) {    return prev + cur;},0);
 6.every every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。
 7.some some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。8.entries 返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。    var fruits = ["Banana", "Orange", "Apple", "Mango"];	fruits.entries();    [0, "Banana"]	[1, "Orange"]	[2, "Apple"]	[3, "Mango"]
```




##### 18.9数组去重

```js
  // 方案一：
        var ary = [1, 2, 3, 3, 3, 2, 1]
        var newArray = []
        for (var i = 0; i < ary.length; i++) {
            let newItem = ary[i]
            if (newArray.includes(newItem)) { continue }
            newArray.push(newItem)
        }
        console.log(newArray)
        // 方案二
        for (var i = 0; i < ary.length; i++) {
            var item = ary[i]
            for (var j = i + 1; j < ary.length; j++) {
                var compare = ary[j]
                if (compare === item) {
                    ary.splice(j, 1);
                    //这里会存在数组塌陷问题  length会发生变化 
                    j--        } 
            }}
                    // 方案三 ：用对象的方式去重（比前两种更好）
                    var ary = [1, 2, 3, 3, 3, 2, 1]
                    var obj = {}
                    for (var i = 0; i < ary.length; i++) {
                        let item = ary[i]
                        //判断对象是否存在了对应属性
                        if (obj[item] !== undefined) {        //删除数组中
                            ary.splice(i, 1)
                            //注意数组塌陷
                            i--
                            continue
                        }
                        obj[item] = item
                    } console.log(ary)
                    //用splice删除会存在数组塌陷，性能不好
                    //优化：找到重复的项时用最后一项的值替换掉当前的值，最后一项删掉
                    var ary = [1, 2, 3, 3, 3, 2, 1]
                    var obj = {}
                    for (var i = 0; i < ary.length; i++) {
                        let item = ary[i]
                        //判断对象是否存在了对应属性
                        if (obj[item] !== undefined) {
                            //最后一项的值赋值给第一项
                            ary[i] = ary[ary.length - 1]
                            ary.pop()
                            i--
                            continue
                        }
                        obj[item] = item
                    } console.log(ary)
                    //    方案四：基于es6的数组去重Setlet
                    ary = [10, 8, 6, 5]
                    ary = [...new Set(ary)]
```

### 19.字符串中常用的方法

##### 19.1 charAt和charCodeAt

charAt 根据索引获取指定位置的字符 没有就返回空字符串不是undefined
charCodeAt 根据字符获取该字符的ASCII编码（unicode编码值）

##### 19.2 substr substring  slice

```
substr(n,m) 从索引n开始截取m个（包含m)substring(n,m) 从索引n开始找到索引m处（不含m）slice(n,m) 和substring类似都是找到索引为m处，但是slice可以支持负数作为索引，其余两个方法时不可以的
```

##### 19.3 indexOf lastIndexOf includes

```
indexOf(x,y) :获取x字符第一次出现的位置，y是控制开始查找的位置
lastIndexOf(x):查找最后一次出现的位置//还可以验证字符是否存在
str.indexOf('s')===-1//indexOf可以查找一个整体是否存在，但返回是整体第一个字符出现的位置//includes返回true或false
```

##### 19.4 toUpperCase toLowerCase大小写转换

str.toUpperCase()

##### 19.5 split

split()把字符串拆分，按指定字符拆分

##### 19.6 replace

```js
let str ='xxs@fdf@sww'str.replace('@','-') => 'xxs-fdf@sww' replace只能替换一次//可以用正则str.replace(/@/g,'-')
```

### 20. 字符串处理日期

```js
let str = '2019-07-12 06:42:56'//1.replace 来直接替换//2.获取指定符号索引，基于substring截取每一项let n = indexOf('-')let y=lastOf('-')let r=indexOf(' ')let s=indexOf(':')let f =lastOf(':')let year = str.substring(0,n)let mouth= str.substring(n+1,y)let day= str.substring(y+1,r)let shi = str.substring(r+1,s)let fen =str.substring(s+1,f)let miao = str.substring(f+1)//3用split进行划分let ary=str.split(' ')let m =ary[0].split('-')let n = ary[1].split(':')//4.用正则的方式let ary =str.split(/?: |:|-/g) =>["2019","07","12","06","42","56"]
```

### 21.日期对象

let time = new Date()

```
1.获取到的是本地的时间，是可以修改的
2.Fri Aug 28 2020 15:32:45 GMT+0800 (中国标准时间)  获取的是一个日期格式的对象
```

标准日期提供了一些方法来操作日期格式

+ getFullYear() 
+ getFullMouth() 0~11月
+ getDate  获取日
+ getDay 获取星期0~6周日到周六
+ getHours()
+ getMinutes()
+ getSeconds()
+ getMilliseconds()
+ getTime()获取当前日期距离1970/1/1 00：00：00这个日期的毫秒差

new Date().toLocaleDateString() => 直接获取年月日 "2020/8/28"
new Date().toLocaleString() =>获取完整的日期字符串 "2020/8/28 下午3:47:57"

```js
new Date() 除了获取本地时间，还可以把一个时间格式字符串转换为标准的时间格式new Date("2019/07/12")// 支持的格式yyyy/mm/ddyyyy/mm/dd  hh:mm:ssyyyy-mm-dd 这种格式ie不支持let Time='2019-01-20 06：04：23'// 用正则拆分let ary = /(?:-| |:)/g  //?:只匹配不捕获
```

### 22.Dom元素

##### 22.1获取Dom元素的九种方式

document.getElementById
document.getElementsByTagName
document.getElementsByClassName
document.getElementByName 获取指定tag标签的name属性
document.head/document.body/document.Element获取页面中的HEAD/BODY/HTML
document.qeruySelector通过选择器获取指定的元素对象
document.querySelectorAll通过选择器获取到指定元素的集合

##### 22.2 js中节点之间的关系

```js
1.childNodes 获取所有的子节点
2.children:获取所有的元素子节点（子元素标签）
3.firstChild 获取第一个子节点
4.lastChild 获取最后一个子节点
5.firstElementChild和lastElementChild 获取第一个和最后一个元素子节点（ie678不兼容）
6.previousSibling 获取上一个哥哥节点
7.nextSibling 获取下一个弟弟节点
8.previousElementSibling/nextElementSibling 获取哥哥弟弟元素节点<ul id="box">    <li>1</li>x    <li>2</li>    <li>3</li>    <li>4</li></ul>box.childNodes:获取所有的子节点(包含所有节点，空格和换行符也算) => [text,li,text,li ....]box.children:获取所有的元素子节点  =>[li,li,li,li] ie678不兼容//封装一个方法兼容ie678 获取元素子节点function children(context){//获取所有的子节点var res = [],nodeList = context.chilNodes// 遍历所有字节点然后找到所有的子元素节点for(var i=0;i<nodeList.length;i++){  let item =  nodeList[i]  if(item.nodeType===1){    //nodeType节点类型为1就是元素类型节点    res.push(item)  }}return res}//获取上一个哥哥节点function prev(context){  var pre = context.previousSibling  while(pre.nodeType!==1){    //如果找到的不是当前元素节点的哥哥节点，就继续向上找    pre = pre.previousSibling  }  return pre}
```

##### 22.3 节点的类型

nodeType
1.元素节点Element nodeType:1
2.属性节点Attr nodeType:2
3.注释节点Comment nodeType:8
4.文档节点Document nodeType:9

![image-20200829164317285](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200829164317285.png)

##### 22.4在js中动态增删改元素 

createElement 创建元素对象
createTextNode 创建文本对象
appendChild  把元素添加到容器的末尾 容器.appendChild(元素)
insertBefore 把元素添加到指定容器中指定元素的前面 容器.insertBefore([新增元素],[指定元素])
cloneNode(true/false) 克隆元素或节点   true是深克隆，false是浅克隆
removeChild 移除容器中的某个元素

```js
appendChild:
//创建一个元素
var box = document.createElement('div')
//创建一个文本
let text = document.createTextNode('珠峰培训')
//追加元素到容器
box.appendChild(text)
insertBefore:
//放到指定元素的前面
let box =document.getElementById('box')  
//box指定元素
let text = document.createTextNode('珠峰培训') 
//添加元素
box.parentNode.insertBefore(text)
//另外常用：
document.body.insertBefore(box,text)
```


```
// 1.节点或元素的克隆元素或节点深浅克隆的区别深克隆会克隆当前元素节点以及子节点或子元素节点
```

##### 22.5setAttribute/getAttribute/removeAttribute设置获取移除元素的自定义属性

```js
   <button>按钮1</button>    <button>按钮2</button>    <button>按钮3</button>    <script>        var btns = document.querySelectorAll('button')        // for(var i=0;i<btns.length;i++){        //     //用点的方式设置自定义属性（该对象的堆内存中添加了一个自定义属性）        //     btns[i].index = i        //     btns[i].onclick = function(){        //         alert(this.index)        //     }        // }        for(var i=0;i<btns.length;i++){            //基于setAttribute把属性信息写到了元素标签的结构上，该结构可以在元素节点上看到            //<button data-index="0">按钮1</button>           btns[i].setAttribute('data-index',i)           btns[i].onclick = function(){               alert(this.getAttribute('data-index'))           }        }    </script>
```

### 23深浅拷贝

```js
 var obj = { age: 20, name: '张三', address: { city: '重庆' }, hobby: ['baskatball', 'football'] }
        //浅拷贝
        var obj2 = obj
        obj2.address.city = '武汉'
        console.log(obj.address.city)
        //深拷贝
        var obj1 = deepClone(obj)
        obj1.address.city = '北京'
        console.log(obj.address.city)
        function deepClone(obj = {}) {
            //判断obj是否是普通类型，如果是普通类型直接返回
            if (typeof obj !== 'object' || obj == null) {
                return obj
            }
            //返回值初始化
            let result
            if (obj instanceof Array) {
                result = []
            } else {
                result = {}
            }
            //递归赋值
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    result[key] = deepClone(obj[key])
                }
            }
            return result
        }
```

### 24.let和const

```js
1.在浏览器开辟栈内存供代码自上而下执行之前，不仅存在变量提升的操作，还有很多其他的操作=>'词法解析'和'词法检错''词法解析'和'词法检错'：就是执行代码之前检测是否有语法错误如果出现代码就不再执行        console.log('1')        let a = 12        console.log(a)        let a=13  //Uncaught SyntaxError: Identifier 'a' has already been declared        console.log(a)
```

## js高级

#### 1.堆栈内存机制

1.1浏览器默认会开辟一个内存来执行代码-栈内存

1.2会产生一个全局执行上下文EC来区分那个区域执行代码，如果是函数会形成私有上下文

1.3将执行上下文放入栈内存中执行（包含VO全局变量对象存储当前上下文声明的变量）

![堆栈内存1](D:\web\note\img\堆栈内存1.png)

1.4引用类型会专门开辟一个空间（堆内存）来存放引用类型值

![引用类型](D:\web\note\img\引用类型.png)

1.5全局执行上下文存在一个GO全局对象里面存放一些通用方法

![全局对象](D:\web\note\img\全局对象.png)

1.6成员变量存在访问优先级

![成员变量访问优先级](D:\web\note\img\成员变量访问优先级.png)

1.7函数执行步骤，作用域链查找机制，垃圾回收机制

![堆栈内存2](D:\web\note\img\堆栈内存2.png)

#### 2.闭包

##### 2.1闭包的形成

返回的函数地址被上一级上下文所f引用，所以返回函数执行完毕内存得不到释放，然后形成了闭包

![闭包形成](D:\web\note\img\闭包形成.png)

##### 2.2闭包练习

f(7)和f(10)是同一个函数作用域内的

![闭包习题1](D:\web\note\img\闭包习题1.png)

2.3闭包练习

释放得是上下文，函数执行会形成一个堆，释放得是上下文，如果当前上下文，被当前上下文以外得暂用，则不会释放

![闭包习题2](D:\web\note\img\闭包习题2.png)

##### 2.4闭包总结

```
闭包：
函数运行得一种机制
函数执行会形成一个私有上下文	，如果上下文得某些内容（一般是堆内存地址）被上下文以外得一些事物所占用，则当前上下文不能被释放【这是垃圾回收机制所定】=》"闭包"形成一个不被释放得上下文
作用：
保护：保护私有变量和外界互不影响
保存：上下文不被释放，那么上下文中得“私有变量”和“值”都会被保存起来，可供下级上下文使用

弊端：大量使用闭包，会使栈内存过多，页面渲染变慢，性能会受到影响
```

##### 2.5循环中得闭包

![事件点击闭包问题](D:\web\note\img\事件点击闭包问题.png)

```js

/*
 * 闭包：函数运行的一种机制（不是某种代码形式）  
 *   + 函数执行会形成一个私有上下文，如果上下文中的某些内容(一般指的是堆内存地址)被上下文以外的一些事物(例如:变量/事件绑定等)所占用，则当前上下文不能被出栈释放「浏览器的垃圾回收机制GC所决定的」 =>“闭包”的机制:形成一个不被释放的上下文
 *     + 保护：保护私有上下文中的“私有变量”和外界互不影响
 *     + 保存：上下文不被释放，那么上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用
 *   + 弊端:如果大量使用闭包，会导致栈内存太大，页面渲染变慢，性能受到影响，所以真实项目中需要“合理应用闭包”；某些代码会导致栈溢出或者内存泄漏，这些操作都是需要我们注意的；
 *     
 */




// 实现不了：我们要清楚原因
 var buttons = document.querySelectorAll('button'); //=>NodeList“类数组”集合
for (var i = 0; i < buttons.length; i++) {
    buttons[i].onclick = function () {
        console.log(`当前点击按钮的索引：${i}`);
    };
} 

// 方案一：基于“闭包”的机制完成 「每一轮循环都产生一个闭包，“存储对应的索引”；点击事件触发，执行对应的函数，让其上级上下文是闭包即可」
 var buttons = document.querySelectorAll('button');
for (var i = 0; i < buttons.length; i++) {
    // 每一轮循环都会形成一个闭包，存储私有变量i的值（当前循环传递的i的值）
    //   + 自执行函数执行，产生一个上下文EC(A)  私有形参变量i=0/1/2
    //   + EC(A)上下文中创建一个小函数，并且让全局buttons中的某一项占用创建的函数
    (function (i) {
        buttons[i].onclick = function () {
            console.log(`当前点击按钮的索引：${i}`);
        };
    })(i);
} 

var buttons = document.querySelectorAll('button');
for (var i = 0; i < buttons.length; i++) {
    buttons[i].onclick = (function (i) {
        return function () {
            console.log(`当前点击按钮的索引：${i}`);
        };
    })(i);
} 

 
// 基于LET这种玩法也是“闭包”方案
let buttons = document.querySelectorAll('button');
for (let i = 0; i < buttons.length; i++) {
    buttons[i].onclick = function () {
        console.log(`当前点击按钮的索引：${i}`);
    };
} 


// 方案二：自定义属性 「性能强于闭包」
 
var buttons = document.querySelectorAll('button');
for (var i = 0; i < buttons.length; i++) {
    // 每一轮循环都给当前按钮(对象)设置一个自定义属性：存储它的索引
    buttons[i].myIndex = i;

    buttons[i].onclick = function () {
        // this -> 当前点击的按钮
        console.log(`当前点击按钮的索引：${this.myIndex}`);
    };
} 


// 方案三：事件委托 「比之前的性能提高40%-60%」
// + 不论点击BODY中的谁，都会触发BODY的点击事件
// + ev.target是事件源：具体点击的是谁
document.body.onclick = function (ev) {
    var target = ev.target,
        targetTag = target.tagName;

    // 点击的是BUTTON按钮
    if (targetTag === "BUTTON") {
        var index = target.getAttribute('index');
        console.log(`当前点击按钮的索引：${index}`);
    }
};
```



#### 3.git

git是一个分布式代码版本控制系统

svn是一个集中式的管理

集中式svn

![image-20200910104449065](http://null/)

分布式git

![image-20200910104526312](http://null/)

##### git的基本操作

git config -l git配置基本信息

![image-20200910105230915](http://null/)

1.git init 在某目录下初始化仓库，该目录下存在.git文件，仓库版本信息都存储在这里

2.gitignore 表示git提交时所忽略的文件

git的工作流程

- 工作区：编辑代码的地方
- 暂存区：临时存储要生成代码的地方
- 历史区：生成历史版本的地方

```
git status
```

**`把工作区提交到暂存区`**

git status 查看代码或则文件的状态

![image-20200910111753828](http://null/)

一般用 git add . 或则 git add -A

**`暂存区到历史区`**

![image-20200910112406072](http://null/)

![image-20200910112928207](http://null/)

git 和gitHub同步

1.让本地的仓库和远程仓库简历关联

git remote -v 查看关联信息

git remote add xxx（origin） [远程仓库地址] //建立关联

git remote remove xxx //移除关联

2.把本地仓库代码推送到远程仓库上，或则从远程仓库上拉取最新的信息到本地

**再推送之前我们都应该先拉取**

git pull origin(这个名字适合远程仓库关联的名字) master

//推送到远程仓库

git push origin master

```
关联仓库的原始做法：
git init  
git remote  add origin [git仓库地址]

简单做法
git clone  [远程仓库地址][克隆后的名字:可以不设置，默认时仓库名]
```

#### 4.之前笔记

##### 2.变量提升

当栈内存形成，js代码自上而下执行之前，浏览器首先会把带有"**var**和**function**"的关键词提前"声明"或则"定义"

=> 声名 var a (udefined)

=> 定义 a=2 (定义其实就是赋值操作)

[变量提升阶段]

=》 带var的只声名未定义

=》带function的声名和赋值都完成了

=》 变量提升只存在当前作用域中

=》在全局作用域下声名的函数或变量是全局变量，同理私有作用域下定义的变量是私有变量

=》当代码执行遇到创建函数这部分代码后， 可直接跳过（因为在提升阶段就已经完成了函数的辅助操作了）

```
console.log(a) //undefined
var a = 12;
```

全局或私有变量都是先进行变量提升讲全局作用域下和私有作用下的var和function进行定义和申明

![image-20200910152923042](http://null/)

在全局作用域下声名的变量相当于给window添加了一个属性

```
console.log(a)  //undefined

console.log(window.a) //undefined

var a=12;

console.log(window.a) //12
```

全局变量和window属性存在“映射机制”

```
a=13;
window.a //13
```

不带var的区别

```
      console.log(window.a)  //undefined
        //此时不带var ，是给window添加一个属性
        a = 12;  
        console.log(a);  //12
        console.log(window.a)  //12
var a=12,b=12  // b带Var
var a=b=12    //b不带var    =》 var a=12 b=12
例题
   //全局作用域
        console.log(a,b)  //a,b =>undefined
        var a=12,b=12
        function sum(){   //这里是私有作用域
            console.log(a,b) //a=undefined,b=12  a是Var定义存在私有变量提升是私有变量，与全局没有关系，此时是undefined
                            //b没有var定义，会向上一级及全局作用域查找 所以 b=12
            var a=b=13
            console.log(a,b) // a=13,b=13   b=13改变了全局变量的值12
        }
        sum()
        console.log(a,b)  //a=12,b=13  a,b指的是全局变量的值
```

![image-20200910161132583](http://null/)

```
   function fn(){
          b=13  //此时没有变量提升会向上一级查找，没有找到这个变量，会转换成win下的属性
          console.log(b)  //13
      }
      fn()
      console.log(b) //13
   fn()  //报错undefined
        sum()
        //var fn 存在变量提升此时 之前fn=undefined
        var fn = function(){
            console.log('123')
        }
        fn()
        function sum(){
            console.log('123');
        }


		//if条件中不管条件是否成立都要变量提升
var fn = 12
function fn(){
}

此时fn和fn重名
   //首先fn会发生变量提升   最走到最后一个
        fn()  //4
        function fn(){
            console.log('1')
        }
        fn()  //4
        function fn(){
            console.log('2')
        }
        fn()  //4
        function fn(){
            console.log('3')
        }
        var fn = 2
        fn()  //报错 fn不是一个函数了
        function fn(){
            console.log('4')
        }
        fn()
```

##### 3.es6箭头函数不存在变量提升

```
console.log(a); //报错
let a=12
console.log(window.a) //undefined es6中切断了全局变量的和window的映射机制
```

暂时性死区

```
 var a=12;
     if(true){
         console.log(a)
         let a=13
     }
```



```
 var ary = [12,23];
    function fn(ary)  {
        console.log(ary); //[12,23]
        ary[0] = 100;
        ary = [100];//这里赋值成了一个新的引用类型
        ary[0] = 0;
        console.log(ary); //[0]

    }
    fn(ary);
    console.log(ary) //[100,23]
```

函数上级作用与问题

![image-20200910182519350](http://null/)

例题

```
  var n=10;
        function fn(){
            //f的作用域与函数创建时的作用域有关所以这里是fn的私有作用域中
            var n=20;
            function f(){
                // n=20
                n++
                console.log(n) 
            }
            f()
            return f
        }
        var x = fn();
        x();
        x();
        console.log(n)

        //21,22,23,10
```

![image-20200910183252745](http://null/)

##### 4.js中的堆栈内存

堆内存： 存储引用数据类型（对象：键值对 函数：代码字符串）

栈内存：提供js代码的执行环境和存储基本类型值

堆内存释放：让所有引用堆内存空间地址的变量赋值为null

栈内存释放：一般情况下，当函数执行完成所形成的私有作用域（栈内存）

​	1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用，不会被释放

​	2.全局内存只有页面关闭才会被释放

​	3.如果当前栈内存没有释放，那么之前栈内存中存储的基本值也不会被释放

##### 5.闭包

函数执行形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为"闭包"

```
   //柯里化函数
        function fn() {
            return function () {

            }
        }
        var f = fn()

        //惰性函数
        var utils = (function(){
            return {

            }
        })()
```

> 在项目中尽量减少闭包的使用，减少性能损耗

> 闭包的作用：保护私有变量不受外界干扰

> ​	保存作用形成不被销毁的私有内存，把一些值保存下来方便后面的调用



​	选项卡的方案：

​	1.自定义属性

![image-20200912100617307](http://null/)

​	2.闭包的方式

​	此时看的是上级作用域，作用域的产生式函数的执行，普通方式的作用域是全局的，而此时的作用域是自执行函数的私有作用域，每一次函数执行都会形成一次私有作用域

![image-20200912101246459](http://null/)

​	![image-20200912101412652](http://null/)

闭包方式二：

![image-20200912101547649](http://null/)

3.let块级作用域

{}会行成一个私有块级作用域，每一次循环都会形成一次块级作用域

![image-20200912101733882](http://null/)

##### 6.单例设计模式(singleton)

1.表现形式

var obj = {

...

}

> 在单例设计模式中 obj被称为”命名空间“而不只是对象名，把描述事物的属性存放到命名空间中，多个命名空间是独立的，互不冲突

作用：把描述同一件事物的属性和特征进行分组归类（存储在同一个堆内存中），因此避免了全局变量之间的冲突和污染

2.单例设计模式的由来

> 每一个命名空间都是JS中Object这个基类的实例

高级单例模式

在给命名空间赋值时，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域AA，在AA中创建一个堆内存，把堆内存的地址赋值给命名空间

```
  var namespace = (function () {
            var n= 12
            function fn(){

            }
            return {
                fn:fn
            }
        })()
```

例题

//要搞清楚this的执向，和n的不同

```
var n = 2;
var obj={
    n:3,
    fn:(function (n) {
        n*=2;
        this.n+=2;
        var n=5;//这个是私有变量n
        return function (m) {
            this.n*=2;
            console.log(m + (++n));
        }
    })(n)//=>obj.n会报错  
};
var fn = obj.fn;
fn(3); //window
obj.fn(3); //obj
console.log(n, obj.n);
```

![image-20200912113324393](http://null/)

##### 7.OP面向对象

```
对象：万物皆对象
类：对象的具体细分（按照功能特点进行分类：大类、小类）
实例：类中具体的一个事物（拿出类别中的具体一个实例进行研究，那么当前类别下的其它实例也具备这些特点和特征）
```

![image-20200912144420137](http://null/)

###### 7.1基于构造函数创建自定义类

​	在普通函数执行的基础上加上一个new,就不是普通函数执行而是够着函数执行，当前函数称之为”类名“，

new出来的是一个实例

```
   function Fn(){

        }
        var f = new Fn()
```

js中创建创建值得方式有两种

1.字面量方式

2.构造函数方式

var obj = {}

var obj = new Object()

两种方式都是创建实例得方式，而var xxx= {} 是单例设计模式

> 基本数据类型两种模式创建得值不一样
>
> var num1 = 12 //=>'number'
>
> var num2 = new Number(12) =>'object'

两种值类型不一样，但两者都是创建出来得实例

###### 7.2构造函数执行机制

普通函数执行：

```
1.创建一个私有函数作用域
2.形参赋值
3.变量提升
4.代码执行
5.栈内存释放问题
```

new Fn()函数执行：

```
1.和普通函数一样，形成一个私有作用域
2.【构造函数独有】 在js代码自上而下执行之前，首先在当前形成得私有栈中创建一个对象（创建一个堆内存，暂时不存储任何东西）并让主体函数得this指这个新得堆内存（this==创建得对象）
3.代码自上而下运行
4.【构造函数独有】代码执行完成，把之前创建得堆内存地址返回（浏览器返回）
```

![image-20200912152646187](http://null/)

![image-20200912152932820](http://null/)

总结：开始创建得对象其实就是fn得一个实例，让this得指向这个实例，[代码执行中得This.xxx](http://xn--This-zf5fs1bi49esye8v0d0b8a.xxx) =xxx就是给实例加一个私有属性，最后浏览器会把默认创建得实例返回，供外面接受

> 够着函数中如果写了return ，并且return返回得是一个基本值，那么最后还是会返回实例
>
> 但如果return 一个引用值，那么默认实例会被覆盖此时接受到得结果，就不在是当前类得实例了
>
> 所以构造函数执行得时候，尽量减少return得使用，防止实例被覆盖

```
function Fn(){
	var n=10
	this.m = n;
	 return {name:'haha'}
}
var f = new Fn();
 console.log(f)
```

###### 7.3prototype

[函数]：

普通函数，类

[对象类型]：

普通对象、数组、正则、Math、

实例是对象类型（除了基本类型创建得字面量值）

prototype也是对象类型

函数也是对象类型

> 原型链三组成

```
1.所有得函数数据类型都天生带有一个属性：prototype(原型)，这个属性得值是一个对象，浏览器会默认给它开辟一个堆内存
2.在浏览器给prototype开辟得堆内存中又一个天生自带得属性：constructor,这个属性存储得值是当前函数本身
3.每一个对象都有_proto_得属性，该属性指向该实例所属类得prototype
```

原型链：

![image-20200912175621485](http://null/)

它是一种基于_prot0_ 得向上查找机制，当我们操作实例中得某个属性或则方法得时候，先查找自己私有空间得属性和方法。

没有找到，基于_proto *找所属类得prototype,如果找到就用这个共有得，没有找到，基于原型上得* _ proto_继续向上查找，一直找到Object.prototype为止

![image-20200912175528961](http://null/)

###### 7.4函数得三种角色

1.普通函数

->堆栈内存释放

->作用域链

2.类

->原型：prototype

->原型链：_proto _

->实例

3.对象

->和普通得对象没有区别，对键值对得增删改查

> 对象和实例得区别例子：

​	juqery封装原理也有一部分是写在原型上，一部分当作普通对象

```
//=>JQ这个类库中提供了很多的方法,其中有一部分是写在原型上的,有一部分是把它当做普通对象来设置的
function () {
    function jQuery() {
        //...
        return [JQ实例]
    }
    jQuery.prototype.animate=function(){}
    //...
    jQuery.ajax=function(){}
    //....
    window.jQuery = window.$ = jQuery;
}();
// $().ajax() //=>调不了   //相当于创键了一个实例，而实例不能调用属性，只能调用原型得方法和属性
// $().anaimte() //=>这样可以调取
// $.ajax() //=>直接的对象键值对操作
// $.animate() //=>对象上没有animate这个属性，这个属性在和实例相关的原型上
```

阿里面试题

```
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function BBB() {
    console.log(2);
};
Foo.prototype.getName = function AAA() {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}

Foo.getName();//=>2 把Foo当做一个对象，找Foo的私有方法执行
getName();//=>4 执行全局下的GET-NAME
Foo().getName();//=>1 先把FOO当做普通函数执行,执行返回的结果在调取GET-NAME执行
getName();//=>1 执行的依然是全局下的GET-NAME

console.log(new Foo.getName());;//=>A:(Foo.getName) =>new A() =>2//new一个函数相当于执行这个函数
new Foo().getName();//=>B:new Foo() =>B.getName() =>3
console.log(new new Foo().getName());//=>C:new Foo() =>new C[Foo的实例].getName() =>D:C.getName =>new D(); =>3  (先计算new Foo()创建一个实例f，然后new f.getName()，先找到f.getName，在把这个函数new一下，最后其实相当于把f.getName当做一个类，返回这个类的一个实例)
```

![image-20200912193428557](http://null/)

###### 7.5 call 、apply、bind

> 1.call

​	Fn.call([this],[param]....)

​	Fn.call当前实例通过原型链得查找机制，找到Function.prototype原型上得call方法

​	Fn.call()将call方法执行

> ​	call方法执行时，内部进行了一些处理

​	=》首先把操作函数中得this关键字变为call方法得第一个参数

​	=》把call方法得第二个以及第二个以后得实参获取到，传递给函数

```
/*
Function.prototype.call=function callAA(){
    //=>1.把THIS(FN)中的"THIS关键字"修改为第一个参数值(OBJ)
    //=>2.把THIS(FN)执行,把第二个及以后接受的参数值传递给函数(10,20)
    //this(10,20)
};
fn.call(obj,10,20)
*/
function fn1(){console.log(1);}
function fn2(){console.log(2);}
fn1.call(fn2);//=>找到CALL-AA把它执行,CALL-AA中的THIS是FN1,第一个参数传递的是FN2  =>在CALL-AA中执行的是FN1 =>1

fn1.call.call(fn2);//=>找到CALL-AA让它执行,CALL-AA中的THIS是FN1.CALL,第一个参数是FN2  (把FN1.CALL中的THIS变为FN2，再让FN1.CALL执行  =>先找到CALL-AA，把它执行，只不过此时它中的THIS是FN2 =>让FN2中的THIS变为UNDEFINED，因为执行FN1.CALL的时候没有传递参数值，然后让FN2执行)  =>2

Function.prototype.call(fn1);//=>先找到CALL-AA把它执行，它中的THIS是Function.prototype =>让F.P中的THIS变为FN1,然后让F.P执行,F.P是一个匿名函数也是一个空函数，执行没有任何的输出

Function.prototype.call.call(fn1);//=>先找到CALL-AA把它执行，它中的THIS是F.P.CALL =>把F.P.CALL中的THIS修改为FN1,让F.P.CALL执行  =>F.P.CALL(CALL-AA)第二次把它执行(此时它里面的THIS已经是FN1) =>这一次其实在CALL-AA中是让FN1执行 =>1
//<==> fn1.call.call(fn2)
//<==> fn1.call===Function.prototype.call ：true

fn1.call.call.call.call.call(fn2);
//=>fn1.call.call.call.call===Function.prototype.call
```

call中得细节

```
1.非严格模式下，如果不传参数，或则第一个传递的是null，undefined this指向window
2.严格模式下，第一个参数是谁就指向谁（包括null、undefined、 ）
```

apply

```
apply：和call基本上一模一样，唯一区别在于传参方式
  fn.call(obj,10,20)
  fn.apply(obj,[10,20]) APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递
```

bind

```
 bind：语法和call一模一样，唯一的区别在于立即执行还是等待执行
 fn.call(obj,10,20) 改变FN中的THIS,并且把FN立即执行
 fn.bind(obj,10,20) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~8）
```

eval:把字符串转化为js表达式

（） 括号表达式

```
//用小括号包起来，里面有很多项（每一项用逗号分隔），最后只获取最后一项的内容（但是会把其它的项也都过一遍）
(function(){
    console.log('1')
},functiong(){
 console.log('2')
 })()  // 2

//不建议过多使用括号表达式，因为会改变THIS

let fn=function(){console.log(this);}
let obj={fn:fn};
(fn,obj.fn)();//=>执行的是第二个OBJ.FN，但是方法中的THIS是WINDOW而不是OBJ
(obj.fn)();//=>this:obj
    //数组中获取几种最大值的方式
            // 方式一  排序的方式i
                let ary = [12, 13, 14, 23, 24, 13, 15, 12];
                let max = ary.sort(function(a,b){
                    return b-a
                })[0]
                console.log(max)
            //方式二 假设法
            var max1 = ary[0]
            for(var i=1;i<ary.length;i++){
                let item = ary[i]
                max1 = item>=max1?item:max1
            }
            console.log(max1)
            //方式三 Math.max  Math.max(只接受一串逗号分隔得数字) 
                //我们需要一个值一个值传递给函数，传递数组只能算传递了一个值
                //[12,24,13].toString()  //"12,24,13" 不能达到要求
                //1.eval：把字符串转换为JS表达式
            //方式三基于Eval
            console.log(eval("Math.max(" + ary.toString() + ")"));   
            
            //方式四  Math.max基于apply
            //=>利用了APPLY的一个特征：虽然放的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数
            Math.max.apply(null,ary)
            
            //方式五 es6得展开运算符
            console.log(Math.max(...ary))
```

###### 7.6如何让类数组使用数组方法

```
/*
 * 编写一个方法fn，实现任意数求平均数（去除数字中的最大和最小，然后再算平均数，保留小数点后面两位）
 */
// let fn = function () {
//     //=>arguments:类数组(不能直接调取数组原型上的方法)
//     //1.先给ARGUMENTS排序(不能直接使用SORT方法),把排序后的值去掉首位(干掉最大值和最小值)
//     //2.把剩下的值求和,除以总长度,求出平均数即可
//
//     //arguments.sort()//=>Uncaught TypeError: arguments.sort is not a function
//     //=>把ARG类数组转换为数组ARY
//     let ary = [];
//     for (let i = 0; i < arguments.length; i++) {
//         ary.push(arguments[i]);
//     }
//
//     //=>给ARY排序，去除首位
//     ary.sort(function (a, b) {
//         return a - b;
//     });
//     ary.pop();
//     ary.shift();
//
//     //=>然后再求和，最后求平均
//     let total = 0;
//     for (let i = 0; i < ary.length; i++) {
//         total += ary[i];
//     }
//     return (total / ary.length).toFixed(2);
// };

let fn = function () {
    //=>把ARG类数组转换为数组ARY（把类数组克隆一份一模一样的，最后存储到数组中）  =>数组的SLICE可以实现克隆的
    //=>把内置的SLICE方法执行 Array.prototype.slice() / [].slice() ...
    let ary = [].slice.call(arguments, 0);//=>类数组借用数组原型上的方法执行,实现相关的操作(借用SLICE实现把类数组转换为数组)  前提：类数组和数组类似，都有length和索引（字符串也符合这个前提，所以也可以这样搞）

   /* [].sort.call(arguments, function (a, b) {
        return a - b;
    });//=>借用SORT给ARG排序，除此之外其它的很多数组的方法都可以被ARG借用*/

    ary.sort(function (a, b) {
        return a - b;
    }).pop();
    ary.shift();
    return (eval(ary.join('+')) / ary.length).toFixed(2);
};
console.log(fn(10, 9.8, 9.5, 8.7, 8.8, 8, 9.2, 8.9));


/*
//=>重写数组的SLICE方法,实现:ary.slice()相当于把ARY克隆一份新数组
Array.prototype.mySlice = function () {
    //=>把操作的数组ARY克隆一份
    //=>this:ary
    //=>内置的SLICE实现数组克隆的代码
    let newAry = [];
    for (let i = 0; i < this.length; i++) {
        newAry.push(this[i]);
    }
    //=>如果我们把内置的SLICE执行，并且让方法中的THIS指向ARGUMENTS，就相当于把ARG转换为数组
    /!*
        let ary = [];
        for (let i = 0; i < arguments.length; i++) {
            ary.push(arguments[i]);
        }
        =>把ARG这个类数组转换为数组
     *!/
    return newAry;
};
let ary = [12, 23, 34];
console.log(ary.mySlice());//=>[12, 23, 34]
*/
```

###### 7.7正则

1.正则一般只能用来处理字符串

2.处理一般包含两方面：

A:验证当前字符串是否符合某个规则"正则匹配"

B:把一个字符串符合规则得字符串获取到"正则捕获"

> 正则基础

```
/*
 * 常用的修饰符
 *   i：ignoreCase 忽略大写小匹配
 *   m：multiline 多行匹配
 *   g：global 全局匹配
 */
/*
 * 常用的元字符
 *   [特殊元字符]
 *     \d  0~9之间的一个数字
 *     \D  非0~9之间的任意字符
 *     \w  “数字、字母、下划线”中的任意一个 =>/[0-9a-zA-Z_]/等价于\w
 *     \s  匹配任意一个空白字符（包括\t制表符[TAB键四个空格]）
 *     \b  匹配边界符  'zhu'(z左边和u右边就是边界)  'zhu-feng'(z左边、u右边、f左边、g右边是边界)
 *     \n  匹配一个换行符
 *     \  转义字符(把一个普通字符转义为特殊的字符,例如:\d，把有特殊含义的转换为普通意思，例如：\. 此处的点就不是任意字符，而是一个小数点)
 *     . 不仅仅是小数点，代表除了\n以外的任意字符
 *     ^  以某个元字符开头
 *     $  以某个元字符结尾
 *     x|y  x或者y中的任意一个(a|z...)
 *     [xyz] x或者y或者z中的任意一个
 *     [^xyz] 除了x\y\z以外的任意字符
 *     [a-z] 获取a-z中的任意一个字符([0-9] 等价于\d ...)
 *     [^a-z] 除了a-z的任意字符
 *     ()  正则分组
 *     (?:) 当前分组只匹配不捕获
 *     (?=) 正向预查
 *     (?!) 负向预查
 *     ...
 *
 *   [量词元字符：让其左边的元字符出现多少次]
 *     * 出现零到多次
 *     ? 出现零到一次
 *     + 出现一到多次
 *     {n} 出现N次
 *     {n,} 出现N到多次
 *     {n,m} 出现N到M次
 *
 *   [普通元字符]
 *     只要在正则中出现的元字符（在基于字面方式创建），除了特殊和有量词意义的以外，其余的都是普通元字符
 */
```

> 创建正则得两种方式

 let reg = /^d+$/g 字面量方式

​	let reg1 = new RegExp("^\d+$","g") //够着函数方式

> 正则当中得一些细节

```
1.[]一般代表本身含义，一个字符代表本身，两个及以上代表其中选择一个
2.let reg = /^\d$/g //只包含一个数字
3.let reg = /\d/   //不加^$表示只要包含0~9得数字即可
4. let reg = /^[12-65]$/ //表示包含1，2-6，5中得任意一个
5.//年龄：18~65之间
    /*
     * 18~19  1[89]
     * 20~59  [2-5]\d
     * 60~65  6[0-5]
     */
     let reg = /^((1[89])|([2-5]\d)|(6[0-5]))$/;
```

> 分组得作用

```
/*
 * 分组的作用
 *   1.改变的默认的优先级
 *   2.分组捕获  捕获大正则得同时，还会捕获小的正则
 *   3.分组引用
 */
// let reg = /^18|19$/;
// console.log(reg.test('18'));//=>true
// console.log(reg.test('19'));//=>true
// console.log(reg.test('1819'));//=>true
// console.log(reg.test('189'));//=>true
// console.log(reg.test('181'));//=>true
// console.log(reg.test('819'));//=>true
// console.log(reg.test('119'));//=>true

//小括号包起来可以改变优先级
// reg = /^(18|19)$/;
// console.log(reg.test('18'));//=>true
// console.log(reg.test('19'));//=>true
// console.log(reg.test('1819'));//=>false
// console.log(reg.test('189'));//=>false
// console.log(reg.test('181'));//=>false
// console.log(reg.test('819'));//=>false
// console.log(reg.test('119'));//=>false

//分组引用
// let reg = /^([a-z])([a-z])\2\1$/;//=>正则中出现的\1代表和第一个分组出现一模一样的内容...
// console.log(reg.test('oppo'));
// console.log(reg.test('poop'));
```

> 正则捕获 exec

```
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;
console.log(reg.exec('130828199012040617'));//=>EXEC实现的是正则捕获，获取的结果是一个数组，如果不匹配获取的结果是null，捕获的时候不仅把大正则匹配的信息捕获到，而且每一个小分组中的内容也捕获到了(分组捕获) : ["130828199012040617", "130828", "1990", "12", "04", "1", index: 0, input: "130828199012040617"]
```

*正则捕获使用的是正则中的EXEC方法*

```
 **  1.如果可以匹配获取的结果是一个数组，如果不能匹配获取的结果是NULL*

 **  2.如果我们只在匹配的时候，想要获取大正则中部分信息，我们可以把这部分使用小括号包起来，形成一个分组，这样在捕获的时候，不仅可以把大正匹配的信息捕获到，而且还单独的把小分组匹配的部分信息也捕获到了(分组捕获)*

 **  3.有时候写小分组不是为了捕获信息，只是为了改变优先级或者进行分组引用，此时我们可以在分组的前面加上“?:”，代表只去匹配，但是不把这个分组内容捕获*

 *1.如果当前正则和字符串不匹配，捕获的结果是NULL*

 **  2.如果匹配，捕获的结果是一个数组*

 **   0:大正则捕获的内容*

 **   index:正则捕获的起始索引*

 **   input:原始操作的字符串*

 **   ...*

 **  3.执行一次EXEC只能捕获到第一个和正则匹配的内容，其余匹配的内容还没有捕获到，而且更恶心的是，我傻傻的执行多次，然而并没啥卵用 =>“正则的捕获有懒惰性”：只能捕获到第一个匹配的内容，剩余的默认捕获不到*
```

​	正则得捕获具有懒惰性：只能捕获到第一个匹配得，剩余得默认捕获不到

```
解决方法：
//用match方法，来处理只能捕获一次得情况，正则表达式要g修饰符才可以匹配所有得内容
 console.log(str.match(reg));//=>MATCH实现了我们自己编写的EXEC-ALL处理的事情，正则不加G返回第一个匹配的即可，加了G，把所有匹配的内容都捕获到，最后统一存储到一个数组中返回
// let str = 'zhufeng{2018}peixun{2019}yangfan{2020}qihang{2021}';
// let reg = /\{(\d+)\}/g;//=>大括号有特殊含义：{N}出现的次数

// console.log(reg.exec(str));//=>['{2018}','2018'] 在正则捕获的时候，如果正则中存在分组捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），而且把小分组匹配的内容也单独抽取出来（数组中的第二项开始就是小分组捕获的内容） =>“分组捕获” ，而/\{(?:\d+)\}/g  ?:是用来阻止分组捕获内容的“只匹配不捕获”

// console.log(str.match(reg));//=>["{2018}", "{2019}", "{2020}", "{2021}"]  MATCH方法也有自己的局限性，在正则设置了G的情况下，基于MATCH捕获的内容只有大正则匹配的，小分组的内容没有单独抽取出来（不设置G的情况下和执行EXEC一样）
```

> 有效数字

```
 *  分析规则：
 *    1.可以出现+/-号：可以没有，也可以有一个
 *    2.整数 0 12 9 : 一位或者多位数字，一位0~9，多位数字不能以0开头
 *    3.小数部分：可能有可能没有，有小数点后面至少要跟一位数字
 */
// let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
```

##### 8.Dom

- 操作DOM的属性和方法

```
 *   [获取元素或者元素集合]
 *    getElementById
 *      ->上下文只能是document（只有document这个实例的原型链上才能找到这个方法，其它实例都找不到）
 *      ->ID重复了获取第一个
 *      ->IE6~7中会把表单元素的name当做id使用
 *    getElementsByTagName
 *      ->获取当前上下文中，所有子子孙孙中标签名叫做XXX的元素
 *    getElementsByClassName
 *      ->IE6~8中不兼容
 *    getElementsByName
 *      ->在IE浏览器中只对表单元素的name起作用
 *      ->上下文也只能是document
 *    querySelector
 *    querySelectorAll
 *      ->不兼容IE6~8
 *      ->没有DOM映射
 *    document.documentElement
 *    document.body
 *    document.head
```

- 描述节点和节点之间关系的属性

```
 *          nodeType nodeName  nodeValue
 *     元素节点  1  大写标签名  null
 *     文本节点  3  #text     文本内容
 *     注释节点  8  #comment  注释内容
 *     文档节点  9  #document null
 *
 *   childNodes：所有子节点
 *   children：所有元素子节点（IE6~8中会把注释当做元素节点）
 *   parentNode
 *   previousSibling / previousElementSibling
 *   nextSibling
 *   firstChild
 *   lastChild
 *
 *   [动态操作DOM]
 *     createElement
 *     createDocumentFragment
 *     appendChild
 *     insertBefore
 *     cloneNode(true/false)
 *     removeChild
 *     set/get/removeAttribute
 *
 *   [散]
 *     xxx.style.xxx=xxx  设置行内样式
 *     =>xxx.style.xxx  获取行内样式
 *
 *     xxx.className='xxx'
 *
 *     xxx.onclick=function...
 *
 *     ...
 */
```

###### 三大家族

client:

```
clienLeft/clientTop/clientWidth/clientHeight
1.clientWidth/clientHeight:获取当前可视区域得宽高（内容得宽高+上下/左右得padding）
	和内容是否有溢出无关（和是否设置了OVERFLOW:HIDDEN也无关），就是我们自己设定的内容的宽高+PADDING
	//=>获取当前页面一屏幕(可视区域)的宽度和高度
	// document.documentElement.clientWidth || document.body.clientWidth
	// document.documentElement.clientHeight || document.body.clientHeight
2.clientLeft/clientTop:获取上/左边框得宽度
```

offset:

```
1.offsetWidth/offsetHeight:内容宽高+padding+border(和内容得溢出也没有关系)
2.offsetTop/offsetLeft：获取当前盒子距离其父级参照物得偏移量
3.offsetParent：但前父级盒子得参照物
4.给元素设置定位position:relative/absolute/fixed，可以改变父级参照物
```

scroll:

```
1.scrollWidth/scrollHeight:真实内容得得宽高（不一定是自己设置得宽高，如果内容溢出，要加上内容溢出得部分，+padding）真实内容的宽高（不一定是自己设定的值，因为可能会存在内容溢出，有内容溢出的情况下，需要把溢出的内容也算上）+ 左/上PADDING，而且是一个约等于的值 （没有内容溢出和CLIENT一样）
//=>在不同浏览器中，或者是否设置了OVERFLOW:HIDDEN都会对最后的结果产生影响，所以这个值仅仅做参考，属于约等于的值

//=>获取当前页面的真实宽高（包含溢出的部分）
// document.documentElement.scrollWidth || document.body.scrollWidth
// document.documentElement.scrollHeight || document.body.scrollHeight
2.scrollTop/scrollLeft:滚动条卷曲得宽度或高度
最小卷曲值：0
最大卷曲值：真实页面宽度-屏幕宽度=document.documentElement.scro llHeight-document.document.clientHeight
//1.[元素].style.xxx 操作获取
//> 只能获取所有写在元素行内上的样式(不写在行内上,不管你写没写都获取不到,真实项目中我们很少会把样式写在行内上)
//2.获取当前元素所有经过浏览器计算的样式
//> 经过计算的样式：只要当前元素可以在页面中呈现（或者浏览器渲染它了），那么它的样式都是被计算过的
//=>不管当前样式写在哪
//=>不管你是否写了(浏览器会给元素设置一些默认样式)
/*
 * 标准浏览器(IE9+)
 *   window.getComputedStyle([元素],[伪类,一般都写null]) 获取到当前元素所有被浏览器计算过的样式(对象)
 *
 * IE6~8
 *   [元素].currentStyle 获取经过计算的样式
 */
```

封装获取css得方法

```
let getCss = function getCss(curEle, attr) {
    if ('getComputedStyle' in window) {
        let val = window.getComputedStyle(curEle, null)[attr];
        //=>把获取的结果去除单位（不是所有的值都能去单位的，例如：display\一些复合值都去不掉单位），只有符合 数字+单位 这种模式的结果才能基于PARSE-FLOAT去单位
        let reg = /^-?\d+(\.\d+)?(px|rem|em|pt)?$/i;
        reg.test(val) ? val = parseFloat(val) : null;
        return val;
    }
    //=>throw new SyntaxError：抛出一个错误(语法错误),让浏览器崩溃,不在继续执行JS
    throw new SyntaxError('您的浏览器版本过低，请升级到最新版本，谢谢配合！！');
};
console.log(getCss(outer, 'width'));
```

封装设置css得方法

```
//=>设置当前元素的某一个具体样式的属性值
//JS中给元素设置样式只有两种
//1.设置元素的样式类名（前提：样式类及对应的样式已经处理完成）
//2.通过行内样式设置 xxx.style.xxx=xxx
let setCss = function (curEle, attr, value) {
    /*
     * 细节处理
     *   1.如果需要考虑IE6~8兼容，透明度这个样式在低版本浏览器中不是使用opacity，而是filter（我们两套都要设置）
     *   2.如果传递进来的VALUE值没有带单位,我们根据情况设置PX单位
     *     ->某些样式属性才会加单位：WIDTH/HEIGHT/PADDING(LEFT...)/MARGIN(LEFT...)/FONT-SIZE/TOP/LEFT/BOTTOM/RIGHT...
     *     ->用户自己传递的VALUE值中是没有单位的
     */
    if (attr === 'opacity') {
        curEle.style.opacity = value;
        curEle.style.filter = `alpha(opacity=${value * 100})`;
        return;
    }
    if (!isNaN(value)) {
        //=>IS-NaN检测的结果是FALSE：说明VALUE是纯数字没单位
        let reg = /^(width|height|fontSize|((margin|padding)?(top|left|right|bottom)?))$/i;
        reg.test(attr) ? value += 'px' : null;
    }
    curEle['style'][attr] = value;
};
```

for in循环

```
//=>FOR-IN遍历的时候有自己的顺序：先遍历数字属性名（按照小->大），再遍历字符串属性名（按照书写顺序）
for (let attr in obj) {
    console.log(attr);//=>0 1 name age sex score
}
//=>FOR-IN遍历的时候有自己的顺序：先遍历数字属性名（按照小->大），再遍历字符串属性名（按照书写顺序）
for (let attr in obj) {
    console.log(attr);//=>0 1 name age sex score
}

//=>obj.__proto__===Object.prototype : obj是Object这个类的一个实例
//=>大括号中的是OBJ的私有属性，Object.prototype上的是OBJ公有属性
Object.prototype.bbbb = 1000;
for (let key in obj) {
    //=>FOR-IN循环只遍历当前对象可枚举（可遍历）的属性
    //1.对象的私有属性(自己写的)是可枚举的
    //2.浏览器内置的属性一般都是不可枚举的
    //3.自己在类的原型上设置的属性也是可枚举的,FOR-IN循环的时候也会被遍历出来（一般情况下我们是不想遍历到原型上的公有属性的）
    if (obj.hasOwnProperty(key)) {//=>一般使用FOR-IN在遍历对象的时候，我们加一个私有属性的验证，只有是私有的属性，我们才做操作
        console.log(key);
    }
}
//=>CSS:集合GET/SET/SET-GROUP为一体的方法
let css = function (...arg) {
    //=>ARG:传递的实参集合
    let len = arg.length;
    if (len >= 3) {
        //=>单一设置:SET-CSS
        // arg=[outer, 'width', 500];
        // setCss(outer, 'width', 500);
        // setCss.apply(null,arg);
        setCss(...arg);
        return;
    }

    if (len === 2 && typeof arg[1] === 'object' && arg[1] !== null) {
        //=>传递两个参数，第二个参数是一个对象(不是NULL)，说明想要操作的是批量设置
        setGroupCss(...arg);
        return;
    }
    //=>剩下的代表获取样式
    return getCss(...arg);
};
let css = function (...arg) {
    let len = arg.length,
        fn = getCss;
    len >= 3 ? fn = setCss : null;
    len === 2 && (arg[1] instanceof Object) ? fn = setGroupCss : null;
    return fn(...arg);
};
```

##### 9.事件

事件：元素天生自带得行为

box.onclick = function(){} 给天生得自带事件绑定方法，触发事件执行对应得方法

###### 1.鼠标事件

```
click : pc端点击事件，移动端有三百毫秒延迟

dbclick : 双击

moseover : 鼠标经过

mouseout : 鼠标移除

mouseenter : 鼠标进入

mouseleave : 鼠标离开

mousemove : 鼠标移动

mousedown : 鼠标按下（鼠标按下触发，鼠标左右键都可以，单击是点击后放开，才触发，先把down和up触发，再触发click）

mouseup:鼠标抬起

mousewheel : 鼠标滚轮滚动
```

onmouseenter和onmouseover的区别：

```
 mouseeneter 和 mouseover 的区别?
 *   1.over属于滑过(覆盖)事件，从父元素进入到子元素，属于离开了父元素，会触发父元素的out，触发子元素的over
 *     enter属于进入，从父元素进入子元素，并不算离开父元素，不会触发父元素的leave，触发子元素的enter
 *
 *   2.enter和leave阻止了事件的冒泡传播，而over和out还存在冒泡传播的
 *
 * 所以对于父元素嵌套子元素这种情况，使用OVER会发生很多不愿意操作的事情，此时我们使用ENTER会更加简单，操作方便，所以真实项目中ENTER的使用会比OVER多
 */
```

**mouseenter不存在冒泡传播机制**

###### 2.键盘事件

```
keydown : 键盘按下

keyup : 键盘放开

keypress : 和key类似，知识keydown返回得是键盘码，keypress返回得是ASCII码值

input: 由于PC端有实体物理键盘，可以监听到键盘的按下和抬起，但是移动端是虚拟的键盘，所以keydown和keyup在大			 部分手机上都没有，我们使用input事件统一代替他们（内容改变事件）
```

###### 3.表单元素常用事件

```
 *focus：获取焦点*

blur：失去焦点

change：内容改变
```

4.其它常用事件

```
 load：加载完成
     unload
     beforeunload
     scroll：滚动条滚动事件
     resize：大小改变事件  window.onresize=function(){} 当浏览器窗口大小发生改变，会触发这个事件，执行对应的事情
```

5.移动端事件

```
  [touch：单手指操作]
    touchstart：手指按下
    touchmove：手指移动
    touchend：手指离开
    touchcancel：因为意外情况
  [gesture：多手指操作]
    gesturestart：手指按下
    gesturechange：手指改变
    gestureend：手指离开


[H5中的AUDIO/VIDEO音视频事件]
 *    canplay：可以播放（播放过程中可能出现由于资源没有加载完成，导致的卡顿）
 *    canplaythrough：资源加载完成，可以正常无障碍播放
```

##### 10.事件绑定

Dom0事件绑定：[element].onclick = xxx

**Dom1得事件绑定**：[element].addEventListener('xxx',function(){},false)

Dom2的事件绑定：[element].attachEvent('onxxx',function(){})

*目的：给当前元素的某个事件绑定方法（不管是基于DOM0还是DOM2），都是为了触发元素的相关行为的时候，能做点事情（也就是把绑定的方法执行）；“不仅把方法执行了，而且浏览器还给方法传递了一个实参信息值 ==>这个值就是事件对象”*

```
box.onclick = function(ev){
	//定义一个ev用来接受方法执行时浏览器传递过来的实参 （实参对应的不同的浏览器事件对象：MouseEvent鼠标事件对象，KeyboardEvent键盘事件对象、Event普通事件对象。。。）
[MouseEvent]
 ev.target：事件源（操作的是哪个元素）
 ev.clientX / ev.clientY ：当前鼠标触发点距离当前窗口左上角的X/Y轴坐标
 ev.pageX / ev.pageY：当前鼠标触发点距离BODY(第一屏幕)左上角的X/Y轴坐标
 ev.preventDefault()：阻止默认行为
 ev.stopPropagation()：阻止事件的冒泡传播
 ev.type：当前事件类型
[KeyboardEvent]
 ev.code：当前按键'keyE'
 ev.key：当前按键'e'
 ev.which / ev.keyCode：当前按键的键盘码 69
 let code = ev.which || ev.keyCode;
    
    
=>常用的键盘码

 * 左-上-右-下：37-38-39-40
 * Backspace：8
 * Enter：13
 * Space：32
 * Delete：46
 *
 * Shift：16
 * Alt：18
 * Ctrl：17
 * ESC：27
 *
 * F1~F12：112 ~ 123
 * 48~57：数字键
 * 65~90：小写字母

}
事件在低版本浏览器下：
box.onclick = function (ev) {
    //=>在IE低版本浏览器中，浏览器执行绑定的方法，并没有把事件对象传递进来，此时ev===undefined，需要基于window.event来获取（由于是全局属性，鼠标每次操作都会把上一次操作的值替换掉）
    if (!ev) {
        //=>低版本中没有的属性，我们手动设置一下：按照自己有的先获取到值，然后赋值给和标准对应的新属性（经过判断处理后，低版本中也有TARGET/PAGE-X/PAGE-Y这些属性了），后期再使用的时候，直接按照高版本的使用即可
        ev = window.event;
        // console.log(ev.srcElement);//=>ev.srcElement是获取事件源（标准中使用的是ev.target）
        ev.target = ev.srcElement;
        // console.log(ev.pageX);//=>低版本浏览器的事件对象中不存在pageX/pageY
        ev.pageX = ev.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
        ev.pageY = ev.clientY + (document.documentElement.scrollTop || document.body.scrollTop);
        ev.which = ev.keyCode;

        // preventDefault & stopPropagation 这些在低版本下都没有
        ev.preventDefault = function () {
            ev.returnValue = false;//=>低版本阻止默认行为
        };
        ev.stopPropagation = function () {
            ev.cancelBubble = true;//=>低版本阻止冒泡传播
        };
    }
    //=>直接按照高版本的规则来使用即可
    console.log(ev.target, ev.which);
    ev.preventDefault();
    ev.stopPropagation();
};
```

###### 1.事件的默认行为

**解释**：*事件本身就是天生就有的，某些事件触发，即使你没有绑定方法，也会存在一些效果，这些默认的效果就是“事件的默认行为”*

a标签点击：1.页面跳转 2.锚点定位

<a href="#box”>珠峰培训 首先会在当前页面URL地址栏末尾设置一个HASH值，浏览器检测到HASH值后，会默认定位到当前页面中ID和HASH相同的盒子的位置（基于HASH值我们还可以实现SPA单页面应用）

**阻止a标签的默认行为**：*很多时候我们使用A标签仅仅是想当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位*

```
1.在结构中阻止
<a href="javascript:;">珠峰培训最新全栈视频，等你来拿~~</a>
javascript:void 0/undefined/null...;
2.在js中阻止

方式一： link.onclick = function (ev) {
     ev = ev || window.event;
     return false;
 };
方式二： link.onclick = function (ev) {
    ev = ev || window.event;
     ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
 };
方式三输入框的默认事件阻止： tempInp.onkeydown = function (ev) {
      ev = ev || window.event;
      ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
     return false;
 };
```

###### 2.事件的传播机制

**捕获机制**：当点击最底层，首先会从最外层向内开始查找（找到触发的事件源），查找的目的是，构建处冒泡传播阶段需要传播的路线（查找就是按照html进行查找）

**目标阶段：**把事件源的相关操作触发

**冒泡传播**：触发当前元素的某一事件的（点击事件）行为，不仅当前元素触发，而且祖先元素的相关事件也会触发，称为"统一冒泡机制"

***xxx.onxxx=function(){} DOM0事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素事件行为的冒泡阶段(或者目标阶段)执行的\***

***xxx.addEventListener('xxx',function(){},false) 第三个参数FALSE也是控制绑定的方法在事件传播的冒泡阶段(或者目标阶段)执行；只有第三个参数为TRUE才代表让当前方法在事件传播的捕获阶段触发执行（这种捕获阶段执行没啥实际意义，项目中不用）；\***

不同浏览器对于对于最外层祖先元素的定义是不一样的：

*谷歌：window->document->html->body...*

IE高：window->html->body...

IE低：html->body...

![image-20200920153711027](http://null/)

###### 3.事件委托（事件代理）

利用事件的冒泡传播机制，如果一个容器的后代元素中，很多元素的点击行为都要做一些处理，此时我们不用像以前一样一个个绑定，我们只需要给容器添加click绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的cilck 触发，把对应的方法执行，更具事件源，根据事件源，我们可以知道点击的是谁，从而做不同的事情即可

将后代的触发事件，加到容器的的方法中执行，通过ev.target可以获取到触发事件的事件源，这样可以减少资源损耗

![image-20200920165849882](http://null/)

事件委托案例

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>珠峰培训</title>
    <link rel="stylesheet" href="css/reset.min.css">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }

        .menuBox {
            margin: 20px auto;
            width: 700px;
            height: 270px;
            border: 1px solid #000;
        }

        .navBox {
            float: left;
            width: 200px;
            background: lightblue;
        }

        .navBox ul li {
            height: 30px;
            line-height: 30px;
        }

        .navBox ul li a {
            display: block;
            padding: 0 10px;
            height: 100%;
            font-size: 14px;
            color: #555;
        }

        .navBox ul li a:hover {
            background: lightcoral;
        }

        .detailBox {
            display: none;
            float: left;
            width: 500px;
            height: 100%;
            background: #EEE;
            font-size: 20px;
        }
    </style>
</head>
<body>
<section class="menuBox">
    <nav class="navBox">
        <ul>
            <li><a href="#" target="_blank">导航1</a></li>
            <li><a href="#" target="_blank">导航2</a></li>
            <li><a href="#" target="_blank">导航3</a></li>
            <li><a href="#" target="_blank">导航4</a></li>
            <li><a href="#" target="_blank">导航5</a></li>
            <li><a href="#" target="_blank">导航6</a></li>
            <li><a href="#" target="_blank">导航7</a></li>
            <li><a href="#" target="_blank">导航8</a></li>
            <li><a href="#" target="_blank">导航9</a></li>
        </ul>
    </nav>
    <div class="detailBox">导航1对应的详情内容</div>
</section>

<script src="js/jquery-1.11.3.min.js"></script>
<script>
    //=>基于事件委托给最外层的盒子的MOUSE-OVER绑定方法，这样不管操作后代元素中的谁的MOUSE-OVER，这个方法都会执行
    let $detailBox = $('.detailBox');
    $(document.body).on('mouseover', function (ev) {
        let target = ev.target,
            tag = target.tagName,
            $target = $(target),
            $pars = $target.parents();//=>获取当前事件源的祖先元素

        //=>如果事件源是NAV-BOX中的A或者LI（让DETAIL-BOX显示）
        let flag = $pars.filter('.navBox').length > 0 ? true : false;//=>TRUE祖先中包含NAV-BOX,FALSE则相反
        if ((tag === 'A' || tag === 'LI') && flag) {
            let val = $target.text().match(/\d+/);
            $detailBox.css('display', 'block').html(`导航${val}对应的内容`);
            return;
        }

        /*//=>如果事件源是DETAIL-BOX或者是它的后代元素，不做处理
        if ($target.hasClass('detailBox') || $pars.filter('.detailBox').length > 0) {
            return;
        }*/
		//mouseOver到MenuBox之外得地方都将detailBox隐藏，但下面得终止事件委托让detailBox区域不会有效果
        $detailBox.css('display', 'none');
    });
	
    $detailBox.on('mouseover', function (ev) {
        //终止事件委托，当mouseover到当前detatilBox时，就不向上冒泡，body得mouseover就不会执行，该盒子就不会走body得事件流程，该盒子不会被隐藏
        ev.stopPropagation();
    });
</script>
</body>
</html>
```

###### 4.事件绑定

```
  /*
     * 事件绑定
     *   DOM0
     *     box.onclick=function(){}
     *     每一个元素对象都是对应类的实例，浏览器天生为其设置了很多私有属性和公有的属性方法，而onclick就是其中的一个私有属性（事件类私有属性，还有很多其它的事件私有属性），这些属性默认值是null
     *     DOM0事件绑定的原理：就是给元素的某一个事件私有属性赋值（浏览器会建立监听机制，当我们触发元素的某个行为，浏览器会自己把属性中赋的值去执行）
     *
     *   DOM2
     *     box.addEventListener('click',function(){},false)  =>removeEventListener是移除（使用的方法都是EventTarget.prototype定义的）
     *
     *     在IE低版本中使用的是attachEvent来处理的：box.attachEvent('onclick',function(){})  移除使用的是dettachEvent
     *
     *    1.DOM2事件绑定可以给当前元素的某一个事件行为绑定“多个不同的方法”
     */
```

```
//多次绑定事件，后面得会覆盖前面得
 //=>DOM0事件绑定：只允许给当前元素的某个事件行为绑定一个方法，多次绑定，后面绑定的内容会替换前面绑定的，以最后一次绑定的方法为主
    box.onclick = function () {
        console.log(1);
    };
    box.onclick = function () {
        console.log(2);//=>触发点击行为，只输出2
    };
```

dom0和dom2的区别：

```
/*
     * DOM0事件绑定和DOM2事件绑定的区别
     *   1.机制不一样
     *    DOM0采用的是给私有属性赋值，所以只能绑定一个方法
     *    DOM2采用的是事件池机制，所以能绑定多个不同的方法
     *
     *   2.移除的操作
     *   3.DOM2事件绑定中增加了一些DOM0无法操作的事件行为，例如：DOMContentLoaded事件（当页面中的HTML结构加载完成就会触发执行）
     */
```

```
1.box.onclick =function(){}
2.box.onclick = null //赋值为null就代表移除了（不需要知道绑定的是谁）

Dom2移除，必须指定才能移除
3.box.addEventListener('click',function(){})
4.box.addEventListener('click',function(){})  //在移除的时候，需要指定移除的的事件池，不要绑定匿名函数
5.window.onload = function () {
        //=>当页面中的资源都加载完成（HTML结构加载完、CSS和JS等资源加载完成等）才会触发执行
    };
    // window.addEventListener('load',function(){}); //=>这样处理也可以执行多次了

    //=>$(document).ready(function(){})
    //原理：基于DOMContentLoaded完成的(IE中用的是onreadystatechange监听的，在document.readyState === "complete"时候执行函数)
    $(function () {
        //=>当页面中的HTML结构加载完成就会执行

    });

    $(function(){
        //=>基于DOM2事件绑定的，所以在同一个页面中可以执行多次（绑定多个不同的方法），当结构加载完成，会依次执行这些方法
    });
```

juqery中的事件绑定：

on/off:基于dom2的事件实现事件绑定和移除

one: 只绑定一次，第一次执行完成，会把绑定的方法移除

*click / mouseover / mouseout ...：JQ提供快捷绑定方法，但是这些方法最后都是基于ON/OFF完成的*

delegate：事件委托方法（1.7版本以前用的是live方法）

bind / unbind：正常绑定

```
  let fn = function (ev) {
        console.log(1);
    };
    // $(document).on('click', fn);
    // $(document).off('click', fn);
    // $(document).one('click', fn);
    // $(document).click(fn);
    // $(document).delegate('#box', 'click', fn);//=>把点击行为委托给DOCUMENT，不管点击文档中的哪一个元素，都会触发文档的点击行为，第一个参数代指事件源是#BOX我们执行FN这件事
```

封装的一个拖拽案例

```
~function ($) {
    if (typeof $ === 'undefined') {
        throw new ReferenceError('The current plugin needs to rely on jquery！');
    }

    //=>空函数没用:我们可以把它赋值给所有的回调函数默认值,也就是回调函数不传,执行的就是这个空函数(不会报错)
    let emptyFn = function emptyFn() {

    };

    class Drag {
        constructor(ele, options = {}) {
            if (typeof ele === 'undefined' || ele.nodeType !== 1) {
                throw new ReferenceError('ele is a must pass parameter and must be an element object！');
            }

            //=>INIT PARAMETERS
            let {selector = ele} = options;
            this.ele = ele;
            this.dragTarget = selector;
            if (typeof selector === 'string') {
                //=>传递一个选择器进来了:我们是想通过操作ELE中某个元素让ELE实现移动
                this.dragTarget = $(ele).find(selector)[0];
            }

            //=>给当前实例挂载三个属性:三个属性就是三个计划表
            this.dragstartPlan = $.Callbacks();
            this.dragingPlan = $.Callbacks();
            this.dragendPlan = $.Callbacks();

            //=>DRAG-START:保证执行原型上的方法,方法中的THIS都是当前类的实例
            this.dragTarget.addEventListener('mousedown', this.down.bind(this));
        }

        //=>MOUSE-DOWN
        down(ev) {
            this.starX = ev.clientX;
            this.starY = ev.clientY;

            let $ele = $(this.ele);
            this.starL = parseFloat($ele.css('left'));
            this.starT = parseFloat($ele.css('top'));

            this.MOVE = this.move.bind(this);
            this.UP = this.up.bind(this);
            document.addEventListener('mousemove', this.MOVE);
            document.addEventListener('mouseup', this.UP);

            this.dragstartPlan.fire(this, ev);//=>通知某一个计划表中的方法执行,把当前类的实例传递给计划表中每一个方法(可以传递更多的值)
        }

        //=>MOUSE-MOVE
        move(ev) {
            let {starX, starY, starL, starT} = this,
                curL = ev.clientX - starX + starL,
                curT = ev.clientY - starY + starT;
            this.curL = curL;
            this.curT = curT;
            $(this.ele).css({
                top: curT,
                left: curL
            });

            this.dragingPlan.fire(this, ev);
        }

        //=>MOUSE-UP
        up(ev) {
            document.removeEventListener('mousemove', this.MOVE);
            document.removeEventListener('mouseup', this.UP);

            this.dragendPlan.fire(this, ev);
        }
    }
    
    window.Drag = Drag;
}(jQuery);

/*
new Drag(ele, {
    selector: 'h3' //=>SELECTOR:当前需要操作的目标元素选择器(按住它实现让ELE移动,不传默认就是按住ELE移动)
});*/
```

###### 5.发布订阅者模式

**思想**：准备一个容器，把到达指定时候要处理的事情，加载到容器中（发布计划，并且向计划表中订阅方法），当到达指定时间点，通知容器中的方法依次执行即可

例子

```
//这是一个自执行函数
~ function anonymous(window) {
    class Subscribe {
        constructor() {
            //这是一个容器池用于存储统一操作的私有属性
            //=>创建一个容器
            //每一个实例都有一个自己独有的容器,管理自己需要执行的方法即可
            this.pond = []
        }
        //向表中增加方法
        add(fn) {
            let pond = this.pond;
            //判断添加的方法在容器中是否存在
            let isExsit = false;
            pond.forEach(item => item === fn ? isExsit = true : null);
            !isExsit ? pond.push(fn) : null
        }
        //向计划表池子中移除方法
        remove(fn) {
            let pond = this.pond;
            pond.forEach((item, index) => {
                if (item === fn) {
                    // pond.splice(index, 1);//=>我们不能基于SPLICE删除，因为这种删除方式会改变原有的数组，例如：我们通知方法执行，当执行到FN3的时候（FIRE循环索引是2），
                    //但是基于SPLICE把FN1/FN2删除后，原始数组后面的项都向前提取两位，此时FIRE中继续遍历下一个方法（索引3），已经找不到和他匹配的那一项了

                    //=>让当前项赋值为NULL即可(这样函数移除掉了,但是此时的数组结构没有改变，不会出现数组塌陷的问题)
                    pond[index] = null
                }
            })
        }
        //=>通知计划表中的方法依次执行
        //如果传递参数信息了,把这些参数依次赋值给执行的每一个方法
        fire(...arg) {
            let pond = this.pond
            for(let i=0;i<pond.length;i++){
                let item = pond[i]
                if(pond[i]===null){
                    //将该项删除
                    pond.splice(i,1)
                    i--;
                    continue;
                }
                item(...arg)
            }

        }
    }
    window.Subscribe = Subscribe
}(window)

//创建一个实例
let subscribe = new Subscribe()

var fn1 = function(){
    console.log('1');
}
var fn2 = function(){
    console.log('2');
}
var fn3 = function(){
    console.log('3');
}
//添加方法到容器统一执行的池中
subscribe.add(fn1);
subscribe.add(fn2);
subscribe.fire();
//移除容器统一执行池中的方法
subscribe.add(fn3);
subscribe.remove(fn2);
//执行统一容器池中的方法
subscribe.fire();
```

##### 11.移动端

###### 1.html5

```
1.新增加(修改/删除)的语义化标签
  header
  footer
  main 主体
  section 区域
  article 文章区域
  aside 与内容无关的部分（例如：广告）
  nav
  figure 配图区域
  figcaption 配图说明

  mark 标记
  time 时间标记
  progress 进度条
  ...

2.关于表单元素的新改革
 [传统表单元素]
    input:text/password/radio/checkbox/file/hidden/button/submit/reset...
    select
    textarea 文本域
    button
    form
    label
    ...

 [新增一些表单元素或者是表单类型]
    input:search/email/tel/number/range/color/date/time/url...

3.音视频标签
  audio
  video
  =>让我们告别了FLASH时代

4.canvas图形绘制

5.提供了一些新的API
  本地存储：localStorage/sessionStorge
  获取地理位置： navigator.geolocation.getCurrentPosition 调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精准度等
  ...
  还提供了一些API，让我们可以通过浏览器调取手机内部的软件或者硬件（但是性能都不咋高，而且兼容性不是特别好）

6.websocket：socket.io 客户端和服务器端新的传输方式（即时通讯IM系统基本上很多是基于它完成的）
```

###### 2.css3

常用属性

```
 [选择器]
    #ID
    .CLASS
    TAG
    *
    SELECTOR1,SELECTOR1... 群组选择器

    A .B{} 后代
    A.B{} 既具备A也具备.B的（同级二次筛选）
    A>B{} 子代
    A+B{} 下一个弟弟
    A~B{} 兄弟

    A[NAME=''] 属性选择器 NAME!='' / NAME^='' / NAME$='' / NAME*='' ...

    A:HOVER
    A:ACTIVE
    A:VISTED
    A:AFTER
    A:BEFORE

    A:NTH-CHILD
    A:NTH-LAST-CHILD
    A:NTH-OF-TYPE
    A:NTH-LAST-OF-TYPE
    A:NOT
    A:FIRST-CHILD
    A:LAST-CHILD

    ...

  [样式属性]
    1.基本常用的
      border-radius
      box-shadow
      text-shadow
    2.背景的
      background -color / -image / -position / -repeat / -attachment / ...

      background-size：
           100px 100px  宽高具体值
           100% 100%  宽高百分比（相对于所在容器）
           cover  以合适的比例把图片进行缩放(不会变形)，用来覆盖整个容器
           contain 背景图覆盖整个容器（但是会出现，如果一边碰到容器的边缘，则停止覆盖，导致部分区域是没有背景图的）
           ...

      background-clip: 背景图片裁切
          border-box
          padding-box
          content-box

      background-origin：设置背景图的起始点
          border-box
          padding-box
          content-box

      ...

      filter

    3.CSS3动画和变形(2D/3D)

      //=>变形不是动画
      transform:
         translate(X|Y|Z)  位移
         scale 缩放
         rotate 旋转
         skew 倾斜
         matrix 矩阵(按照自己设定的矩阵公式实现变形)
      transform-style:preserve-3d 实现3D变形
      transform-origin：变形的起点

      //=>过渡动画
      transition:
         transition-property:all/width... 哪些属性样式发生改变执行过渡动画效果，默认ALL，所有样式属性改变都会执行这个过渡效果
         transition-duration:过渡动画的时间，我们一把都用秒，例如：.5s
         transition-timing-function:动画运动的方式 linear(默认) ease ease-in ease-out ease-in-out cubic-bezier(执行自己设定的贝塞尔曲线)
         transition-delay:设置延迟的时间,默认是0s不延迟,立即执行动画
         ...

      //=>帧动画
      animation：
         animation-name 运动轨迹的名称
         animation-duration 运动的时长
         animation-timing-function 运动的方式(默认ease)
         animation-delay 延迟时间
         animation-iteration-count 运动次数(默认1  infinite无限次运动)
         animation-fill-mode 运动完成后的状态（帧动画完成后，元素会默认回到运动的起始位置，如果想让其停留在最后一帧的位置，设置这个属性值为forwards；backwards是当前帧动画如果有延迟时间，在延迟等待时间内，元素处于帧动画的第一帧位置；both是让帧动画同时具备forwards和backwards）
         ...

      //=>设置帧动画的运动轨迹
      @keyframes [运动轨迹名称] {
        from{
           //开始的样式
        }
        to{
           //结束的样式
        }
      }

      @keyframes [运动轨迹名称] {
         0%{
            //开始的样式
         }
         50%{}
         100%{
            //结束的样式
         }
      }

    4.CSS3中的新盒子模型
      box-sizing: border-box / padding-box / content-box（默认值） 改变的就是我们在CSS中设置的WIDTH/HEIGHT到底代表啥  border-box让其代表整个盒子的宽高，当我们去修改PADDING或者BORDER，盒子大小不变，只会让内容缩放

      columns：多列布局

      flex：弹性盒子模型

    5.一些其它的CSS3属性
      perspective:视距 实现3D动画必用的属性
      @media:媒体查询 实现响应式布局的一种方案
      @font-face:导入字体图标
      ...
```

###### 3.响应式开发

```
响应式布局开发
   响应式布局：在不同尺寸的设备上都能良好的展示，这就是响应式布局设计（Responsive Layout）

   公司中的产品形态：
     1.PC端(全屏页面需要宽度自适应，但是一般都是固定宽度的)
     2.PC+移动端用同一套项目（简单的页面，例如：产品介绍，公司展示类的官网等）
     3.移动端（移动端设备尺寸差异较大，需要做响应式布局开发）
       嵌入到APP中的H5
       微信中分享出来的H5
       微信公号
       小程序
       靠浏览器访问的H5
       ...
     4.RN(React Native) / ionic / cordova ... JS开发APP的框架，使用JS代码开发APP，最后框架会把代码转换为 安卓和IOS 需要的代码


   如何实现响应式布局开发?
     最常用的方案：REM等比缩放响应式布局

     做移动端H5开发，首先加META标签
        <!--meta:vp [Tab]-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        REM和PX一样都是样式单位，PX是固定单位，REM是相对单位（相对于当前页面根元素HTML的字体设定的单位）

        我们开始给HTML的字体大小设置为100PX(1REM=100PX)，接下来我们写样式的时候，把所有的尺寸都用REM设定（测量出来的PX值/100就是应该设置的REM的值）,如果HTML的FONT-SIZE不变，用REM和PX一样，但是如果字体大小改变，也就是改变了REM和PX之间的换换算比例，那么之前所有用REM做单位的样式都会自动按照最新的比例进行缩放（实现了改动HTML的FONT-SIZE，整个页面中的元素都跟着缩放了，牵一发而动全身）

        真实项目中，设计师给给我们一套设计稿（常用的尺寸：640*1136  750*1334 640*960 ...），拿到设计稿后，我们严格按照设计稿中的尺寸去编写样式
           HTML{
              FONT-SIZE:100PX;
           }
           接下来写样式，把测量出来的PX都除以100变为REM，所有的单位基于REM来搞
           =>假设设计稿是750,也就相当于750的设备下,1REM=100PX

        我们页面运行在320的设备上，我们需要修改HTML的字体大小，以此实现页面跟着整体缩放：320/750*100 =>当前设备上HTML的字体大小





四、微信二次开发（小程序） =>Hybrid混合APP开发

五、移动端事件

六、移动端常用的插件、类库、框架等
```

##### 12.ajax

###### 1.浏览器相关

````
【HTTP请求阶段：向服务器发送请求】
    1.浏览器首先向DNS域名解析服务器发送请求
    2.DNS反解析：根据浏览器请求地址中的域名，到DNS服务器中找到对应的服务器外网IP地址
    3.通过找到的外网IP，向对应的服务器发送请求（首先访问的是服务器的WEB站点管理工具:准确来说是我们先基于工具在服务器上创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求哪个服务）
    4.通过URL地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件

【HTTP响应阶段：服务器把客户端需要的内容准备好，并且返回给客户端】
    5.服务器端根据请求地址中的路径名称、问号传参或者哈希值，把客户端需要的内容进行准备和处理
    6.把准备的内容响应给客户端（如果请求的是HTML或者CSS等这样的资源文件，服务器返回的是资源文件中的源代码[不是文件本身]）

【浏览器渲染阶段】
    7.客户端浏览器接受到服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的绘制和渲染
      ->首先计算DOM结构，生成DOM TREE
      ->自上而下运行代码，加载CSS等资源内容
      ->根据获取的CSS生成带样式的RENDER TREE
      ->开始渲染和绘制

2.我们把一次完整的 请求+响应 称之为 “HTTP事务”
  事务就是完整的一次操作，请求和响应缺一不可

3.一个页面完全加载完成，需要向服务器发起很多次HTTP事务操作
  一般来说：首先把HTML源代码拿回来，加载HTML的时候，遇到link/script/img[src]/iframe/video和audio[没有设置preload='none']...都会重新和服务器端建立HTTP事务交互

  特殊情况：如果我们做了资源缓存处理(304)，而且即将加载的资源在之前已经加载过了，这样的操作和传统的HTTP事务有所不一样，他们是从服务器和浏览器的缓存中读取数据，比传统的读取快很多

4.在客户端向服务器发送请求，以及服务器把内容响应给客户端的时候，中间相互传递了很多内容(客户端把一些内容传递服务器，服务器把一些内容响应给客户端)，我们把传递的内容统称为“HTTP报文”

[传输协议]
    用来传输客户端和服务器端交互的信息的（类似于快递小哥）
      HTTP：超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息），是目前最常用的WEB传输协议
      HTTPS：基于SSL（Secure Sockets Layer 安全套接层）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的）
      FTP：文件传输协议，一般用来实现资源文件在服务器上的上传下载

  [域名] Domain Name
    一级域名（顶级域名）  www.qq.com
    二级域名   sports.qq.com
    三级域名   kbs.sports.qq.com

    .com 供商用的国际域名
    .cn 供商用的中文域名
    .net 用于网络供应服务商（系统类的经常使用NET域名）
    .org 用于官方组织
    .edu 用于教育院校
    .gov 用于政府机构

  [端口号]
    用来区分同一台服务器上不同服务的标识（基于WEB服务管理器创建服务的时候可以指定），不同服务之间一般是不能使用相同的端口号的

    HTTP =>默认端口号80
    HTTPS =>默认端口号443
    FTP =>默认端口号21
    如果当前网站服务，采用的是协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户把默认的端口传递给服务器

    一台服务器上的端口号范围：0~65535之间

    WEBSTORM预览页面：WS把自己的电脑当做服务器，在服务器上创建一个服务，端口号是63342，自己电脑上的浏览器预览自己电脑上的服务，属于本机服务请求，用localhost(127.0.0.1)本地域名即可
    http://localhost:63342/201802LESSON/WEEK7/0522DAY1/1.html

    服务器上安装一款应用都可能会作为一个服务，占用一个端口号

  [请求路径名称]
    path
    pathname
    例如：/stu/index.html 一般都是请求当前服务对应的项目目录中，STU文件夹中的INDEX.HTML页面。但是也有特情况，就是当前的URL是被“伪URL重写”的，我们看到的URL请求其实不是真实的请求（例如 https://item.jd.com/4679424.html 这个URL就是被重写的，它的真实URL地址很可能是 https://item.jd.com/detail.jsp?id=4679424，其实就是跳转到详情页，通过问号传递不同的产品编号，展示不同的产品详情信息，但是.jsp这种服务器渲染的动态页面不能被搜索引擎收录，不利于页面的SEO，所以我们会把动态页面静态化，这也就用到了URL重写技术）

    例如：/stu/info 这种没有任何后缀信息，一般都不是用来请求资源文件的，而是用于AJAX数据请求的接口地址（如果后缀是.json类的，也是同理），但是有一种除外 /stu/info/ 这种的很可能不是接口地址，而是没有指定请求的资源名称，服务器会请求默认的资源文件，一般都是index.html/default.html...

    DHTML：动态页面，泛指当前页面中的内容不是写死的而是动态绑定的，例如.jsp/.php/.aspx...这些页面中的数据都是基于AJAX或者是后台编程语言处理，由服务器端渲染，最后把渲染后的结果返回给客户端呈现的

  [问号传参及哈希值]
    ?xxx=xxx&...#xxx

    在HTTP事务中，问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的)

    哈希值一般都跟客户端服务器交互没啥关系，主要用于页面中的锚点定位和HASH路由切换

//========HTTP报文
起始行：请求起始行、响应起始行
首部（头）：请求头、响应头、通用头
主体：请求主体、响应主体

General 通用头
```
Request URL: http://www.zhufengpeixun.cn/  请求地址
Request Method: GET  请求方式:GET/POST/DELETE/PUT/HEAD/OPTION...
Status Code: 304 Not Modified   响应的HTTP状态码
Remote Address: 125.39.174.137:80  主机地址(服务器外网IP地址)
Referrer Policy: no-referrer-when-downgrade
```

Request Headers 请求头 [客户端设置，服务器接收]
```
GET / HTTP/1.1  =>起始行(描述当前请求的一些基本信息：用的是1.1版本传输协议进行内容传输的)
Host: www.zhufengpeixun.cn
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: ... =>cookie信息一般都是放到头文件中实现和服务器端的数据通信的
If-Modified-Since: Sun, 06 May 2018 10:02:42 GMT
```

Response Headers 响应头 [服务器端设置，客户端获取]
```
HTTP/1.1 304 Not Modified  =>响应起始行（HTTP状态码）
Date: Tue, 22 May 2018 09:18:56 GMT  =>服务器响应内容时候的“服务器端时间”（客户端获取这个时间的时候已经和真实的时间产生误差了，因为服务器返回内容到客户端接收到，也是需要时间的），并且这个时间是格林尼治时间（比北京时间慢8小时，北京时间是GMT+0800）
Connection: keep-alive
ETag: "700a6f-17f43-56b86a77513d3"
Vary: Accept-Encoding,User-Agent
Server: yunjiasu-nginx  //=>管理WEB服务的工具
CF-RAY: 41ee32c192db66b8-TSN
```

Response [响应主体]
```
  服务器返回的是啥就是啥
```

Request Payload / Form Data  [请求主体]
```
  客户端传递给服务器的内容
```

2. 大家了解HTTP报文以及如何查看对未来工作开发和BUG调试至关重要
 以后涉及到交互功能（前端<=>后台）出现问题，都按照如下方式查找问题原因
   A:打开控制台，在NET-WORK中找到当前交互的请求地址，点击进去看详情
   B:如果是传递给服务器的参数或者方式错误 [前端问题]
   C:如果服务器返回的信息有错误或者和API接口文档规定的内容不一样 [后台问题]
   D:如果返回数据是对的，但是展示有问题 [前端问题]

   确定是自己前端的问题后，基于断点(或者代码中的debugger)或者控制台输出等方式，开始逐步调试即可

3. 客户端和服务器端信息交互的方式
  [客户端传递给服务器]
     A:问号传参
      请求的URL地址末尾通过问号传参方式，把一些信息传递给服务器
      /stu/info?id=12&lx=man

     B:设置请求头
      客户端把需要传递给服务器的内容设置到请求头信息中（自定义请求头）,服务器可以通过接收请求头信息把内容得到

     C:设置请求主体
      xhr.send([AJAX SEND中传递的内容，就是客户端设置的请求主体内容，服务器端可以接收到这些信息的]);

  [服务器返回给客户端]
     A:设置响应头信息
      例如把服务时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度是优先于响应主体的）

     B:设置响应主体
      主要的返回信息都在响应主体中
````

###### 2.性能优化

```
===前端开发性能优化方案===
减少HTTP请求次数和请求大小
代码优化
  ->有利于SEO
  ->有利于扩展维护
  ->有利于减少性能消耗
  [JS代码优化的108条建议]  [雅虎CSS优化的36条建议]
  ...
DNS及HTTP通信方式的优化


1.在JS中尽量减少闭包的使用（原因：闭包会产生不释放的栈内存）
  A:循环给元素做事件绑定的时候，尽可能的把后期需要的信息（例如索引）存储到元素的自定义属性上，而不是创建闭包存储
  B:可以在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建闭包(例如单例模式)
  C:尽可能的手动释放不被占用的内存
  ...

2.尽量合并CSS和JS文件（把需要引入的CSS合并为一个，JS也是合并为一个），原理是在减少HTTP请求次数，尽可能的把合并后的代码进行压缩，减小HTTP请求资源的大小
  A:webpack这种自动化构建工具，可以帮我们实现代码的合并和压缩（工程化开发）
  B:在移动开发(或者追求高性能的PC端开发\[例如百度首页])，如果CSS或者JS不是需要很多，我们可以选择把css和js编程内嵌式（也就是代码直接写在HTML中）

3.尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片（因为字体图标等是矢量图(基于代码编写出来的)，放大不会变形，而且渲染速度快，相对比位图要小一些）

4.减少对DOM的操作（主要是减少DOM的重绘和回流(重排)）
  A:关于重排的分离读写
  B:使用文档碎片或者字符串拼接做数据绑定(DOM的动态创建)

5.在JS中避免“嵌套循环”（这种会额外增加很多循环次数）和“死循环”（一旦遇到死循环浏览器就卡壳了）

6.采用图片的“懒加载”（延迟加载）
  目的是为了减少页面“第一次加载”过程中HTTP的请求次数，让页面打开速度变快
  步骤：开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们再去做图片加载

7.利用浏览器和服务器端的缓存技术(304缓存)，把一些不经常更新的静态资源文件做缓存处理（例如：JS、CSS、静态图片等都可以做缓存）
   原理是为了减少HTTP请求大小，让获取速度更快

8.尽可能使用事件委托(事件代理)来处理事件绑定的操作，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定

9.尽量减少CSS表达式的使用(expression)
```

\#myDiv { position: absolute; width: 100px; height: 100px; left: expression(document.body.offsetWidth - 110 + "px"); top: expression(document.body.offsetHeight - 110 + "px"); background: red; }

````
10.CSS选择器解析规则是从右向左解析
```
.container .link a{
  先找到所有的A，再筛选是在.link样式类中的，再次筛选是在.container样式类中的... 先找到的是所有的A，操作起来是消耗性能的，我们在使用CSS选择器的时候尽可能减少对标签选择器的使用
}
```

11.CSS雪碧图技术(css sprite / css 图片精灵)
把所有相对较小资源图片汇总到一张大图上，后期我们只需要把大图加载下来，用背景定位的方式展示对应的小图即可
````

.bg{ background:url('xxx.png'); } .box1{ background-position:xx xx; } .box2{ background-position:xx xx; }

\```

13.减少对于COOKIE的使用（最主要的是减少本地COOKIE存储内容的大小），因为客户端操作COOKIE的时候，这些信息总是在客户端和服务器端传来传去

14.页面中的数据获取采用异步编程和延迟分批加载 使用异步获取数据，是为了降低HTTP通道的堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度（我们可以这样处理：需要动态绑定数据的区域先隐藏，等数据返回并且绑定完成后在让其显示） 延迟分批加载类似于图片懒加载，是为了减少第一次页面加载时候的HTTP请求次数

15.页面中出现音视频标签，我们不让页面加载的时候就去加载这些资源（要不然页面加载速度会变慢）（方案：只需要设置 preload='none' 即可），等待页面加载完成，音视频播放的时候我们在去加载音视频资源

16.在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小） ==>相对于XML格式的传输才会有这个优势

17.尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码（减少HTTP请求资源的大小）

20.CSS中设置定位后，最好使用Z-INDEX改变盒子的层级，让所有的盒子不在相同的平面上，这样后续处理的时候，性能有那么一丢丢的提高

21.在基于AJAX的GET请求进行数据交互的时候，根据需求可以让其产生缓存（这个缓存不是304缓存），这样下一次从相同地址获取的数据是上一次缓存的数据（但是很少用，项目中一般刻意清除这个缓存的时候偏多）

22.尽量减少对于filter滤镜属性的使用(这个属性消耗性能较大一些)

23.在CSS导入的时候尽量减少使用@import导入式，因为@import是同步操作，只有把这个对应的CSS导入，才会向下加载，而link是异步操作

24.配置ETag(有点类似于304缓存)

25.使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画

26.减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套（建议使用尾递归）

27.避免使用iframe（不仅不好管控样式，而且相当于在A页面中加载了其它页面，消耗较大）

28.利用H5中提供的localstorage本地存储或者是manifest离线缓存，做一些信息的本地存储，下一次加载页面的时候直接从本地获取，减少HTTP请求次数

29.基于SCRIPT调取JS的时候，可已使用 defer或者async 来异步加载

重量级优化：做CDN加速（烧钱机器）

=额外技巧= 1.我们一般都把CSS放到BODY上，把JS放到BODY下面（原因：让其先加载CSS在加载JS，先加载CSS是为了保证页面渲染的过程中，元素是带着样式渲染的，而JS一般都是用来操作DOM元素的，需要等到元素加载完再操作）

2.能用CSS搞定的绝对不用JS，能用原生JS搞定的绝对不用插件，绝对不使用FLASH（除了音视频的低版本浏览器播放） =>CSS处理动画等功能的性能优于JS，而且CSS中的transform变形还开起了硬件加速

3.JS中尽量减少对EVAL的使用，因为JS合并压缩的时候，可能出现由于符号不完善，导致的代码执行优先级错乱问题，EVAL处理起来消耗的性能也是偏大一点的

4.使用keep-alive实现客户端和服务器端的长连接

5.尽量使用设计模式来管理我们的代码（单例、构造、Promise、发布订阅），方便后期的升级和维护

6.开启服务器端的gzip压缩（这个压缩可以有效减少请求资源文件的大小），其实客户端的图片等资源也是可以进行压缩的（但是对于24位的位图，压缩后可能会变模糊）

7.页面中不要出现无效的链接（利于SEO优化），还有其它技巧：提高关键字曝光率、img需要加alt、设置meta标签、标签语义化...

8.避免使用with语句（非常耗性能）

````
###### 3.全局刷新和局部刷新

![image-20200924162014747](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200924162014747.png)

###### 4.ajax知识



​```js
1.async javascript and xml 异步的JS和XML
在AJAX中的异步不是我们理解的同步异步编程，而是泛指“局部刷新”，但是我们在以后的AJAX请求中尽可能使用异步获取数据（因为异步数据获取不会阻塞下面代码的执行）

XML是一种文件格式（我们可以把HTML理解为XML的一种）：可扩展的标记语言，它的作用是用自己扩展的一些语义标签来存储一些数据和内容，这样存储的好处是清晰的展示出数据的结构

很久以前，AJAX刚刚兴起的时候，客户端从服务器端获取数据，服务器为了清晰的表达数据结构，都是返回XML格式的内容，当下，我们获取的数据一般都是JSON格式的内容，JSON相对于XML来说，也能清晰表达数据结构，而且访问里面数据的时候操作起来比XML更简便（但是现在某些项目中，服务器返回给客户端的数据不单纯是数据，而是数据和需要展示的结构拼接好的结果(类似于我们自己做的字符串拼接)，换句话说，是服务器端把数据和结构拼接好返回给我们，此时返回的数据格式一般都是XML格式的字符串）

2.AJAX操作
```
//=>创建AJAX实例：IE6中是不兼容的，使用的是new ActiveXObject来实现的
let xhr = new XMLHttpRequest();

//=>打开请求：发送请求之前的一些配置项
//1.HTTP METHOD 请求方式
// GET/DELETE/HEAD/OPTIONS/TRACE/CONNECT
// POST/PUT
//2.URL 向服务器端发送请求的API（Application Programming Interface）接口地址
//3.ASYNC 设置AJAX请求的同步异步，默认是异步（写TRUE也是异步），FALSE是同步，项目中都使用异步编程，防止阻塞后续代码执行
//4.USER-NAME/USER-PASS：用户名密码，一般不用
xhr.open([HTTP METHOD],[URL],[ASYNC],[USER-NAME],[USER-PASS]);

//=>3.事件监听：一般监听的都是 READY-STATE-CHANGE 事件（AJAX状态改变事件），基于这个事件可以获取服务器返回的响应头响应主体内容
xhr.onreadystatechange=()=>{
  if(xhr.readyState===4 && xhr.status===200){
     xhr.responseText;
  }
};

//=>4.发送AJAX请求：从这步开始，当前AJAX任务开始，如果AJAX是同步的，后续代码不会执行，要等到AJAX状态成功后在执行，反之异步不会
xhr.send([请求主体内容]);
```

3.关于HTTP请求方式的一点学习
所有的请求都可以给服务器端传递内容，也都可以从服务器端获取内容
GET：从服务器端获取数据(给的少拿的多)
POST：向服务器端推送数据(给的多拿的少)
DELETE：删除服务器端的某些内容（一般是删除一些文件）
PUT：向服务器上存放一些内容（一般也是存放文件）
HEAD：只想获取服务器返回的响应头信息，不要响应主体中的内容
OPTIONS：一般使用它向服务器发送一个探测性请求，如果服务器端返回的信息了，说明当前客户端和服务器端建立了连接，我们可以继续执行其它请求了（TRACE是干这件事的，但是axios这个AJAX类库在基于cross domain进行跨域请求的时候，就是先发送OPTIONS请求进行探测尝试，如果能连通服务器，才会继续发送其它的请求）

4.GET VS POST
[传递给服务器信息的方式不一样]
GET是基于URL地址“问号传参”的方式把信息传递给服务器，POST是基于“请求主体”把信息传递给服务器
````

```
[GET]
xhr.open('GET','/temp/list?xxx=xxx&xxx=xxx')

[POST]
xhr.send('xxx=xxx&xxx=xxx')
```

```
GET一般应用于拿（给服务器的会少一些），而POST给服务器的很多，如果POST是基于问号传参方式来搞会出现一些问题：URL会拼接很长，浏览器对于URL的长度有有最大限度（谷歌8KB 火狐7KB IE2KB ...），超过的部分浏览器就把它截掉了 =>所以GET请求可以基于URL传参，而POST都是使用请求主体传递（请求主体理论上是没有限制的，真实项目中我们会自己做大小限制，防止上传过大信息导致请求迟迟完不成）

[GET不安全，POST相对安全]
 因为GET是基于“问号传参”把信息传递给服务器的，容易被骇客进行URL劫持，POST是基于请求主体传递的，相对来说不好被劫持；所以登录、注册等涉及安全性的交互操作，我们都应该用POST请求；

[GET会产生不可控制的缓存,POST不会]
 不可控：不是想要就要，想不要就不要的，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉
 GET请求产生缓存是因为：连续多次向相同的地址（并且传递的参数信息也是相同的）发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据（POST不会）

 解决方案：
```

```
xhr.open('GET',`/temp/list?lx=1000&_=${Math.random()}`); //=>保证每次请求的地址不完全一致：在每一次请求的末尾追加一个随机数即可(使用_作为属性名就是不想和其它的属性名冲突)
```

```
5.AJAX状态(READY-STATE)   左边是状态码
0 =>UNSENT  刚开始创建XHR，还没有发送
1 =>OPENED  已经执行了OPEN这个操作
2 =>HEADERS_RECEIVED 已经发送AJAX请求（AJAX任务开始），响应头信息已经被客户端接收了（响应头中包含了：服务器的时间、返回的HTTP状态码...）
3 =>LOADING 响应主体内容正在返回
4 =>DONE 响应主体内容已经被客户端接收

6.HTTP网络状态码(STATUS)
根据状态码能够清楚的反映出当前交互的结果及原因
200 OK 成功(只能证明服务器成功返回信息了，但是信息不一定是你业务需要的)

301 Moved Permanently 永久转移（永久重定向）
 =>域名更改，访问原始域名重定向到新的域名

302 Move temporarily 临时转移（临时重定向 =>307）
 =>网站现在是基于HTTPS协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上
 =>302一般用作服务器负载均衡：当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其它的服务器机组上处理
 =>偶尔真实项目中会把所有的图片放到单独的服务器上“图片处理服务器”，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理

304 Not Modified 设置缓存
 =>对于不经常更新的资源文件，例如：CSS/JS/HTML/IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取；如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取；基于CTRL+F5强制刷新页面，304做的缓存就没有用了。

400 Bad Request 请求参数错误
401 Unauthorized 无权限访问
404 Not Found  找不到资源(地址不存在)
413 Request Entity Too Large 和服务器交互的内容资源超过服务器最大限制

500 Internal Server Error 未知的服务器错误
503 Service Unavailable 服务器超负荷

7.关于XHR的属性和方法
xhr.response  响应主体内容
xhr.responseText 响应主体的内容是字符串（JSON或者XML格式字符串都可以）
xhr.responseXML 响应主体的内容是XML文档

xhr.status 返回的HTTP状态码
xhr.statusText 状态码的描述

xhr.timeout 设置请求超时的时间
xhr.withCredentials 是否允许跨域（FALSE）

xhr.abort() 强制中断AJAX请求
xhr.getAllResponseHeaders() 获取所有响应头信息
xhr.getResponseHeader([key]) 获取KEY对应的响应头信息，例如：xhr.getResponseHeader('date')就是在获取响应有中的服务器时间

xhr.open() 打开URL请求
xhr.overrideMimeType() 重写MIME类型
xhr.send() 发送AJAX请求
xhr.setRequestHeader() 设置请求头
```

例题：

```
<!--<script>
    let xhr = new XMLHttpRequest();  //状态0
    xhr.open('GET', '/temp/list', true);//=>异步 //状态码 1
    xhr.onreadystatechange = () => {//=>监听的是AJAX状态“改变”事件：设置监听之前有一个状态，当后续的状态和设置之前的状态不相同，才会触发这个事件
        if (xhr.readyState === 2) {
            console.log(1);
        }
        if (xhr.readyState === 4) {
            console.log(2);
        }
    };
    xhr.send();//=>发送AJAX请求：这个执行才证明AJAX任务开始  //状态码 3
    console.log(3);
    //=>3 1 2
</script>-->

<!--<script>
    let xhr = new XMLHttpRequest();
    xhr.open('GET', '笔记.MD', true);
    xhr.send();//=>AJAX任务开始(异步)
    //此时状态是1
    xhr.onreadystatechange = () => {
        if (xhr.readyState === 2) {
            console.log(1);
        }
        if (xhr.readyState === 4) {
            console.log(2);
        }
    };
    console.log(3);
    //=>3 1 2
</script>-->

<!--<script>
    let xhr = new XMLHttpRequest();
    xhr.open('GET', '笔记.MD', false);
    xhr.onreadystatechange = () => {//=>监听前的状态是1
        if (xhr.readyState === 2) {
            console.log(1);
        }
        if (xhr.readyState === 4) {
            console.log(2);
        }
    };
    xhr.send();//=>任务开始(同步：只要当前AJAX请求这件事没有完成，什么都不能做)
    console.log(3);
    //=>2 3  当AJAX任务开始，由于是同步编程，主任务队列在状态没有变成4（任务结束）之前一直被这件事占用着，其它事情都做不了（当服务器把响应头返回的时候，状态为2，触发了事件readystatechange，但是由于主任务队列没有完成，被占着呢，绑定的方法也无法执行... 所有只有状态为4的时候执行一次这个方法）
</script>-->
```

###### 5.倒计时例子

```
   let queryTime = function queryTime() {
        //=>从服务器端获取时间会存在一个问题：由于服务器端返回数据需要时间，所以客户端拿到返回的“服务器时间”的时候，已经过去一会了，导致获取的时间和真实的时间是有一定误差的，这个误差越小越好，那么如何减少误差：
        //1.在AJAX为2的时候就从响应头中获取信息，而不是等到更靠后的状态4
        //2.请求方式设置为HEAD：只获取响应头信息即可，响应主体内容不需要
        //3.特殊：即使我们想服务器发送一个不存在的请求地址，返回的是404状态码，但是响应头信息中都会存在服务器的时间（不建议使用，不友好）

        //=>第二次执行QUERY-TIME：
        //用之前记录的全局变量值，但是需要把这个值手动累加1秒钟
        if (_serverTime) {
            _serverTime = new Date(_serverTime.getTime() + 1000);
            return _serverTime;
        }

        //=>第一次向服务器发送请求:把获取的结果存储到全局变量中
        return new Promise(resolve => {
            let xhr = new XMLHttpRequest(),
                serverTime = null;
            xhr.open('HEAD', 'json/data.json');
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 2) {
                    serverTime = new Date(xhr.getResponseHeader('date'));
                    _serverTime = serverTime;
                    resolve(serverTime);
                }
            };
            xhr.send(null);
        });
    };


 let computedTime = function computedTime() {
        //=>这样处理也有一个问题：一个客户端每间隔1秒都会向服务器发送一个新的请求，这样下去访问用户多，服务器就爆了（超过负载均衡）
        //=>解决方案：创建一个全局变量，记录第一次从后台获取的服务器时间，每一秒刷新的时候，都是在第一次的基础上一直累加一秒，而不是重新重新从服务器获取（减轻服务器的压力）
        let promise = queryTime();
        promise instanceof Promise ? promise.then(fn) : fn(promise);

        function fn(serverTime) {
            let nowTime = serverTime,
                tarTime = new Date('2018/05/24 18:00:00'),
                diffTime = tarTime - nowTime;

            //=>在毫秒差中计算出对应的“时分秒”
            if (diffTime >= 0) {
                let hours = Math.floor(diffTime / (1000 * 60 * 60));
                diffTime = diffTime - hours * 3600000;
                let minutes = Math.floor(diffTime / (1000 * 60));
                diffTime = diffTime - minutes * 60000;
                let seconds = Math.floor(diffTime / 1000);

                hours < 10 ? hours = '0' + hours : null;
                minutes < 10 ? minutes = '0' + minutes : null;
                seconds < 10 ? seconds = '0' + seconds : null;

                timeSpan.innerHTML = `${hours} : ${minutes} : ${seconds}`;
                return;
            }

            //=>已经到达抢购的时间了
            timeSpan.innerHTML = '-- : -- : --';
            clearInterval(autoTimer);
        }
    };

    computedTime();
    autoTimer = setInterval(computedTime, 1000);


    /*
     * new Date() 获取当前客户端本机时间（是标准的时间格式数据 =>对象）
     *   Thu May 24 2018 12:21:09 GMT+0800 (中国标准时间)
     *
     * new Date("时间字符串") 把指定的时间字符串转换为标准时间数据，时间字符串支持很多格式，例如："xxxx-xx-xx xx:xx:xx" 中杠换成斜杠也可以 、"xxxx/xx/xx" ...
     */
```

```
 //=>$.ajax([URL],[OPTIONS]) 或者 $.ajax([OPTIONS]) 在OPTIONS中有一个URL字段代表请求的URL地址
    //=>$.get / $.post / $.getJSON / $.getScript 这些方法都是基于$.ajax构建出来的快捷方法，项目中最常使用的还是$.ajax
    
     * URL：请求的API接口地址
     * METHOD：请求的方式
     *
     * DATA：传递给服务器的信息可以放到DATA中
     *   如果是GET请求是基于问号传参传递过去的
     *   如果是POST请求是基于请求主体传递过去的
     *
     *   DATA的值可以是对象也可以是字符串(一般常用对象)
     *     如果是对象类型，JQ会把对象转换为 xxx=xxx&xxx=xxx 的模式(x-www-form-urlencoded)
     *     如果是字符串，我们写的是什么就传递什么
     *
     * DATA-TYPE：预设置获取结果的数据格式 TEXT/JSON/JSONP/HTML/SCRIPT/XML...（服务器返回给客户端的响应主体中的内容一般都是字符串[JSON格式居多]），而设置DATA-TYPE='JSON'，JQ会内部把获取的字符串转为JSON格式的对象 =>“他不会影响服务返回的结果，只是把返回的结果进行了二次处理”
     *
     * ASYNC：设置同步或者异步（TRUE->异步 FALSE->同步）
     * CACHE：设置GET请求下是否建立缓存（默认TRUE->建立缓存 FALSE->不建立缓存），当我们设置FALSE，并且当前请求是GET请求，JQ会在请求的URL地址末尾追加随机数（时间辍）
     *
     * SUCCESS：回调函数，当AJAX请求成功执行，JQ执行回调函数的时候会把从响应主体中获取的结果(可能二次处理了)当做参数传递给回调函数
     * ERROR：请求失败后执行的回调函数
     */
    /*$.ajax({
        url: 'https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/list',
        method: 'GET',
        data: {
            name: '周啸天',
            age: 28
        },
        dataType: 'json',
        async: true,
        cache: false,
        success: (result, textStatus, xhr) => {
            //=>RESULT就是从服务器获取的结果
            console.log(result);
            console.log(textStatus);
            console.log(xhr.getResponseHeader('date'));//=>jqXHR
        },
        error: () => {

        }
    });
```

###### 6.Promise

```
/*
 * Promise是ES6中新增加的内置类：目的是为了管理异步操作的
 *   1.new Promise() 创建类的一个实例，每一个实例都可以管理一个异步操作
 *    ->必须传递一个回调函数进去（回调函数中管理你的异步操作）,不传递会报错
 *    ->回调函数中会有两个参数
 *      resolve：异步操作成功做的事情（代指成功后的事件队列 =>成功后要做的所有的事情都存放到成功这个事件队列中）
 *      reject：异步操作失败做的事情（代指失败后的事件队列）
 *    ->new Promise的时候立即把回调函数执行了（Promise是同步的）
 *
 *  2.基于Promise.prototype.then方法（还有catch/finally两个方法）向成功队列和失败队列中依次加入需要处理的事情
 *
 *  3.如果是多个THEN掉用，不是像我们想象的依次把增加的方法执行
 *    异步操作成功或者失败，先把第一个THEN中的方法执行，每当执行一个THEN会返回一个新的Promise实例，这个实例管控的是第一个THEN中方法执行的是成功还是失败
 *
 */
/*let promise1 = new Promise((resolve, reject) => {
    $.ajax({
        url: 'json/data2.json',
        success(result) {
            resolve(result);
        },
        error(msg) {
            reject('no');
        }
    });
});
promise1.then(
    result => {
        console.log('THEN1 OK', result);
        return 100;
    },
    msg => {
        console.log('THEN1 NO', msg);
        return 100;
    }
).then(
    result => {
        console.log('THEN2 OK', result);
    },
    msg => {
        console.log('THEN2 NO', msg);
    }
);*/

//=>建议不要使用THEN中的第二个参数（这样看起来很乱），而是建议我们使用Promise.prototype.catch来管理失败的情况
/*let promise1 = new Promise((resolve, reject) => {
    $.ajax({
        url: 'json/data2.json',
        success(result) {
            resolve(result);
        },
        error(msg) {
            reject('no');
        }
    });
});
promise1.then(result => {
    console.log('THEN1 OK', result);
    100();
    return 100;
}).catch(msg => {
    //=>第一个CATCH
    //1.异步请求失败会执行它
    //2.第一个THEN方法失败也会执行它
    console.log('CATCH1', msg);
}).then(result => {
    console.log('THEN2 OK', result);
}).catch(msg => {
    console.log('CATCH2', msg);
});*/

//=>JS中的异常捕获（目的：把抛出异常的错误捕获到，不让其阻断浏览器的继续执行）
/*
try {
    //=>正常执行的JS代码(可能会报错)
    1();
} catch (e) {
    //=>TRY中的代码报错了会执行CATCH
    console.log(e.message);
} finally {
    //=>不管TRY中的代码成功还是失败都会执行
}
*/


let A = function A() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, 1000);
    });
};

let B = function B() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, 1000);
    });
};

let promise = A();
promise.then(() => {
    console.log(1);
    return B();//=>如果方法中返回的一个具体值，而且执行中没有错误异常，会立即执行下一个THEN中的方法（不写RETURN也是返回的了具体值：undefined），但是如果返回的是一个PROMISR实例（并且管控了一个异步操作），只能等PROMISE完成，把成功后的结果当做具体的值返回，才能进入下一个函数执行
}).then(() => {
    console.log(2);
});
```

###### 7.axios

```
    /*
     * axios：它是一个类库，基于PROMISE管理的AJAX库
     *   1.提供了对应请求方式的方法（例如：get/post/head/delete/put/options...）
     *     axios.get() 向服务器发送一个请求，基于的是GET方式
     *     ...
     *
     *   2.支持的参数配置
     *     axios.get([URL],[OPTIONS])
     *
     *   3.基于GET或者POST方法发请求，返回的结果都是PROMISE实例
     */
    /*
    
    
      /*let result = null;
    axios.get('A').then(resultA => {
        result = resultA;
        return axios.get('B');
    }).then(resultB => {
        //=>A和B都成功执行:RESULT-B是B成功后的结果
        //=>全局RESULT是A的结果
    });*/

    //=>SEND-ARY存放三个AJAX请求的PROMISE实例
    let sendAry = [
        axios.get('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/list'),
        axios.get('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/info'),
        axios.post('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/add')
    ];
    //=>三个请求都完成才做一些事情（可以基于ALL实现）
    /*axios.all(sendAry).then(result => {
        console.log(result);//=>是一个数组，分别存储每一个请求的结果
        let [resA, resB, resC] = result;
    });*/

    /*module.exports = function spread(callback) {
        return function wrap(arr) {
            return callback.apply(null, arr);
        };
    };
    let wrap = axios.spread(() => {
    });
    axios.all(sendAry).then(axios.spread((resA, resB, resC) => {
        //=>RES-A/-B/-C分别代表三次请求的结果
        //=>原理是JS中的柯理化函数
    }));*/


//=>初始化一些常用的配置项
    axios.defaults.baseURL = 'https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp';
    axios.interceptors.response.use(result => result.data);
    axios.defaults.validateStatus = status => /^(2|3)\d{2}$/.test(status);

    //=>设置在POST请求中基于请求主体向服务器发送内容的格式，默认是RAW，项目中常用的是URL-ENCODEED格式
    axios.defaults.headers['Content-Type'] = 'appliction/x-www-form-urlencoded';
    axios.defaults.transformRequest = data => {
        //=>DATA:就是请求主体中需要传递给服务器的内容（对象）
        let str = ``;
        for (let attr in data) {
            if (data.hasOwnProperty(attr)) {
                str += `${attr}=${data[attr]}&`;
            }
        }
        return str.substring(0, str.length - 1);
    };


    // axios.defaults.validateStatus = function validateStatus(status) {
    //     //=>自定义成功失败规则：RESOLVE / REJECT（默认规则：状态码以2开头算作成功）
    //     return /^(2|3)\d{2}$/.test(status);
    // };

    /*axios.interceptors.response.use(function success(result) {
        return result.data;
    }, function error() {

    });//=>设置响应拦截器：分别在响应成功和失败的时候做一些拦截处理（在执行成功后设定的方法之前，先会执行拦截器中的方法）*/
    // axios.defaults.timeout = 3000;
    // axios.defaults.headers = {//=>自定义请求头
    //     name: 'zfpx'
    // };
    // axios.defaults.params={};//=>GET传参
    // axios.defaults.data={};//=>POST传参

    //=>使用
    /*axios.get('/list', {
        params: {
            lx: 12
        },
        headers: {xxx: 'xxx'}
    }).then(result => {
        console.log(result);
        //=>result.headers:服务器返回的响应头信息
    });*/

    //=>POST：三个参数 axios.post(url[,data][,config])
    axios.post('/add', {
        lx: 12,
        sex: 1
    }).then(result => {
        console.log(result);
    });
```

###### 8.fetch

```
     * FETCH不是AJAX，它诞生的目的是为了代替AJAX，它是JS中内置的API：基于FETCH可以实现客户端和服务器端的信息通信
     *   1.FETCH是ES2018规范中新增的API，所以浏览器的支持度不是特别好（可以基于BABEL的最新语法解析包，把其进行解析），想要兼容性好一些，需要使用 “fetch polyfill”
     *
     *   2.使用FETCH发送请求
     *
     *     => GET/HEAD等请求不能设置BODY
     *     => 不管服务器返回的状态是多少，FETCH都不认为是失败（那怕是4或者5开头的状态码），都执行的是THEN中的方法（需要我们自己进行异常抛出处理）
     */
    fetch('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/info2', {
        method: 'GET',
        headers: {
            //=>设置请求头
            'content-type': 'x-www-form-urlencoded'
        },
        //=>不管同源还是跨域请求都带着COOKIE信息
        credentials: 'include'
    }).then(result => {
        console.log(result);
        /!*
         * headers：{} 包含响应头信息
         * redirected：false 是否重定向
         * status：状态码
         * statusText
         * type：'basic'/'cors'
         * url：请求的地址
         *
         * __proto__:Response
         *   arrayBuffer()
         *   blob()
         *   json()
         *   text()
         *   ...
         *   基于这些方法可以快速的把从服务器获取的结果找到
         *!/
    });*/

    fetch('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/info').then(result => {
        let {status} = result;
        if (/^(4|5)\d{2}$/.test(status)) {
            throw new Error('query data is error!');
            return;
        }
        return result.json();
    }).then(result => {
        console.log(result);
    }).catch(msg => {
        console.log(msg);
    });*/

    fetch('https://www.easy-mock.com/mock/5b0412beda8a195fb0978627/temp/add', {
        method: 'POST',
        body: 'a=1&b=2'//=>BODY中只支持字符串(GET请求还无法设置BODY)
    }).then(result => {
        let {status} = result;
        if (/^(4|5)\d{2}$/.test(status)) {
            throw new Error('query data is error!');
            return;
        }
         return result.json();
    }).then(result => {
        console.log(result);
    }).catch(msg => {
        console.log(msg);
    });
```

# ======node

```
安装 koa-generator
koa2 项目名创建
```



#### 1.static

##### 1.module.export 和exports

```js
1.Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量
    var module = {
        id: 'hello',
        exports: {}
    };
   // 来存放load()函数最总的返回module.exports
   	// load（）函数
        var load = function (exports, module) {
        // hello.js的文件内容
        ...
        // load函数返回:
        return module.exports;
    };

    var exported = load(module.exports, module);
2.得出Node准备的exports变量和module.exports变量实际上是同一个变量
3.当给exports变量赋值为一个新对象的时改变的是exports的地址内存，但并不会影响module.exports的值，所有exports不能赋值一个对象否则引用的时候为空
```

#### 2.fs

##### 1.buffer和toString转化

```js
当读取二进制文件时，不传入文件编码时
var fs = require('fs');

fs.readFile('sample.png', function (err, data) {
    if (err) {
        console.log(err);
    } else {
        console.log(data);
        console.log(data.length + ' bytes');
    }
});
//buffer=>String
var text = data.toString('utf-8');
// String -> Buffer
var buf = Buffer.from(text, 'utf-8');

```

##### 2.stat

```js
var fs = require('fs');

fs.stat('sample.txt', function (err, stat) {
    if (err) {
        console.log(err);
    } else {
        // 是否是文件:
        console.log('isFile: ' + stat.isFile());
        // 是否是目录:
        console.log('isDirectory: ' + stat.isDirectory());
        if (stat.isFile()) {
            // 文件大小:
            console.log('size: ' + stat.size);
            // 创建时间, Date对象:
            console.log('birth time: ' + stat.birthtime);
            // 修改时间, Date对象:
            console.log('modified time: ' + stat.mtime);
        }
    }
});
```

##### 3.stream

```js
1.createReadStream读取流
// 打开一个流:
var rs = fs.createReadStream('sample.txt', 'utf-8');

rs.on('data', function (chunk) {
    console.log('DATA:')
    console.log(chunk);
});
rs.on('end', function () {
    console.log('END');
});
rs.on('error', function (err) {
    console.log('ERROR: ' + err);
});

2.createWriteStream写入流
var fs = require('fs');

var ws1 = fs.createWriteStream('output1.txt', 'utf-8');
ws1.write('使用Stream写入文本数据...\n');
ws1.write('END.');
ws1.end();

var ws2 = fs.createWriteStream('output2.txt');
ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));
ws2.write(new Buffer('END.', 'utf-8'));
ws2.end();

3.pipe两个水管串成一个更长的水管一样，两个流也可以串起来
pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序
var fs = require('fs');
var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');
rs.pipe(ws);
```

##### 4.判断一个文件夹是否存在

```js
1.fs.exists()  //直接返回true和false 但不推荐在 fs.open()、 fs.readFile() 或 fs.writeFile() 之前使用 fs.exists() 判断文件是否存在，会引起竞态条件。
fs.exists('/etc/passwd', (exists) => {
  console.log(exists ? '存在' : '不存在');
});

2.fs.stat //判断是否是一个文件，如果是一个文件就代表存在
const stats = await util.promisify(fs.stat)('text1.txt');
console.log(stats.isDirectory()); // false
console.log(stats.isFile()); // true

3.fs.access //fs.access 接收一个 mode 参数可以判断一个文件是否存在、是否可读、是否可写，返回值为一个 err 参数 若果err不存在文件就存在(推荐使用)

const file = 'text.txt';

// 检查文件是否存在于当前目录中。
fs.access(file, fs.constants.F_OK, (err) => {
  console.log(`${file} ${err ? '不存在' : '存在'}`);
});

// 检查文件是否可读。
fs.access(file, fs.constants.R_OK, (err) => {
  console.log(`${file} ${err ? '不可读' : '可读'}`);
});

// 检查文件是否可写。
fs.access(file, fs.constants.W_OK, (err) => {
  console.log(`${file} ${err ? '不可写' : '可写'}`);
});

// 检查文件是否存在于当前目录中、以及是否可写。
fs.access(file, fs.constants.F_OK | fs.constants.W_OK, (err) => {
  if (err) {
    console.error(
      `${file} ${err.code === 'ENOENT' ? '不存在' : '只可读'}`);
  } else {
    console.log(`${file} 存在，且可写`);
  }
});
```



#### 3.宏任务与微任务

```js
1.同步代码分为宏任务，微任务
2.异步任务会放到EventLoop里面，同步任务执行完毕会把异步任务推到EventLoop里面执行  
3.	宏任务
		主体script，setTimeout，setInterval
	微任务
		Promise，process.nextTick
4.示例：
setTimeout(()=>{
    //宏任务
    console.log('1');

    //宏任务，但这里是异步要等待  开定时器是同步的，执行的函数是异步的
    setTimeout(()=>{
        console.log('3');
    },100)

    //宏任务 new Promise()是宏任务
    new Promise((resolve)=>{
        console.log('2')
        resolve();
        //then处理是微任务
    }).then(()=>{
        console.log('then')
    })
    
},100)

//首先setTimeout是异步任务，当主线程的同步任务完成，会将setTimeout分配到EventLoop中执行
//总结：同步任务》异步任务  宏任务》微任务
```

#### 4.模块化

##### 1.独立模块

一个文件就是一个独立的模块

每一个模块都有自己的独立作用域

##### 2.导入导出

require导入

```js
//导入会返回一个exports对象
var hello = require('./hello');
hello.world();
```



exports导出

```js
exports.world = function() {
  console.log('Hello World');
}
```

##### 3.模块对象

每一个模块都会有一个内置对象：module

```js
module{

​		id:当前模块的唯一标识，默认id为当前这个文件的绝对路径
​		filename：当前模块的文件 
​		parent
​		children
​		loaded
​		paths

}

module.require=require
module.exports = exports
虽然module.exports=exports相等，但又区别
//导出单个没有问题
exports.a=1  
exports.b=2 
//引入
require()//{a:1,b:2}
//这里可以是因为
//var module ={
//    exports:{}
//}
//var exports = module.exports//两者关联
//exports.a = module.exports.a
//exports.b = module.exports.b

//导出多个
exports={
    a:1,
    b:2
}
//引入
require()  //{}


//导出多个
module.exports={
    a:1,
    b:2
}
//引入
require()  //{a:1,b:2}

原因：
 exports={a:1，b:2}相当于重新赋值一个对象，不会对原对象发生改变，所以导出为空

```

##### 4.模块化的分类

```js
File Modules  //普通文件
	Folders as Modules 文件夹
		node_modules Folders  nodemodule文件夹
		global folders 全局文件夹
	Core Modules  核心文件夹
	
1.当我门导入一个模块是文件夹的时候：
   1. 读取该文件夹下的package.json文件
   2. 导入package.json文件中main选项指定的文件
   3. 如果不存在package.json或者main指定的文件，这默认自动导入模块文件夹下的index.js
2.当我们导入的是node_module文件夹下的模块的时候
	1.如果模块的加载是以 ./ ../ / 开始的，那么就是路径模块加载模式，按路径查找
	2.不以 ./ ../ / 开始的模块，按照另外一种加载机制进行加载
     require()方法其实是module.require()
     当非路径加载模式的时候，会按照如果下规则进行模块的查找
     在module对象有一个属性，paths，是一个数组，里面保存的就是这种非路径加载模式需要查找的路径列表
	// let m2 = require('./node_modules/m2'); 当指定路径会根据路径查找
    // let m2 = require('m2'); //当没指定路径，会从当前的node_module的文件夹里找，没有，就像上一级的文		件夹里面找，module内置对象里的path就包含了可查找的路径
 3. // 如果自己定义的模块与核心模块冲突了，那么默认加载的是核心模块
	// let fs = require('fs');
	// console.log(fs);
```

##### 5.ECMA模块的导入导出

**导入模块后缀为.mjs**

导出 

```js
export var a = 1;
export var obj = {x: 100};

// 每个模块只能同时存在一个default
export default 100;
```

导入

```js
// import {a, obj} from './2';

//import * as m2 from './2';  //m2别名表示所有数据

import v from './2'; //默认值



console.log(v);
```

#### 5.核心部分

##### 1.event事件

事件类似与dom都有类似结构

事件是整个 Node.js 的核心，Node.js中大部分模块都使用或继承了该模块（类似 WebAPI 中的EventTarget）

使用Event需要导入

event事件只有一个核心类

require('events')

```js
const EventEmmiter = require('events');

class Person extends EventEmmiter {
    constructor(name){
        //要先实现继承方法
        super();
        this.name = name;
        this.age = 0;
        //实现继承的方法
    
        this.growup();
    }
    //创建一个行为
    growup(){
        setInterval(() => {
         this.age++;
        //传递事件
        this.emit('growup');
        }, 1000);
        
    }
}

const p1 = new Person("小王");  //创建实例执行了够造方法

//监听事件
p1.addListener('growup',()=>{
    console.log('又长大了一岁');
})




1.addListener(event, listener)
为指定事件添加一个监听器到监听器数组的尾部。
2	on(event, listener)
为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。
server.on('connection', function (stream) {
  console.log('someone connected!');
});
3	once(event, listener)
为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。
server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});
4	removeListener(event, listener)
移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。

它接受两个参数，第一个是事件名称，第二个是回调函数名称。

var callback = function(stream) {
  console.log('someone connected!');
};
server.on('connection', callback);
// ...
server.removeListener('connection', callback);
5	removeAllListeners([event])
移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。
6	setMaxListeners(n)
默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。
7	listeners(event)
返回指定事件的监听器数组。
8	emit(event, [arg1], [arg2], [...])
按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。
```

##### 2.process

process 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程

```js
.argv
.env
.exit([code])
...


1.process.argv 属性会返回一个数组，其中包含当 Node.js 进程被启动时传入的命令行参数。 第一个元素是 		process.execPath。 如果需要访问 argv[0] 的原始值，则参见 process.argv0。 第二个元素是正被执行的 JavaScript 文件的路径
2.env当前的开发环境
3.exit进程退出  code <integer> 退出码。默认值: 0。
4.根据进程的输入输出完成文件的创建
const fs = require('fs');
//输出
// process.stdout.write('hello')


//接受输入流，用户输入后的东西可以被获取到
//在默认情况下输入流是关闭的，要监听输入流首先要开启输入流
process.stdin.resume();

process.stdin.on('data', (e) => {
    console.log('用户输入', e.toString());
});



5.process.stdout
		标准输出流
		.write(data[, encoding][, callback])
	process.stdin
		标准输入流
		事件：
			'data'

//创建文件夹
process.stdout.write("请输入要创建的文件夹")
process.stdin.on('data',(filename)=>{
    fs.mkdirSync(filename.toString().replace('\n\r',''))
    process.stdout.write("创建文件成功")
})
```

##### 3.stream流

###### 3.1stream基础

流（stream）是一种在 Node.js 中处理流式数据的抽象接口。 stream 模块提供了一些基础的 API，用于构建实现了流接口的对象，Node.js 中许多的对象都是提供了流的实现：fs文件操作、net、dgram、http、https等
	使用
		require('stream')

```
流的基本类型:
		Writable - 可写入数据的流（例如 fs.createWriteStream()）
		Readable - 可读取数据的流（例如 fs.createReadStream()）
		Duplex - 可读又可写的流（例如 net.Socket）
        Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）
1.Writable属性方法
		.write(chunk[, encoding][, callback])
		.end([chunk][, encoding][, callback])
		.setDefaultEncoding(encoding)
	Writable事件
2.	Readable属性方法
		.setEncoding(encoding)
		.read([size])
		.pipe(destination[, options])
		.pause()
		.resume()
	Readable事件


3.pipe管道将可读流传入可写流 ，pipe方法存在两个参数
readable.pipe(destination[, options])
destination：是一个可写流对象
end：读取结束时终止写入流 默认是true
```

###### 3.2多个文件写入

```js
如果要实现多个文件写入一个文件中就需要开启持续可写入流
就要将  readStream.pipe(fileWriteStream,{end:false})  end设置为false
但需要监听每个写入流写入完毕过后要关闭写入流

const fs = require('fs')
const path = require('path')
/**
 * 
 * @param {string} sourcePath  文件的根文件
 * @param {*} targrtSource  合并文件的目标文件
 */
function mergeFile(sourcePath,targrtSource){
    const mergefiles = fs.readdirSync(path.resolve(__dirname,sourcePath))
    const fileWriteStream = fs.createWriteStream(path.resolve(__dirname,targrtSource))

    streamMergeRecursive(mergefiles, fileWriteStream);
}
/**
 * 
 * @param {*} mergefiles 合并文件下的所有目录列表
 * @param {*} fileWriteStream 写入目标文件流
 */
function streamMergeRecursive(mergefiles,fileWriteStream){
    if(!mergefiles.length){
      return  fileWriteStream.end("console.log('文件写入完毕')")  //调用可写流的end方法表示之后不在可以写入关闭流，关闭流之前可以写入最后一个额外的内容
    }
    const currentFile = mergefiles.shift()
    const readStream = fs.createReadStream(path.resolve(__dirname,'mergefiles/',currentFile))
    readStream.pipe(fileWriteStream,{end:false})
    readStream.on('end',function(){
        streamMergeRecursive(mergefiles,fileWriteStream)
    })
    readStream.on('error',function(){
        console.error('error')
        fileWriteStream.close()  //文件写入过程发生错误也要关闭写入流
    })
}

mergeFile('./mergefiles','./mergetarget.txt')
```



##### 4.buffer

用于操作二进制数据的类
		- 类似数组
		- 长度固定
		- 只能操作二进制数据
	Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require

```js
Buffer.alloc(size[, fill[, encoding]])  //分配字节大小
分配一个大小为 size 字节的新建的 Buffer。 如果 fill 为 undefined， 则该 Buffer 会用 0 填充， encoding默认为 'utf8'
Buffer也有下标， 可以通过 buf[index] 进行操作
length： 字节长度（ 非字符长度）


Buffer的方法：
	buf.fill(value[, offset[, end]][, encoding]) //填充
	buf.write(string[, offset[, length]][, encoding]) //写 [写入的字符，写入位置，写入长度]
	buf.includes(value[, byteOffset][, encoding])  //包含
	buf.indexOf(value[, byteOffset][, encoding])  //找到索引
	buf.equals(otherBuffer)  //buffer的比较是否相等
	buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])  //复制
	buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]]) //比较
    Buffer.byteLength(string[, encoding])//字节长度
	Buffer.compare(buf1, buf2)
	Buffer.concat(list[, totalLength])//拼接
	Buffer.from(array)//使用 0 – 255 范围内的字节数组 array 来分配一个新的 Buffer。 超出该范围的数组	  条目会被截断以适合它。
	Buffer.isBuffer(obj)  //判断是否时buffer类型
	Buffer.isEncoding(encoding)//检查的字符编码名称。


const buf = new ArrayBuffer(4);
console.log(buf);
//自动分配
let bf4 = new Buffer.alloc(10);
//填充
bf4.fill(0x60, 2, 4);
console.log(bf4);
```

##### 5.文件系统

fs模块提供了一些与文件系统进行交互的 API

文件系统包含很多，主要有四个

```
1.文件读取类
fs.ReadStream 类
		fs.createReadStream(path[, options])
2.文件写入类
fs.WriteStream 类
		fs.createWriteStream(path[, options])
3.文件基本信息类
fs.Stats 类
		fs.stat(path[, options], callback)
4.文件监听类
fs.FSWatcher 类
		fs.watch(filename[, options][, listener])
		fs.watchFile(filename[, options], listener)
```

```js
//1.写入文件
//方法加ysnc是同步读取
fs.writeFile(file, data[, options], callback)
// 数据（字符串，音频，视频，二进制） => buffer => stream
// 如果文件不存在，则创建
// 如果目录不存在，创建文件就会失败
fs.writeFile('b.txt','kao',(err)=>{
    if(err){
        console.log('文件写入失败');
    }else{
        console.log('文件写入成功');
    }
})

//输入一个不存在的目录  同步异常用try-catch捕获
try {
    // fs.writeFileSync('G:/aaa/1.txt', 'Miaov');
    fs.writeFileSync('./1.txt', 'Miaov');
    console.log('写入成功');
} catch(e) {
    console.log('写入失败');
}

2.//追加内容
fs.appendFileSync('./1.txt', '我是追加的内容');

3.//读文件
let content = fs.readFileSync('./a.txt');

4.//获取文件其它信息
let info = fs.statSync('./a.txt');
console.log(info);
console.log(info.isFile());

5.//删除文件
fs.unlinkSync('./1.txt');


6.//创建文件夹

//创建，不会进行递归创建
fs.mkdirSync('./a/b/c');
fs.mkdirSync('./a');
// 不能非空文件夹(文件夹里面还含有文件)
 fs.rmdirSync('./a');
//删除文件夹
fs.rmdirSync('./a')

7.//监听文件
fs.watchFile('./data.txt', e => {
    // console.log('changed');

    //e : 类似事件对象，保存当前变化的细节
    console.log(e); 
});

// 监听文件或目录
fs.watch('./a', (eventType, filename) => {
    // eventType: change rename
    // filename: 当前发生改变的具体文件
    console.log(eventType, filename);
});
```

```js
//用递归封装一个删除文件夹
const fs = require('fs')
//获取删除文件夹下的文件，看是否存在，是否还存在子级文件
removeFile('./a');
function removeFile(pathname){
    let files = fs.readdirSync(pathname)
    //删除子文件及文件夹
    files.forEach(item=>{
        //该目录下也可能存在文件夹，要判断一下
        let childrenPath = pathname+'/'+item
        if(fs.statSync(childrenPath).isDirectory()){
            removeFile(childrenPath)
        }else{
            //删除每一个子文件
            fs.unlinkSync(childrenPath)
        }
    })
    //删除指定文件夹
    fs.rmdirSync(pathname)
}

8.fs.promises API 提供了一组备用的异步文件系统的方法，它们返回 Promise 对象而不是使用回调。
const fsPromises = require('fs').promises;

// v10.0.0+
fsPromises.mkdir('./b').then(() => {
    console.log('成功')
}).catch(err=>{});

```

**自动创建文件**

```js
const fs = require('fs');

//输入类似 node create app -i创建问价夹
//app文件名
//-i 该目录下创建index.html

//获取到输入的命令
const rootName = process.argv[2];

//拼接要创建文件的根目录
const rootPath = __dirname+'/'+rootName;

//判断文件是否存在
if(fs.existsSync(rootName)){
    console.log('该项目文件已经存在')
    process.exit()
}

//创建文件
fs.mkdirSync(rootPath)
fs.mkdirSync(rootPath+'/images')
fs.mkdirSync(rootPath+'/js')
fs.mkdirSync(rootPath+'/css')

```





##### 6.commander

命令行开发工具

```js
1.安装：npm install commander --save
2.const commander = require('commander')
3.commander.parse(process.argv) 解析执行传入的 argv 命令字符串，通常改命令字符串来自用户在命令行的输入	process.argv    commander 同时会默认创建一个 -h, --help 的选项
4.设置当前命令的版本
 commander.version('0.0.1').parse(process.argv);
5.设置其他option，--name 后面的 [val] 是当前这个选项的参数值
commander.option('-n, --name [val]', '设置名称', '');如果第三个参数是函数则用户命令行输入的值就是函数的返回值
6.设置命令动作
commander.action(() => {
    console.log('Hello ' + commander.foo);
});

eg:
const commander = require('commander');
const fs = require('fs');

commander.version('v1.0.0', '-v, --version');

commander.option('-n, --name [val]', '设置名称', '');

//这里和option一样<app-name>必填,[app-name]选填，在action中参数可以获取到就是这个值（用户输入命令的值），参数可以为多个
commander.command('create <app-name>')
.description('创建项目')
.alias('c')
.usage('使用说明')
.action( appName => {
    // console.log(appName);

    // fs.mkdirSync(appName);
});

commander.action(() => {
    console.log('Hello ' + commander.name);
});

// 解析来自process.argv上的数据，会自动帮助我们添加一个 -h 的解析
commander.parse( process.argv );

// console.log( commander.name );
```

##### 7.通过commander来获取某个文件夹下的列表集合

```js
/**
 * ls
 *  输出当前运行命令所在的目录下的文件和文件夹
 * ls -p d:\
 *  我们还可以指定要显示的目录
 */

// 加载commander模块
const commander = require('commander');
// 加载fs模块
const fs = require('fs');

// 设置当前命令工具的版本
commander.version('v1.0.0', '-v, --version');

// 设置命令选项   这里的[path]在action后会在commander里面生成同名的变量，用来获取用户输入的参数
//__dirname是默认值表示显示当前目录列表
commander.option('-p, --path [path]', '设置要显示的目录', __dirname);

// commander.path = undefined;

// 以列表的形式显示，如果选项不接收用户输入的值，那么这个选项将以boolean的形式提供给后面命令使用
commander.option('-l, --list', '以列表的形式显示');

// 实现命令的具体逻辑
commander.action( () => {

    // option中的变量会挂在到当前commander对象的同名属性下
    // console.log(commander.list);

    try {
        const files = fs.readdirSync( commander.path );
        //console.log( files );

        if ( commander.list ) {
            // 如果commander.list为true，以列表的形式显示

            // 通过map生成要显示的数据
            let output = files.map( file => {

                // 文件的扩展信息（除了文件内容以外的信息）
                let stat = fs.statSync( commander.path + '/' + file );
                // console.log(stat.isDirectory());
                // 根据isDirectory()显示不同的文件类型
                let type = stat.isDirectory() ? '目录' : '文件';

                return `[${type}] ${file}\r\n`;

            } ).join('');

            console.log(output);
        } else {
            console.log( files );
        } 

    } catch(e) {
        // 开发过程中，可以把错误打印出来，实际发布以后应该屏蔽错误信息
        console.log(e);
    }
} );

commander.parse( process.argv );
```

8.chalk

```js
对命令行进行美化
const chalk = require('chalk');
chalk.red('hello')

bold Colors 文字颜色：red、green、yellow、blue、cyan 
Background colors 背景颜色：bgRed、bgGreen、bgYellow、bgBlue、bgCyan	
Colors
		.hex('#DEADED') 
		.keyword('orange') 
		.rgb(15, 100, 204)
	Background colors
		.hex('#DEADED')
		.keyword('orange')
		.rgb(15, 100, 204)	

```

##### 9.Inquirer

```js
交互式命令
//交互式命令，提问用户，收集用户输入数据
	//安装
		npm i inquirer
	//使用
		require('inquirer')

		inquirer.prompt(questions).then(answers=>{
			...
		})
// 提问用户，与用户进行命令行的交互
        questions
		type：提问类型，input, confirm, list, rawlist, expand, checkbox, password, editor
		name：问题名称，供程序后续使用
		message：问题文字，给用户看的
		default：默认值
		choices：选项
		validate：输入验证
		filter：数据过滤
        //{}用对象包裹起来
// prompt数组中存放一个指定格式的对象，我们称为question对象
inquirer.prompt([

    {
        type: 'input',
        name: 'username',
        message: '请输入你的应用名称',
        default: 'app',
        // 对用户输入的数据或选择的数据进行验证
        validate(val) {
            if (val.trim() === '') {
                return '应用名称不能为空';
            }
            return true;
        },
        // 对用户输入的数据或选择的数据进行过滤
        filter(val) {
            return val.toLowerCase();
        }
    },

    {
        type: 'confirm',
        name: 'useES6',
        message: '是否启用ES6支持',
        default: true
    },
    {
        type: 'list',
        name: 'framework',
        message: '请选择框架：',
        choices: ['Vue', 'React', 'Angular'],
        default: 1
    },
    // {
    //     type: 'rawlist',
    //     name: 'framework2',
    //     message: '请选择框架：',
    //     choices: ['Vue', 'React', 'Angular'],
    //     default: 1
    // },
    {
        type: 'checkbox',
        name: 'tools',
        message: '开发工具',
        choices: [
            {
                name: '使用ESLint',
                value: 'eslint',
                checked: true
            },
            {
                name: '使用mocha单元测试',
                value: 'mocha'
            }
        ]
    }

]).then(answers=>{
    console.log(answers);
})
```

##### 10.Electron

使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用



#### 6.服务

##### 1.node服务器

```js
eg1:
var http = require('http');

http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});

    // 发送响应数据 "Hello World"
    response.end('Hello World\n');
}).listen(8888);

// 终端打印如下信息
console.log('Server running at http://127.0.0.1:8888/');

eg2:
// 引用系统模块
 const http = require('http');
  // 创建web服务器
 const app = http.createServer();
  // 当客户端发送请求的时候
 app.on('request', (req, res) => {
        //  响应
       res.end('<h1>hi, user</h1>');
 });
  // 监听3000端口
 app.listen(3000);
 console.log('服务器已启动，监听3000端口，请访问 localhost:3000')

```

##### 2.request对象

```js
app.on('request', (req, res) => {
     req.headers  // 获取请求报文
     req.url      // 获取请求地址
     req.method   // 获取请求方法
 });

//设置状态码
app.on('request', (req, res) => {
     // 设置响应报文
     res.writeHead(200, {         'Content-Type': 'text/html;charset=utf8‘
     });
 });


```

##### 3.处理get请求

```js
 const http = require('http');
 // 导入url系统模块 用于处理url地址
 const url = require('url');
 const app = http.createServer();
 app.on('request', (req, res) => {
     // 将url路径的各个部分解析出来并返回对象
         // true 代表将参数解析为对象格式
     let {query} = url.parse(req.url, true);
     console.log(query);
 });
 app.listen(3000);

'http://localhost:8000/index?username=123456'
query:username=123456
pathname:/index
path: '/index?username=123456'
```

##### 4.post请求

```js
 // 导入系统模块querystring 用于将HTTP参数转换为对象格式
 const querystring = require('querystring');
 app.on('request', (req, res) => {
     let postData = '';
     // 监听参数传输事件
     req.on('data', (chunk) => postData += chunk;);
     // 监听参数传输完毕事件
     req.on('end', () => { 
         console.log(querystring.parse(postData)); 
     }); 
 });

```

##### 5.路由

```js
var http = require('http');
const url = require('url');

http.createServer(function(req,res){
    const {pathname} = url.parse(req.url);
    switch (pathname) {
        case '/':
            res.writeHead(200,{
                'content-type':'text/html;charset=utf8;'
            })
            res.end('欢迎来到首页')
            break;
        case '/user':
            res.writeHead(200,{
                'content-type':'text/html;charset=utf8;'
            })
            res.end('用户页面')
        default:
            res.writeHead(404,{
                'content-type':'text/html;charset=utf8;'
            })
            res.end('访问的页面不存在！')
            break;
    }

}).listen(8000)
console.log('服务器创建成功');

```

根据fs来读取不同的html并返回到对应的页面

```js
var http = require('http');
const url = require('url');
const fs = require('fs');

const dirPath = __dirname+'/html/';

http.createServer(function(req,res){
    const {pathname} = url.parse(req.url);
    switch (pathname) {
        case '/':
           sendData(dirPath+'index.html',req,res);
            break;
        case '/user':
            sendData(dirPath+'user.html',req,res);
            break;
        default:
            sendData(dirPath+'404.html',req,res);
            break;
    }

}).listen(8000)
console.log('服务器创建成功');


function sendData(file,req,res){
    fs.readFile(file,function(err,data){
        if(err){
            res.writeHead(404,{
                'content-type':'text/html;charset=utf8;'
            })
            res.end(data)
        }else{
            res.writeHead(200,{
                'content-type':'text/html;charset=utf8;'
            })
            res.end(data)
        }
    })
}
```

##### 6.dgram (数据报)UDP

```js
*dgram模块提供了 UDP 数据包 socket 的实现

*socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，其本质上就是一套用于实现网络数据交换的接口（API）

//1.使用：
const dgram = require('dgram')

//2.创建一个特定 type 的dgram.Socket 对象
//方式一	
const server = new dgram.Socket()
//方式二
cosnt server = dgram.createSocket(type[, callback])
type: 'udp4' 或 'udp6'
//3.事件
close
		- error//出现错误
		- listening//监听有数据传递过来
		- message //传递过来的数据
server.on('listening',()=>{})

//4.绑定（监听）端口
		server.bind([port][, address][, callback])
			prot: 未指定则由系统分配
			address: 默认 0.0.0.0，表示所有地址/IP
			callback: 绑定成功后的回调
//5.关闭服务
	server.close()


```

eg：

```js
client.js

const dgram = require('dgram');

const clientSocket = dgram.createSocket('udp4');

/**
 * 发送数据
 *      UDP，无连接协议，不需要连接到服务器，然后再发数据
 */

clientSocket.send('hello', 12345, '127.0.0.1');


```

```js
server.js
/**
 * 服务端
 *      监听当前服务器上指定的ip与端口，如果有数据发送到给ip和端口上，我就进行处理
 */

const dgram = require('dgram');


/**
 * 创建一个 scoket 类，scoket 就是用来处理网络数据的一个标准 API 对象
 * 通过 scoket，我们就可以对网络数据进行读取和输出
 * 
 * dgram.Scoket 类
 */
// const socket = new dgram.Socket();

const serverSocket = dgram.createSocket('udp4');    //udp4 => ipv4

serverSocket.on('listening', () => {
    console.log('服务器开启成功，等待数据：');
});

// 当接收到数据的时候出发
serverSocket.on('message', data => {
    console.log('接收到了数据：', data.toString());
})

/**
 * 监听指定的地址以及端口
 */
serverSocket.bind(12345, '127.0.0.1');





```

##### 7.TCP(net模块)

```js
1.net 模块提供了创建基于流的 TCP 或 IPC 服务器(net.createServer())和客户端(net.createConnection()) 的异步网络 API
2.创建服务端对象
		const server = new net.Server()
		const server = net.createServer([port[, host]])
  监听端口，处理请求
		server.listen(端口, [ip])
  端口：
			ip：默认为0.0.0.0，表示所有
3.TCP：先连接，后传输
	net.Socket 类
	//创建客户端端对象
	const socket = new net.Socket()
	const socket = net.createConnection(port[, host][, connectListener])
    //方法
    	//发送数据
    write(data[, encoding][, callback])
			在 socket 上发送数据。第二个参数制定了字符串的编码 - 默认是 UTF8 编码
		end([data][, encoding])
			半关闭 socket。例如发送一个 FIN 包。服务端仍可以发送数据
			如果指定了 data，则相当于调用 socket.write(data, encoding) 之后再调用 socket.end()
	- connect  //在服务创建链接connect后 socket里可以获取数据，错误，结束
			- error
			- data
			- end

4.net.Server 类  
			- listening
			- error
			- connection
			函数的第一个参数是一个net.Socket实例对象，数据的传输就是通过socket对象来实现

5.socket.remoteAddress 链接端的地址
  socket.remotePort 链接端的端口号

  总结：
  TCP端：服务端先创建服务，在等待链接，设置端口地址，最后数据交互
  		客户端，创建链接，接受数据，最后交互数据（相互发送）

```

eg:



```js
===========>server.js
const net = require('net');
const fs = require('fs');

/**
 * 创建一个服务器端
 *      1. 监听地址以及端口
 *      2. 处理发送到当前监听地址以及端口的数据
 *      3. 返回（发送）数据到连接的客户端
 * 
 * net.Server 类
 *      new net.Server()
 *      net.createServer()  => return new net.Server()
 */

//Tcp先创建服务
const server = net.createServer(() => {

})

//后链接
// socket => 当前连接的 socket 对象
server.on('connection', socket => {
    //发送给链接对象
    socket.write('hello')
    //发送一个图片给链接对象
    // let data = fs.readFileSync('./server/1.jpg')
    // socket.write(data)

    console.log('有人连接了');

    //接受client端的发送
    socket.on('data', data => {
        socket.write('I give you pic');

        console.log(data.toString(), socket.remoteAddress, socket.remotePort);
    });
})


/**
 * 监听地址及端口
 */
server.listen(12345, '127.0.0.1')
```

```js
==========>client.js

const net = require('net')

const clientScoket = net.createConnection(12345,'127.0.0.1')

clientScoket.on('data',(data)=>{
    console.log('服务器返回'+data.toString())
    // console.log('服务器返回图片'+data)
    clientScoket.write('getPic')
    
})


// 当数据包接收完成的时候触发   当接受文件或图片过大时，传输过来的数据会分段传输，所以我们可以通过此方法来表示数据已经传输完毕了
clientScoket.on('end', () => {
    // console.log( '数据包接收完成' );
    
    // 把接收到的数据组合起来，然后通过fs写入到client文件夹中
    // 注意：我们接收到的数据是buffer
    // 保存写入buffer数据到文件
});
```

##### 8.Http

```js
1.HTTP是一个基于TCP/IP通信协议来传输（超文本）数据
2.http 模块
		require('http')
  http.Server 类
		const server = new http.server()
		const server = http.createServer([options][, requestListener])
		该类继承自 net.server，http基于tcp
  监听
		server.listen([port][, host])
3.Request - 请求
	http.ClientRequest 类
		const client = new http.ClientRequest()
		const client = http.request(options[, callback])  //可以发送请求
	http.clientRequest - options  //options发送请求的参数
		protocol : 使用的协议。默认为 http:
		host : 请求发送至的服务器的域名或 IP 地址。默认为 localhost
		family : 当解析 host 和 hostname 时使用的 IP 地址族时有效，值是 4 或 6，未指定时，则同时使用 				  IP v4 和 v6
		port : 远程服务器的端口。默认为 80
		method : 指定 HTTP 请求方法的字符串。默认为 'GET'
		path : 请求的路径。默认为 '/'。 应包括查询字符串（如有的话）。如 '/index.html?page=12'
		headers : 包含请求头的对象
4.Request 消息分为三个部分：
		- Request Line：请求行
		- Request header：请求头
		- Request body：请求正文
	每个部分又包含不同的内容：
    Request Line - 请求行：
		- Method：表示请求方式，比如“get”、“post”，“put”……，不同的请求方式所得到的结果也有不一样
		- Path-to-resoure：请求资源，也就是 URL，URL的作用是用来定位我们想要获取的内容在网络的位置，它也						   有一套规则
		- Http/version-number：表示当前所使用的HTTP协议的版本，主流为1.1，最新为2.0 
	Request Header - 请求头：
		 Accept
			告诉服务端，客户端接收什么类型的数据
			Accept: text/html,image/apng,*/*
		Cache-Control
			对返回的内容进行缓存控制，是否缓存，缓存多久
			Cache-Control: no-cache
	
5.esponse 消息分为三个部分：
		- Response Line：响应行
		- Response header：响应头
		- Response body：响应正文
    Response Line - 响应行：
                -  HTTP/version-number：表示HTTP协议的版本号
                - status-code：状态码
                - message：状态码对应的描述
     
    Response Line - 响应头：
            同请求头，服务端在返回一些主要数据之外，还会返回一些额外的数据，这些数据都包装的响应头部分，客户端会根据接收到的响应头以及头信息中对应的字段来做出不同的解析行为
6.消息头
根据不同上下文，可将消息头分为：
			一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。
			请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。
			响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。
			实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。

		Content-Type<实体首部>：发送内容类型
		Content-Length<实体首部>：发送内容长度
		Location<响应首部>：重定向地址
		Cookie<请求首部>：包含要发送给服务器的Cookie
		Set-Cookie<响应首部>：服务器端向客户端发送 cookie
7.状态码分类：
		https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status
		HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别
		1XX  提示信息 - 表示请求已被成功接收，继续处理
		2XX  成功 - 表示请求已被成功接收，理解，接受
		3XX  重定向 - 要完成请求必须进行更进一步的处理
		4XX  客户端错误 -  请求有语法错误或请求无法实现
		5XX  服务器端错误 -   服务器未能实现合法的请求


```



```
// 请求的发送需要调用下面的方法
client.write('');
client.end();
```

eg:

server.js

```js
const http = require('http')

const server = http.createServer();
server.on('request',(res)=>{
    console.log('收到发送请求了');
})
server.listen(80,'0.0.0.0')
```

client.js

```js
const http = require('http');
const fs = require('fs');

/**
 * http.ClientRequest 类
 *  new http.ClientRequest()
 *  http.request()
 */

// 创建一个客户端（能发http请求）的对象
// 请求行:    get http://127.0.0.1:80/ http/1.1
const client = http.request({
    // tcp
    host: 'www.baidu.com',
    port: 80,

    // http
    protocol: 'http:',
    method: 'get',

    path: '/img/bd_logo1.png'
}, res => {
    // 这个函数会在服务器响应的时候出发

    // let content = '';

    let content = Buffer.alloc(0);

    // res => socket
    res.on('data', data => {
        // console.log(data.toString());
        // content += data.toString();
        //这里传进来的是图片我们就不能转化toString()，需要用buffer来进行转译
        content = Buffer.concat([content, data], content.length + data.length);

    });

    res.on('end', () => {
        fs.writeFileSync('./baidu.png', content);
    });
});

// 请求的发送需要调用下面的方法
client.write('');
client.end();
```

请求静态资源的方法

```js
const http = require('http');
const fs = require('fs');

//封装的一个MIME用于获取类型
const Mime = require('./libs/Mime');

// console.log(Mime.getType('txt'));    //   'text/plain'
// console.log(Mime.getType('html'));    //   'text/html'
// console.log(Mime.getExtension('text/html')); // ['html', 'htm']

const app = http.createServer( (req, res) => {
    
    res.writeHead(200, http.STATUS_CODES[200], {
        'Content-Type': 'text/html;charset=utf-8'
    });

    /**
     * 我们直接让用户访问/static/index.html,/static/list.html
     * 用户在url后面带的路径，我们直接就把他关联到服务器本地的目录文件中
     */
    let content = '';

    // staticSend(__dirname + '/static/index.html');
    staticSend(__dirname + req.url);

    //处理静态资源的路径，传入的有文本返回类型，状态码
    function staticSend(filename, headers={'Content-Type': 'text/html;charset=utf-8'}, statusCode=200) {

        if (fs.existsSync(filename)) {

            let ext = filename.substring( filename.lastIndexOf('.') + 1 );

            if (!ext) {
                ext = 'txt';
            }

            // 根据扩展名输出对应的MIME 更改掉默认的返回类型
            headers['Content-Type'] = Mime.getType(ext);
            //设置返回文本的响应头
            res.writeHead(statusCode, http.STATUS_CODES[statusCode], headers);
            content = fs.readFileSync(filename);
            res.end(content);
        } else {
            staticSend(__dirname + '/static/404.html', {
                'Content-Type': 'text/html;charset=utf-8'
            }, 404);
        }

        
    }

} );


app.listen(80, () => {
    console.log('服务器启动成功了');
});


//localhost:80/static/index.html
```

MIME.js

```js
const _mime = {
    'text/plain': ['txt'],
    'text/html': ['htm', 'html'],
    'text/css': ['css'],
    'text/javascript': ['js', 'jsx'],
    'image/png': ['png'],
    'image/jpeg': ['jpg']
};

module.exports = {
    getType(ext) {  //html
        for (let property in _mime) {
            let arr = _mime[property];
            if (arr.includes(ext)) {
                return property;
            }
        }
    },
    getExtension(type) {
        return _mime[type];
    }
};
```

#### 7.koa

##### 1.基本服务

```js
1.安装
		npm i koa
  载入
		const koa = require('koa')
		const app = new koa()
		app.listen(80)
  响应输出
		app.use(async ctx => {ctx.body = 'Hello'})
  热重载supervisor
 　npm install -g supervisor
  可以自动重启server
  启动：supervisor node app.js
2.中间件
  use(callback)
		- callback(context, next)
		- context 对象
			每一次请求都会包装一个context对象
		- next
			每一个中间件都是一个迭代器
		- 异步中间件
			.use(async callback)
3.错误处理
app.on('error',err=>{})
4.context对象
		- .req：Node 的 request 对象
		- .res：Node 的 response 对象
		注意：在 Koa 中尽量使用Koa提供的封装对象
		- .request：Koa 的 request 对象
		- .response：Koa 的 response 对象
		- .state：用户数据存储空间
		- .app：当前应用程序实例 - Application 对象
  //     context.throw会抛出一个错误，koa会进行处理，	
  //      app.on('error')可以捕获到该异常，error 参数中也会保存msg和properties
5.cookie对象
  cookies 对象
			- .get(name, [options])
			- .set(name, value, [options])
			- options
				- .maxAge	- .signed
				- .expires	- .path
				- .domain	- .secure
				- .httpOnly	- .overwrite

eg:
const koa =require('koa');

const app = new  koa();

app.use((ctx,next)=>{
    ctx.body = '<strong>hello'
    //state：用户数据存储空间
    let a=100;
    ctx.state.a=a;
     // 判断当前用户是否有权限，如果有权限，再调用next(),相当于一个拦截作用
    next();
})
app.use((ctx,next)=>{
    // console.log(ctx.state.a); ctx是可以传递值的
    // ctx.body='koa</strong>'
    ctx.throw(404,'页面没了')
    
})
//可以获取到，context抛出的异常
app.on('error',err=>{
    console.log('错了',err);
})
app.listen(3000,()=>{
    console.log('服务器启动成功');
})

```

##### 2.request对象的相关参数

```js
- .header：头信息对象，别名：headers
		- .header=：设置头信息，别名：headrs=
		- .method：请求方法
		- .method=：设置请求方法
		- .length：请求正文内容长度
		- .url：请求URL
		- .url=：设置请求URL，不包含协议与主机部分
		- .orginalURL：原始URL，不包含协议与主机部
		- .href：原始完整URL，包含协议、主机、请求串
		- .path：URL路径部分
		- .path=：设置URL路径
		- .querystring：URL中的querystring
		- .querystring=：设置URL中的querystring
		- .search：URL中的search，带 ? 的querystring
		- .search=：设置URL中的search
		- .host：请求头中的host
		- .hostname：请求头中的hostname
		- .URL：解析过的URL对象
		- .type：请求头中 content-type
		- .charset：请求头中的charset
		- .query：解析过的querystring对象
		- .query=：设置querystring对象值
		- .fresh：判断缓存设置时候有效，true表示有效
		- .stale：与fresh相反
		- protocol：请求使用的协议
		- .secure：是否是安全协议，protocol=='https'
		- .ip：请求客户端 IP
		- .ips：请求客户端所有 IP（比如使用了代理等）
		- .subdomains：子域名数组
		- .is(types...)：判断提交内容的MIME类型
- .socket：request.socket对象
		- .get(field)：获取请求头的通用方法



```

##### 3.response对象相关参数

```js
- .header：响应头对象
		- .headers：header的别名
		- .socket：response.socket对象
		- .status：响应状态码
		- .status=：设置响应状态码
		- .message：响应状态码描述文本
		- .message=：设置响应状态码描述文本
		- .body：响应内容
		- .body=：设置响应内容，如果status没有设置，Koa会默认设置status为：200 或者 204，同时 Koa 会根			据返回的数据类型自动设置 content-type
			- string：text/html 或 text/plain
			- buffer/Stream：application/octet-stream
			- object：application/json
		- .length：响应内容长度
		- .length=：设置响应内容长度
		- .get(field)：获取指定头信息
		- .get(fields)：批量设置头信息
		- .set(field)：设置指定头信息
		- .append(field, value)：追加头信息
		- .remove(field)：移除头信息
		- .type：获取 content-type
		- .type=：设置 content-type
		- .is(types...)：判断 content-type
		- .redirect(url)：重定向，默认重定向状态码为：302，可以通过status进行设置
		- .attachment([filename])：设置下载文件头，filename为下载文件的名称


```

##### 4.中间件

```js
		- koa-static-cache：静态文件代理服务
		- koa-router：路由
		- koa-swig：模板引擎
		- koa-bodyparser：body解析
		- koa-multer：formData解析

```

##### 5.静态资源服务koa-static-cache

```js
1. koa-static-cache：静态文件代理服务
   const koaStaticCache = require('koa-static-cache')
	staticCache(dir [, options] [, files])
			- dir：服务器上存放静态资源的目录
			- options：选项设置
			- files：合并的文件对象
	-选项设置：
        - prefix：URL前缀，默认是 '.'
		- maxAge：缓存时间，单位毫秒，默认为0
		- gzip：启用gzip压缩传输，默认为true

eg:
const koa =require('koa');

const koaStaticCache = require('koa-static-cache');
const app = new koa();

//这里必须要使用
app.use( koaStaticCache( __dirname + '/static', {
    // root: __dirname + '/static', //与上面的第一个参数效果一样
    prefix: '/public',  //如果当前请求的url是以 /public 开始，则作为静态资源请求 浏览器输入/public相当于去查找static目录下的文件
} ) );

app.use((ctx,next)=>{

})
app.listen(3000,()=>{
    console.log('服务启动成功');
})
```

##### 6.路由Router

```
1.koa-router：路由
		- 给应用注册指定的路由中间件
			- .use([path], middleware)
			- app.use(router.routes())
		- 命名路由
			- router.get('main', '/', cb);
		- 复合中间件
			- router.get('/', cb1, cb2, cb3...)
				- 注意调用中间件的next函数
2. - 嵌套路由
			const parent = new Router()
			const child = new Router()
			parent.use('/p', child.routes())
	- 路由前缀
			const router = new Router({
				prefix: '/user'
			})
	- 动态路由
			router.get('/user/:id', cb);
			动态路由参数通过 ctx.params 对象获取
	- 路由重定向
			router.redirect('/user', '/login', 301)
	- URL生成器
			Router.url('/list', {page:1}, {query{order:'desc'}}) 生成：/list/1?order=desc

```

```js
const Koa = require('koa');
const koaStaticCache = require('koa-static-cache');
const app = new Koa();
const Router = require('koa-router');

app.use( koaStaticCache( __dirname + '/static', {
    prefix: '/public',
} ) );



const router = new Router();

// 通过 get 方式 发送 / 请求 => get http://127.0.0.1/
router.get('/', (ctx, next) => {
    ctx.body = '首页';
});



//子路由
const itemRouter = new Router();
itemRouter.get('/add',(ctx,next)=>{
    ctx.body='添加物品'
})
itemRouter.get('/delete',(ctx,next)=>{
    ctx.body='删除物品'
})
//在一个路由中添加子路由
router.use('/item',itemRouter.routes())

//动态路由匹配
const goosRouter = new Router()
goosRouter.get('/goods/:id',(ctx,next)=>{
    ctx.body = ctx.params.id
})



//将路由挂载到服务上
app.use(router.routes())
app.use(itemRouter.routes())
app.use(goosRouter.routes())
app.listen(3001,()=>{
    console.log('服务启动成功');
})
```

##### 7.koa-swig：模板引擎

使用mysql库

```js
1.安装使用
		npm i koa-swig
		const Swig = require('koa-swig')
		const render = Swig(options)
2.加载 co 模块
		koa v2.x 需要使用 co 函数
		npm i co
		const co = require('co')
3.把渲染方法挂载到 Context 下
		app.context.render = co.wrap( render(opts) )		
		opts:
			- root: 模板存放目录
			- autoescape：是否自动 escape 编码
			- cache：是否启用缓存
			- ext：模板后缀，'html'
	render & data
		ctx.body = await ctx.render(模板文件, 数据)
```

使用mysql2库(async await)

```js
const koa =require('koa')
const app =new koa();
const Router = require('koa-router')
const koaSwig =require('koa-swig')
const co = require('co')

const router = new Router()
//配置模板目录
const render = koaSwig({
    root:__dirname+'/views',
    autoescape:true,
    cache:false,
    ext:'.html'
})
//依赖co函数,配置模板相关选型并挂载在ctx上
app.context.render = co.wrap(render)
router.get('/getindex',async(ctx,next)=>{
    //render(模板名称，传递的参数)函数依赖co函数
    ctx.body =await ctx.render('index.html',{
        username:'张三'
    })
})

app.use(router.routes())

app.listen(3001,()=>{
    console.log('服务启动成功');
})


=========>index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    我是模板一  ====》{{username}}
</body>
</html>
```

##### 8.模板引擎的语法格式

```js
1.输出：{{表达式}}
		判断
			{% if 条件 %}{% endif %}
			{% if 条件 %}{%elseif 条件%}{% endif %}
			{% if 条件 %} {%else%}{% endif %}
2.循环
			{% for x in y %}{% endfor %}
			{%for key, val in data%}
			内置变量
				loop.index：从1计算
				loop.index0：从0计算
				loop.length：长度
3.继承
			{% extends "base.html" %}
			{% block name %}{% endblock %}
				类似类的方法，子模板可以重写
4.包含导入
			{% include 'widget.html' %}
		变量设置与传参
			{% set name = 'zMouse' %}
			{% include 'widget.html' with name %}
			在使用 include 的模板中可以使用 name
```

##### 9.todoList

```js
const koa =require('koa')
const Router = require('koa-router')
const co = require('co')
const Swig = require('koa-swig')
const koaStaticCahce = require('koa-static-cache')
const bodyParser =require('koa-bodyparser')

const router = Router();
const app = new koa();

//处理静态资源文件
app.use(koaStaticCahce('./static/',{
    prefix:'/static',
    gzip:true
}))

/**
 * 存储所有的任务数据
 *  当前这个数据是存储在服务器运行中的内存中
 */
let datas = {
    maxId: 3,
    appName: 'TodoList',
    skin: 'index.css',
    tasks: [
        {id: 1, title: '测试任务一', done: true},
        {id: 2, title: '学习koa', done: false},
        {id: 3, title: '学习sequelize', done: false}
    ]
};

//模板处理  Swing依赖co
app.context.render = co.wrap(Swig({
    root:__dirname+'/views',
    autoescape: true,   //是否html编码，为了安全起见，一般不开启该功能，设置为true
    cache: false,
    // cache: 'memory', //memory : 把解析后的结果保存在内存中，比如每次访问都去解析模板，一般用于线上生成环境
    ext: 'html'
}))

/**
 * 处理请求正文中的数据
 */
app.use( bodyParser({

}) );

//首页
router.get('/',async ctx=>{
    ctx.body =await ctx.render('index.html',{
        datas
    })
})
//跳转到添加
router.get('/add',async ctx=>{
    ctx.body=await ctx.render('add.html')
})
//添加数据
router.post('/posttask',async ctx=>{
    //获取到当前数据
    const {title} = ctx.request.body||''
    if(!title){
        ctx.body =await ctx.render('message.html',{
            msg:'请输入任务标题',
            href: 'javascript:history.back();'
        })
        return
    }
    datas.tasks.push({
        id:datas.maxId++,
        title:title,
        done:false
    })
    //添加成功返回首页
    ctx.body =await ctx.render('message.html',{
        msg:'添加成功',
        href:'/'
    })

})
//删除
router.get('/remove/:id',async ctx=>{
    let id = ctx.params.id
    console.log('');
    datas.tasks =  datas.tasks.filter(item=>item.id!=id)
    ctx.body = await ctx.render('message', {
        msg: '删除成功',
        href: '/'
    });
})
//修改
router.get('/update/:id',ctx=>{
    ctx.body='修改'
})



app.use(router.routes())
app.listen(8000,()=>{
    console.log('服务器启动成功');
})
```

##### 10.koa脚手架

```
1.npm install -g koa-generator 
2.koa +项目名
```



#### 8.mysql

```js
const mysql = require('mysql')

const connection = mysql.createConnection({
    host:'localhost',
    user:'root',
    password:'123456',
    port:'3306',
    database:'xinlangblog'
})

connection.connect();
const sql = 'select * from blogs';

connection.query(sql,function(err,res){
    if(err){
        console.log('查询不到相关数据');
        return;
    }else{
        console.log(res);
    }
})
connection.end();
```

```js
(async function() {

    const mysql = require('mysql2/promise');

    const connection = await mysql.createConnection({
        host: '127.0.0.1',
        user: 'root',
        password: '',
        database: 'miaov'
    });

    /**
     * arr返回一个数组，第一个数组是记录的值，第二个数组是记录中包含的字段的信息
     */
    // let arr = await connection.query("SELECT username,age,gender FROM users");
    // console.log(arr);

    /**
     * 解构赋值
     */
    let [users] = await connection.query("SELECT username,age,gender FROM users");
    console.log(users);

    users.forEach(user => {
        console.log(user.username);
    });

})();
```

案例

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"></script>
    <style>
        li {
            line-height: 40px;
        }
        .done span {
            text-decoration: line-through;
            color: #cccccc;
        }
        .pages {
            margin: 10px;
        }
        .pages a {
            margin: 15px;
        }
        .pages a.active {
            color: red;
        }
        .footer {
            margin: 10px;
        }
        .footer button.active {
            background: yellow;
        }
    </style>
</head>

<body>
    <div id="app">
        <h1>App</h1>
        <div>
            <input type="text" v-model="newValue" />
            <button @click="add">添加新任务</button>
        </div>
        <hr />
        <ul>
            <li v-for="todo of todos" :key="todo.id" :class="{done: todo.done}">
                <input type="checkbox" :checked="todo.done" @click.prevent="toggle(todo.id, !todo.done)" />
                <span>#{{todo.id}} - {{todo.title}}</span>
                <button @click="remove(todo.id)">删除</button>
            </li>
        </ul>
        <div class="pages">
            <a href="" :class="{active: n == page}" @click.prevent="changePage(n)" v-for="n of pages">{{n}}</a>
        </div>
        <div class="footer">
            <button :class="{active: type===''}" @click="changeType('')">所有</button>
            <button :class="{active: type===1}" @click="changeType(1)">已完成</button>
            <button :class="{active: type===0}" @click="changeType(0)">未完成</button>
        </div>
    </div>


    <script>
    
        new Vue({
            el: '#app',
            data: {
                newValue: '',
                page: 1,
                prepage: 4,
                pages: 0,
                type: '',
                todos: []
            },
            created() {
                // console.log(1)
                this.getData();
            },
            // computed: {
            //     async todos() {
            //         return await getData(this.page);
            //     }
            // },
            methods: {
                getData() {
                    fetch('/todos?type='+ this.type +'&page=' + this.page + '&prepage=' + this.prepage).then(res => {
                        return res.json();
                    }).then( data => {
                        this.todos = data.data.todos;
                        this.pages = data.data.pages;
                        // console.log(1)
                    } );
                },
                changePage(n) {
                    this.page = n;
                    this.getData();
                },
                changeType(m) {
                    this.type = m;
                    this.getData();
                },
                add() {
                    fetch('/add', {
                        method: 'post',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify( {title: this.newValue} )
                    }).then(res => {
                        return res.json();
                    }).then( data => {
                        // this.todos = data.data;
                        // console.log(1)
                        if (!data.code) {
                            this.getData();
                        }
                    } )

                    this.newValue = '';
                },
                toggle(id, todo) {
                    fetch('/toggle', {
                        method: 'post',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify( {id, todo: Number(todo)} )
                    }).then(res => {
                        return res.json();
                    }).then(data => {
                        if (!data.code) {
                            this.getData();
                        }
                    });
                },
                remove(id) {
                    fetch('/remove', {
                            method: 'post',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify( {id} )
                        }).then(res => {
                            return res.json();
                        }).then(data => {
                            if (!data.code) {
                                this.getData();
                            }
                        });
                }
            }
        })
    
    </script>
</body>
</html>
```

node

```js
(async function run() {

    const Koa = require('koa');
    const Static = require('koa-static-cache');
    const Router = require('koa-router');
    const Bodyparser = require('koa-bodyparser');
    const fs = require('fs');
    const mysql = require('mysql2/promise');

    const app = new Koa();

    app.use( Static('./static', {
        prefix: '/static',
        gzip: true
    }) );

    const connection = await mysql.createConnection({
        host: '127.0.0.1',
        user: 'root',
        password: '',
        database: 'miaov'
    });

    const router = new Router();

    // 如果觉得 /static/index.html 太丑，可以使用下面的方法
    
    app.use( Bodyparser() );

    router.get('/', ctx => {
        const content = fs.readFileSync('./static/index.html');
        ctx.body = content.toString();
    });

    router.get('/todos', async ctx => {
        // ctx.body = [
        //     {id: 1, title: '学习node', done: true},
        //     {id: 2, title: '学习koa', done: true},
        //     {id: 3, title: '学习mysql', done: false}
        // ];

        /**
         * 排序
         * ORDER BY
         */

        // const [data] = await connection.query("SELECT id,title,done FROM todos ORDER BY done DESC, id DESC");

        /**
         * 查询数量限制
         * LIMIT - top 10
         * 查询偏移
         * OFFSET
         * 
         * 分页:
         *  把一定的数据按照每页固定的条数去显示，我们需要首先定义每页显示多少
         * 
         * 每页显示3条
         *  1 : 0 - 2
         *  2 : 3 - 5
         *  3 : 6 - 8
         * 每页显示 -> LIMIT
         * 当前的页码 -> OFFSET
         * 
         * 如果页码从1开始算，那么对应的记录应该    LIMIT 3 OFFSET (页码-1 * 3)
         * 
         * 总页码
         */
        let page = ctx.query.page || 1; //这个page其实应该由前端来决定是多少
        page = Number(page);
        let prepage = ctx.query.prepage || 4;
        prepage = Number(prepage);
        let type = ctx.query.type;
        let where = '';

        if (type) {
            where = 'WHERE done=' + type;
        }

        // 查询总的记录条数
        const sql = `SELECT id,title,done FROM todos ${where}`;
        const [todosAll] = await connection.query(sql);
        // 总的数据量 / 每页显示条数，注意：小数
        const pages = Math.ceil(todosAll.length / prepage);

        // const sql2 = `SELECT id,title,done FROM todos LIMIT ${prepage} OFFSET ${(page-1)*prepage}`;

        // const sql2 = `SELECT id,title,done FROM todos ${where}  LIMIT ${prepage} OFFSET ${(page-1)*prepage}`;

        // console.log(sql2)

        // where ??=?  :  ?? 表示字段或表名，? 表示值
        const sql2 = `SELECT id,title,done FROM todos ${where} LIMIT ? OFFSET ?`;

        const [todos] = await connection.query(sql2, [prepage, (page-1)*prepage]);

        ctx.body = {
            code: 0,
            data: {
                page,
                prepage,
                pages,
                todos
            }
        }
    });

    router.post('/add', async ctx => {
        const  title = ctx.request.body.title || '';

        if (title == '') {
            ctx.body = {
                code: 1,
                data: 'title不能为空'
            }
            return;
        }

        // console.log("INSERT INTO todos (title, done) VALUES ('"+ title +"', 0)")

        const [rs] = await connection.query("INSERT INTO todos (title, done) VALUES ('"+ title +"', 0)");

        if (rs.affectedRows > 0) {
            ctx.body = {
                code: 0,
                data: '添加成功'
            }
        } else {
            ctx.body = {
                code: 2,
                data: '添加失败'
            }
        }
    });


    router.post('/toggle', async ctx => {

        let id = Number(ctx.request.body.id) || 0;
        let todo = Number(ctx.request.body.todo) || 0;

        let sql = "UPDATE todos SET ??=? WHERE ??=?";
        
        let [rs] = await connection.query(sql, ['done', todo, 'id', id]);

        if (rs.affectedRows > 0) {
            ctx.body = {
                code: 0,
                data: '修改成功'
            }
        } else {
            ctx.body = {
                code: 2,
                data: '修改失败'
            }
        }
    });

    router.post('/remove', async ctx => {
        let id = Number(ctx.request.body.id) || 0;

        let sql = "DELETE FROM todos WHERE ??=?";
        
        let [rs] = await connection.query(sql, ['id', id]);

        if (rs.affectedRows > 0) {
            ctx.body = {
                code: 0,
                data: '删除成功'
            }
        } else {
            ctx.body = {
                code: 2,
                data: '删除失败'
            }
        }
    });


    app.use( router.routes() );


    app.listen(80);

})();
```

#### 9.跨域

跨域指当前服务器去访问一个不同服务器，协议，域名，端口都不一致

方式一

```js
服务端设置允许访问：
// 第一个参数 “*” 星号，是通配符，代表任意请求地址
app.all('*', (req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*') // 声明任意地址都能访问
    res.header('Access-Control-Allow-Headers', 'Content-Type')
    res.header('Access-Control-Allow-Methods', '*')
    next()
})
```

方式二

```js
通过代理方式访问
//通过请求本服务中的路由接口，在服务结构中通过转发代理到另一个服务器，这样是可以实现跨域的
// 创建一个用于访问server2的接口
app.get('/accessServer2', (req, res) => {

    // 访问不支持跨域的服务器时，可以代理转发
    axios.post('http://127.0.0.1:2048/test', {headers: {origin: 'http://127.0.0.1:1024'}}).then(result => {
        console.log(result.data)
        res.json({msg: '访问成功！'})
    }).catch(reason => {
        console.error(reason)
        res.json({msg: '访问失败！'})
    })
})
```

方式三

```js
cors跨域：

let cors = require('cors');
 
let corslet = cors({
    // 应许改域访问
    origin: ['http://localhost:8080'],
    // 允许状态为200
    optionsSuccessStatus: 200,
    // 只应许GET\POST请求
    methods: ['GET', 'POST'],
    // 只应许带content-type请求头访问
    allowedHeaders: ['Content-Type']
});
 
module.exports = corslet;
```

方式四

```
jsonP:通过script标签不受同源限制，通过回调函数的方式来接受到跨域服务端传递回来的数据
iframe
```

#### 10.利用husboy上传文件

upload.js

```js
const koa = require('koa')
const path = require('path')
const {uploadFile} = require('./11.upload')
const app = new koa()
app.use(async (ctx) => {
    if (ctx.url === '/' && ctx.method === 'GET') {
        // 当GET请求时候返回表单页面
        let html = `
    <h1>koa2 upload demo</h1>
    <form method="POST" action="/upload.json" enctype="multipart/form-data">
      <p>file upload</p>
      <span>picName:</span><input name="picName" type="text" /><br/>
      <input name="file" type="file" /><br/><br/>
      <button type="submit">submit</button>
    </form>
  `
        ctx.body = html
    }else if(ctx.url==='/upload.json'&&ctx.method==='POST'){
        let result ={success:false}
        // 保存文件的文件夹路径
        let createServePath = path.join(__dirname,'upload_files')
        //调用上传的方法
        result = await uploadFile(ctx,{
            fileType:'album',  //默认是common,指定到upload_files那个文件夹下
            path:createServePath //指定文件夹路径
        })
        ctx.body =result
    }else{
        ctx.body = '404....找不到'
    }
})
app.listen(3000, () => {
    console.log('3000端口已经监听了...')
})
```

**uploadFile.js**

```js
1.busboy可以将文件解析出来
2.fs.createWriteStream（）创建可写流


const koa = require('koa')
const fs = require('fs')
const os = require('os')
const path = require('path')
const Busboy =require('busboy')
const inspect = require('util').inspect //将任意对象转换成字符串
const app = new koa()

/**
*创建存放上传文件的文件夹
*@filename {String} 目录的绝对地址
return {Boolean}创建文件夹的结果
*/
function mkdirsSync(dirname) {
    //判断当前文件是否存在
    if (fs.existsSync(dirname)) {
        return true
    } else {
        if (mkdirsSync(path.dirname(dirname))) {  //判断上一级是否存在
            //存在就创建文件夹
            fs.mkdirSync(dirname)
        }
    }
}
/**
 * 获取上传文件的类型
 * @params filename {String} 上传图片的的名字
 * 返回图片的后缀名
 */

function getFileNameType(filename) {
    let nameList = filename.split('.')
    return nameList[nameList.length - 1]
}
/**
 *
 *
 */
function uploadFile(ctx, options) {
    let req = ctx.req //这是原生的req
    let res = ctx.res
    //创建文件解析的服务
    let busboy = new Busboy({ headers: req.headers })


    let dirPath = options.path
    let fileType = options.fileType
    //指定到某文件夹下的路径
    let createFilePath = path.join(dirPath, fileType)
    let mkdirResult = mkdirsSync(createFilePath)

    return new Promise((resolve, reject) => {
        let result = {
            success: false,
            formData: {

            }
        }
        //利用busboy解析出上传文件的相关东西
        busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
            //上传文件保存的名字
            let fileName = Math.random().toString(16).substr(2) + '.' + getFileNameType(filename)
            //上传文件的地址
            let saveTo = path.join(createFilePath, fileName)
            //创建可写流
            let upStream = fs.createWriteStream(saveTo)
            //建立通道降文件写入可写流
            file.pipe(upStream)
            //文件写入完成
            file.on('end', function () {
                result.success = true,
                    result.message = '上传文件成功'
                resolve(result)
            })
        })
        //解析表单中的其他字段信息
        busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetyp){
            console.log('表单字段数据 [' + fieldname + ']: value: ' + inspect(val));
            result.formData[fieldname] = inspect(val);
        })

        // 解析结束事件
        busboy.on('finish', function () {
            console.log('文件上结束')
            resolve(result)
        })

        // 解析错误事件
        busboy.on('error', function (err) {
            console.log('文件上出错')
            reject(result)
        })
        //将请求与busboy建立链接，解析请求上传文件
        req.pipe(busboy)
    })

}

module.exports =  {
    uploadFile
  }
```

### node常用的方法

##### 1.path

```
path.extname(文件名)  //获取后缀
path.basename(file,'.js') //标识要过滤的字符
file ==> /path/file.js  =>file

path.resolve()路径或路径片段的序列解析为绝对路径，给定的路径序列从右到左处理，每个后续的 path 会被追加到前面，直到构建绝对路径
path.resolve('/foo/bar', './baz');
// 返回: '/foo/bar/baz'

path.resolve('/foo/bar', '/tmp/file/');
// 返回: '/tmp/file'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');
// 如果当前工作目录是 /home/myself/node，
// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif'

path.join() 
```

##### 2.fs

```
fs.statSync(文件路径) //返回文件的基本信息
fs.statSync(文件路径)).isDirectory() //判断是否是文件夹
```

##### 3.util

###### 3.1util.promisify

```js
  util 模块有一个 promisify() 方法，该方法将基于回调的函数转换为基于 Promise 的函数。这使您可以将 Promise 链和 async/await 与基于回调的 API 结合使用
  
  const fs = require('fs')
const util = require('util')

// 将 fs.readFile() 转换为一个接受相同参数但返回 Promise 的函数。
const readFile = util.promisify(fs.readFile)

// 现在可以将 readFile() 与 await 一起使用！
const buf = await readFile('./package.json')

const obj = JSON.parse(buf.toString('utf8'))
console.log(obj.name) // 'Example'
```



## mongodb

###### 1.相关命令行

```
1.在bin目录下执行mongo进入mongo里面
2.show dbs 查看数据库
3.use 数据库名 如果有就切换，没有就新建
4.db.createCollection('users')创建一张表（集合）
5. db.users.insertOne({userId:2,userName:'zs',age:30,score:100}) 插入一条数据
6.db.users.find() 查询所有数据 {age:{$gt:35}}可以筛选年龄大于35的
7. db.users.deleteOne({ "_id" : ObjectId("6141667c352e1a163484bc2e")}) 删除一条
8.db.users.update({age:{$gte:35}},{$set:{score:200}}) 更新年龄大于等于35的，分数设置为200
```



# ======vue

### 1.vue2.0

##### 1.vue的渲染机制

步骤：

1.将组件模板通过vue-loader编译成render函数

2.将实例进行挂载，根据根节点render函数的调用，递归的生成虚拟Dom

3.对比虚拟Dom渲染成真是的Dom结构

4.组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom,返回到步骤三（data的改变会重复渲染）



![image-20201115110938009](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201115110938009.png)

##### 2.v-for比v-if

```
v-for比v-if的优先级更高，不推荐一起使用
```

##### 3.自定义指令

​	全局指令

```js
<input type="text" v-color='msg'>
<script type="text/javascript">
    /*自定义指令-带参数 bind - 只调用一次，在指令第一次绑定到元素上时候调用 */
    //这里一般设置一个用Vue.directive(指令名，指令对象)
    Vue.directive(
        'color', {
            // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 
            // el 为当前自定义指令的DOM元素 // binding 为自定义的函数形参 通过自定义属性传递过来的值 存在 binding.value 里面 
            bind: function (el, binding) { 
                // 根据指令的参数设置背景色 
                console.log(binding.value.color)
                el.style.backgroundColor = binding.value.color;
            }
        });
    var vm = new Vue({
        el: '#app',
        data: {
            msg: {
                color: 'blue'
            }
        }
    });
</script>
```

局部指令

```js
<input type="text" v-color='msg'> <input type="text" v-focus>
<script type="text/javascript">
    /*自定义指令-局部指令 */
    var vm = new Vue({
        el: '#app',
        data: {
            msg: {
                color: 'red'
            }
        },
        //局部指令，需要定义在 directives 的选项 
        directives: {
            color: {
                bind: function (el, binding) {
                    el.style.backgroundColor = binding.value.color;
                }
            },
            focus: {
                inserted: function (el) {
                    el.focus();
                }
            }
        }
    });
</script>
```

##### 4.计算属性

```vue
<div id="app">
    <!--当多次调用 reverseString 的时候 只要里面的 num 值不改变 他会把第一次计算的结果直接返回 直到data 中的num值改变 计算属性才会重新发生计算 -->
    <div>{{reverseString}}</div>
    <div>{{reverseString}}</div> <!-- 调用methods中的方法的时候 他每次会重新调用 -->
    <div>{{reverseMessage()}}</div>
    <div>{{reverseMessage()}}</div>
</div>
<script type="text/javascript">
    /*计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存 */
    var vm = new Vue({
        el: '#app',
        data: {
            msg: 'Nihao',
            num: 100
        },
        methods: {
            reverseMessage: function () {
                console.log('methods') 
                return this.msg.split('').reverse().join('');
            }
        }, //computed 属性 定义 和 data 已经 methods 平级 
        computed: { // reverseString 这个是我们自己定义的名字 
            reverseString: function () {
                console.log('computed')
                var total = 0;
                // 当data 中的 num 的值改变的时候 reverseString 会自动发生计算 
                for (var i = 0; i <= this.num; i++) {
                    total += i;
                }
                // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果 
                return total;
            }
        }
    });
</script>
```

##### 5.监听器watch

```vue
<div id="app">
    <div><span>名：</span> <span> <input type="text" v-model='firstName'> </span> </div>
    <div><span>姓：</span> <span> <input type="text" v-model='lastName'> </span> </div>
    <div>{{fullName}}</div>
</div>
<script type="text/javascript">
    /* 侦听器 */
    var vm = new Vue({
        el: '#app',
        data: {
            firstName: 'Jim',
            lastName: 'Green',
             fullName: 'Jim Green' 
        },
            //watch 属性 定义 和 data 已经 methods 平级 
            watch: {
                // 注意： 这里firstName 对应着data 中的 firstName
                // 当 firstName 值 改变的时候 会自动触发 watch
                firstName: function (val) {
                    this.fullName = val + ' ' + this.lastName;
                },
                // 注意： 这里 lastName 对应着data 中的 lastName 
                lastName: function (val) {
                    this.fullName = this.firstName + ' ' + val;
                }
            }
        }
    });
</script>
```

6.过滤器

```vue
<div id="app"> <input type="text" v-model='msg'>
    <!-- upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 -->
    <div>{{msg | upper}}</div>
    <!--支持级联操作 upper 被定义为接收单个参数的过滤器函数，表达式msg 的值将作为参数传入到函数中。 然后继续调用同样被定义为接收单个参数的过滤器 lower ，将upper 的结果传递到lower中 -->
    <div>{{msg | upper | lower}}</div>
    <div :abc='msg | upper'>测试数据</div>
</div>
<script type="text/javascript">
    // lower 为全局过滤器
    Vue.filter('lower', function (val) {
        return val.charAt(0).toLowerCase() + val.slice(1);
    });
    var vm = new Vue({
        el: '#app',
        data: {
            msg: ''
        },
        //filters 属性 定义 和 data 已经 methods 平级 // 定义filters 中的过滤器为局部过滤器 
        filters: {
            // upper 自定义的过滤器名字
            // upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 
            upper: function (val) {
                // 过滤器中一定要有返回值 这样外界使用过滤器的时候才能拿到结果
                return val.charAt(0).toUpperCase() + val.slice(1);
            }
        }
    });
</script>

filter传递参数

<div id="box"> 
<!--filterA 被定义为接收三个参数的过滤器函数。 其中 message 的值作为第一个参数， 普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 -->
 {{ message | filterA('arg1', 'arg2') }} 
 </div>
<script>
// 在过滤器中 第一个参数 对应的是 管道符前面的数据 n 此时对应 message
// 第2个参数 a 对应 实参 arg1 字符串 // 第3个参数 b 对应 实参 arg2 字符串
Vue.filter('filterA', function(n, a, b) {
  if (n < 10) {
    return n + a
  } else {
    return n + b
  }
})
new Vue({ el: '#box', data: { message: '哈哈哈' } })
</script>

```

6.生命周期

```js
1.beforeCreate
在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的
DOM结构都没有初始化 什么都做不了
2.created 在实例创建完成后被立即调用此时data 和 methods已经可以使用 但是页面还没有渲染出来
3.beforeMount 在挂载开始之前被调用 此时页面上还看不到真实数据 只是一个模板页面而已
4.mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 数据已经真实渲染到页面上
在这个钩子函数里面我们可以使用一些第三方的插件
5.beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。 页面上数据还是旧的
6.updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已
经替换成最新的
7.beforeDestroy 实例销毁之前调用
8.destroyed 实例销毁后调用
```

##### 6.数组相关方法

```js
push() 往数组最后面添加一个元素，成功返回当前数组的长度
pop() 删除数组的最后一个元素，成功返回删除元素的值
shift() 删除数组的第一个元素，成功返回删除元素的值
unshift() 往数组最前面添加一个元素，成功返回当前数组的长度
splice()
有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），
第三个是删除 后想要在原位置替换的值
sort() sort() 使数组按照字符编码默认从小到大排序,成功返回排序后的数组
reverse() reverse() 将数组倒序，成功返回倒序后的数组

替换数组，但不会改变原数组
filter： filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
concat： concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组
slice： slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组
```

##### 7.组件

```vue
<div id="example"> <!-- 2、 组件使用 组件名称 是以HTML标签的形式使用 -->  <my-component></my-component> </div><script>// 注册组件 // 1、 my-component 就是组件中自定义的标签名Vue.component('my-component', { template: '<div>A custom component!</div>' })// 创建根实例new Vue({ el: '#example' })</script>
```

局部组件

```vue
<div id="app"> <my-component></my-component> </div><script>// 定义组件的模板var Child = { template: '<div>A custom component!</div>' }new Vue({  //局部注册组件  components: {    // <my-component> 将只在父模板可用 一定要在实例上注册了才能在html文件中使用    'my-component': Child  }})</script>
```

组件之间的传值

```js
父传子：通过属性绑定子传递父组件：$emit(事件名，参数) ，父组件 @事件名=函数 监听兄弟之间传值：建立一个hub中心			var hub = new Vue()            组件1：            发送：hub.$emit(事件1，参数)			监听要在钩子函数mounted中进行			监听：hub.$on(事件2，(val)=>{})			组件2：            发送：hub.$emit(事件2，参数)			监听：hub.$on(事件1，(val)=>{})最后要销毁hubhub.$off(事件1);hub.$off(事件2);
```

![image-20201115143109452](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201115143109452.png)

##### 8.插槽

匿名插槽

```js
<div id="app"><!-- 这里的所有组件标签中嵌套的内容会替换掉slot 如果不传值 则使用 slot 中的默认值 --> <alert-box>有bug发生</alert-box><alert-box>有一个警告</alert-box><alert-box></alert-box> </div> <script type="text/javascript"> /*组件插槽：父组件向子组件传递内容 */Vue.component('alert-box', {   template: ` <div> <strong>ERROR:</strong> # 当组件渲染的时候，这个 <slot> 元素将会被替换为“组件标签中嵌套的内容”。 # 插槽内可以包含任何模板代码，包括 HTML <slot>默认内容</slot> </div> ` });   var vm = new Vue({ el: '#app', data: { } }); </script></body></html>
```

具名插槽

```vue
<head slot="head">有一个警告</head>Vue.component('base-layout',{ template: ` <div>    <header>        ### 1、 使用 <slot> 中的 "name" 属性绑定元素 指定当前插槽的名字            <slot name='header'></slot>    </header>    <main>        <slot></slot>    </main>    <footer>         ### 注意点： ### 具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序        <slot name='footer'></slot>    </footer></div> ` });
```

作用域插槽

```vue
Vue.component('fruit-list',{ props: ['list'],template: ` <div>                <li :key='item.id' v-for='item in list'>                    ### 3、 在子组件模板中,<slot>元素上有一个类似props传递数据给组件的写法msg="xxx", ###                        插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉                        <slot :info='item'>{{item.name}}                        </slot>                </li>        </div> ` });//使用slotProps是一个临时变量，保存的是属性绑定传递过来的值<template slot-scope='slotProps'>	<strong v-if='slotProps.info.id==3' class="current"> {{slotProps.info.name}} </strong> 	<span v-else>{{slotProps.info.name}}</span></template>
```



##### 9.fetch

```js
1.Fetch API是新的ajax解决方案 Fetch会返回Promise2.fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。3.用法：fetch(url, options).then()4.提供了很多方法：POST，GET，DELETE，UPDATE，PATCH和PUT5.get方式  fetch('http://localhost:3000/books?id=123', {            #get 请求可以省略不写 默认的是GET            method: 'get'        }).then(function (data) {            #它返回一个Promise实例对象， 用于获取后台返回的数据            return data.text();        }).then(function (data) {            # 在这个then里面我们能拿到最终的数据            console.log(data)        });        #1.2 GET参数传递 restful形式的URL 通过/ 的形式传递参数 即 id = 456 和id后台的配置有关        fetch('http://localhost:3000/books/456', {                       # get 请求可以省略不写 默认的是GET            method: 'get'        }).then(function (data) {            return data.text();//要将获取到的值转化为字符串            return JSON.parse(data) //返回为json对象        }).then(function (data) {            console.log(data)        });6.delete和get类似7.post	//要设置body,method,headers等选项  fetch('http://localhost:3000/books', {            method: 'post',            #3.1 传递数据             body: 'uname=lisi&pwd=123',            #3.2 设置请求头             headers: {                'Content-Type': 'application/x-www-form-urlencoded'            }        }).then(function (data) {            return data.text();        }).then(function (data) {            console.log(data)        });8.put	put和post类似
```

##### 10.axios

```js
基于promise用于浏览器和node.js的http客户端支持浏览器和node.js支持promise能拦截请求和响应自动转换JSON数据能转换请求和响应数据
```

传参方式

```js
1.get      #2. get 请求传递参数# 2.1 通过传统的url 以 ? 的形式传递参数         axios.get('http://localhost:3000/axios?id=123').then(function (ret) {            console.log(ret.data)        })        # 2.2 restful 形式传递参数         axios.get('http://localhost:3000/axios/123').then(function (ret) {            console.log(ret.data)        })        # 2.3 通过params 形式传递参数        axios.get('http://localhost:3000/axios', {            params: {                id: 789            }        }).then(function (ret) {            console.log(ret.data)        })2.post        #4.1 通过选项传递参数 axios.post('http://localhost:3000/axios', {            uname: 'lisi',            pwd: 123        }).then(function (ret) {            console.log(ret.data)        })        # 4.2 通过 URLSearchParams 传递参数        var params = new URLSearchParams();        params.append('uname', 'zhangsan');        params.append('pwd', '111');        axios.post('http://localhost:3000/axios', params).then(function (ret) {            console.log(ret.data)        })
```

###### axios全局配置

```js
# 配置公共的请求头axios.defaults.baseURL = 'https://api.example.com'; # 配置 超时时间 axios.defaults.timeout = 2500;# 配置公共的请求头 axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;# 配置公共的 post 的 Content-Type axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

###### axios拦截器

```vue
 <script>        #1. 请求拦截器         axios.interceptors.request.use(function (config) {                    console.log(config.url)                    # 1.1 任何请求都会经过这一步 在发送请求之前做些什么                     config.headers.mytoken = 'nihao';                    # 1.2 这里一定要return 否则配置不成功                    return config;                }, function (err) {                    #1.3 对请求错误做点什么                     console.log(err) })         # 2. 响应拦截器                     axios.interceptors.response.use(function (res) {                                #2.1 在接收响应做些什么                                 var data = res.data;                                return data;                            }, function (err) {                                #2.2 对响应错误做点什么                                 console.log(err) })    </script>
```



##### 11.路由

```js
渲染方式1.后端渲染（存在性能问题）2.Ajax前端渲染（前端渲染提高性能，但是不支持浏览器的前进后退操作）3.SPA（Single Page Application）单页面应用程序：整个网站只有一个页面，内容的变化通过Ajax局部更新实现、同时支持浏览器地址栏的前进和后退操作SPA实现原理之一：基于URL地址的hash（hash的变化会导致浏览器记录访问历史的变化、但是hash的变化不会触发新的URL请求）在实现SPA过程中，最核心的技术点就是前端路由
```

路由通过hash地址的方式来切换页面，不用往服务端发送请求

###### 路由步骤

```
1. 引入相关的库文件2. 添加路由链接3. 添加路由填充位4. 定义路由组件5. 配置路由规则并创建路由实例6. 把路由挂载到 Vue 根实例中
```

###### 路由实例

​	1.路由占位符：通过在某个组件中写下router-view，当请求路由引用的组件对用到当前组件时，会显示当前占位父符组件

```vue
 <!-- 控制组件的显示位置 --> <router-view></router-view>
```

2.定义路由组件

```vue
var User = { template: '<div>User</div>' } var Register = { template: '<div>Register</div>' }
```

3.创建路由实例

```js
 // 创建路由实例对象  var router = new VueRouter({ // routes 是路由规则数组 routes: [ // 每个路由规则都是一个配置对象，其中至少包含 path 和 component 两个属性： // path 表示当前路由规则匹配的 hash 地址 // component 表示当前路由规则对应要展示的组件 {path:'/user',component: User}, {path:'/register',component: Register} ] })
```

4.挂载Vue根实例上

```js
 new Vue({ el: '#app', // 为了能够让路由规则生效，必须把路由对象挂载到 vue 实例对象上 router });
```



5.路由重定向redirect

###### 嵌套路由

```js
const router = new VueRouter({ routes: [ { path: '/user', component: User }, { path: '/register', component: Register, // 通过 children 属性，为 /register 添加子路由规则 children: [ { path: '/register/tab1', component: Tab1 }, { path: '/register/tab2', component: Tab2 } ] } ] })
```

###### 动态路由

```js
//路由var router = new VueRouter({ routes: [ // 动态路径参数 以冒号开头 { path: '/user/:id', component: User } ]})//组件  使用路由传递的参数const User = { // 路由组件中通过$route.params获取路由参数 template: '<div>User {{ $route.params.id }}</div>'}
```

###### 路由组件传递参数

上述将路由和组件高度耦合，不好，要用props将路由和组件分开

```js
//通过props传递参数 const router = new VueRouter({ routes: [ // 如果 props 被设置为 true，route.params 将会被设置为组件属性 { path: '/user/:id', component: User, props: true } ] })  const User = { props: ['id'], // 使用 props 接收路由参数 template: '<div>用户ID：{{ id }}</div>' // 使用路由参数 }
```

```js
props值为对象类型时，就无法获取到对应的id值 const router = new VueRouter({ routes: [ // 如果 props 是一个对象，它会被按原样设置为组件属性 { path: '/user/:id', component: User, props: { uname: 'lisi', age: 12 }} ] })const User = { props: ['uname', 'age'], template: ‘<div>用户信息：{{ uname + '---' + age}}</div>' }
```

```js
props为函数类型就可以传递动态路由，也可以传递参数 const router = new VueRouter({ routes: [ // 如果 props 是一个函数，则这个函数接收 route 对象为自己的形参 { path: '/user/:id',  component: User,  props: route => ({ uname: 'zs', age: 20, id: route.params.id })} ] })const User = { props: ['uname', 'age', 'id'], template: ‘<div>用户信息：{{ uname + '---' + age + '---' + id}}</div>' }
```

###### 编程式导航和声明式导航

```json
1.声明式导航：通过点击链接实现导航的方式，叫做声明式导航  例如：普通网页中的 <a></a> 链接 或 vue 中的 <router-link></router-link>2.编程式导航：通过调用JavaScript形式的API实现导航的方式，叫做编程式导航  例如：普通网页中的 location.href3.编程式导航const User = { template: '<div><button @click="goRegister">跳转到注册页面</button></div>', methods: { goRegister: function(){ // 用编程的方式控制路由跳转 this.$router.push('/register'); } } }4.编程式导航传参 // 字符串(路径名称) router.push('/home') // 对象 router.push({ path: '/home' }) // 命名的路由(传递参数) router.push({ name: '/user', params: { userId: 123 }}) // 带查询参数，变成 /register?uname=lisi router.push({ path: '/register', query: { uname: 'lisi' }})
```

###### 命名路由

```js
 const router = new VueRouter({ routes: [ { path: '/user/:id', name: 'user', component: User } ] }) //声明式 <router-link :to="{ name: 'user', params: { id: 123 }}">User</router-link>//编程式 router.push({ name: 'user', params: { id: 123 }})
```

##### 12.vuex

```js
步骤：1.导入vuex包    安装npm install vuex --savevue.use(vuex)2.创建store对象const store = new Vuex({	//存储共享的数据	state:{		count:0	}})3.将store对象挂载到vue实例当中new Vue({ el: '#app', render: h => h(app), router, // 将创建的共享数据对象，挂载到 Vue 实例中 // 所有的组件，就可以直接从 store 中获取全局的数据了 store})
```

###### 核心模块

1.state

```js
1.state: 提供唯一的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储 // 创建store数据源，提供唯一公共数据 const store = new Vuex.Store({ state: { count: 0 } }) 访问方式1：this.$store.state.全局数据名称 组件访问方式二:从vuex中导入mapState函数 	import { mapState } from 'vuex' 	将全局数据映射为当前组件的计算属性    computed: { 		...mapState(['count'])	}
```

2.Mutation

```js
Mutation:用于变更state中的数据Mutation不能直接改变state的数据 1.定义 Mutation const store = new Vuex.Store({ state: { count: 0 }, mutations: {     //定义的mutation方法 add(state) { // 变更状态 state.count++ } } }) 2. //通过this.$store.commit()来触发mutation中的方法 methods: { handle1() { // 触发 mutations 的第一种方式 this.$store.commit('add') } }3.mutation可以传递参数 methods: { handle2() { // 在调用 commit 函数， // 触发 mutations 时携带参数 this.$store.commit('addN', 3) } }//mutationadd(state，step) //step参数4.mutation触发第二种方式import { mapMutations } from 'vuex'// 将指定的 mutations 函数，映射为当前组件的 methods 函数methods: { ...mapMutations(['add', 'addN'])}
```

3.Action

```js
Action 用于处理异步任务如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发Mutation 的方式间接变更数据1.组件中触发action// 触发 Action methods: { handle() { // 触发 actions 的第一种方式 this.$store.dispatch('addAsync') } }2.action中定义方法并调用 const store = new Vuex.Store({ // ...省略其他代码 mutations: { add(state) { state.count++ } }, actions: { addAsync(context) { setTimeout(() => { context.commit('add') }, 1000) }  } }) 3.携带参数  // 触发 Action methods: { handle() { // 在调用 dispatch 函数， // 触发 actions 时携带参数 this.$store.dispatch('addNAsync', 5) } }//actionaddAsync(context,step){    }4.触发action的第二种方式//  从 vuex 中按需导入 mapActions 函数import { mapActions } from 'vuex'通过刚才导入的 mapActions 函数，将需要的 actions 函数，映射为当前组件的 methods 方法：//  将指定的 actions 函数，映射为当前组件的 methods 函数methods: { ...mapActions(['addASync', 'addNASync'])}
```

4.getter

```js
1.Getter 用于对 Store 中的数据进行加工处理形成新的数据2. Store 中数据发生变化，Getter 的数据也会跟着变化。// 定义 Getter const store = new Vuex.Store({ state: { count: 0 }, getters: { showNum: state => { return '当前最新的数量是【'+ state.count +'】' } } })  3.使用 getters 的第一种方式：this.$store.getters.名称使用 getters 的第二种方式：import { mapGetters } from 'vuex'computed: { ...mapGetters(['showNum'])}
```

##### 13.组件懒加载

懒加载用到时才会加载

```
{path:'/p1',component: resolve=>(require(["@/components/HelloWorld"],resolve))}
```



##### 14.组件中的data为什么是一个函数return返回

```
因为组件需要复用，当我们是一个对象时，多个组件公用一个data数据，当某个组件改变时会对公用的data发生改变，这样不好，当data是一个函数时，形成了一个私有作用域，各个组件的data数据私有化，互不影响
```

![image-20201124191444066](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201124191444066.png)

![image-20201124191500376](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20201124191500376.png)

##### 15.minxs

vue中提供了一种混合机制--mixins，用来更高效的实现组件内容的复用。最开始我一度认为这个和组件好像没啥区别。。后来发现错了。下面我们来看看mixins和普通情况下引入组件有什么区别？

   组件在引用之后相当于在父组件内开辟了一块单独的空间，来根据父组件props过来的值进行相应的操作，单本质上两者还是泾渭分明，相对独立。

   而mixins则是在引入组件之后，则是将组件内部的内容如data等方法、method等属性与父组件相应内容进行合并。相当于在引入后，父组件的各种属性方法都被扩充了。

```js
1.定义一个 js 文件(mixin.js)复制代码export default { data() {  return {   name: 'mixin'  } }, created() {  console.log('mixin...', this.name); }, mounted() {}, methods: {}}复制代码2.在vue文件中使用mixinimport mixin from '@/mixin'; // 引入mixin文件export default { mixins: [mixin]}
```

##### 16.vue中v-if与v-show的区别以及使用场景

```js
1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好
```

##### 17.双向数据绑定原理

```
1.  Object.defineProperty2.发布订阅者模式<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <h1></h1>    <input type="text" id="input">    <button id="btn">提交</button>    <script>    let obj = {}    var name='ddd'    Object.defineProperty(obj,'name',{        set:function(val){            console.log('数据被劫持了')            name = val            //数据修改就赋值            let h1 = document.getElementsByTagName('h1')[0]            h1.innerHTML=val        },        get:function(val){            return  name        }    })    let btn =document.getElementById('btn')    btn.onclick =function(){        obj.name = '双向数据绑定原理'        console.log(obj.name)    }    //输入值监听    let input =document.getElementsByTagName('input')[0]    input.oninput =function(){        obj.name = this.value    }    </script></body></html>
```

##### 18.class与style的绑定

```js
-----class1.<div v-bind:class="{ active: isActive }"></div>  =>isActive:true生效 false不生效  2.<div  class="static"  v-bind:class="{ active: isActive, 'text-danger': hasError }"></div> //可以两个class共同存在3.<div v-bind:class="classObject"></div>	classObject:{        active:true    }4.数组的绑定 	//可以直接定义一个对象<div v-bind:class="[activeClass, errorClass]"></div>	data: {  activeClass: 'active',  errorClass: 'text-danger'}//切换样式（三元表达式）<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>//可以将数组与对象结合<div v-bind:class="[{ active: isActive }, errorClass]"></div> //isActive是否为true决定active是否存在------style1.<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>data: {  activeColor: 'red',  fontSize: 30}2.对象<div v-bind:style="styleObject"></div>data: {  styleObject: {    color: 'red',    fontSize: '13px'  }}3.数组语法可以将多个样式对象应用到同一个元素上<div v-bind:style="[baseStyles, overridingStyles]"></div>4.可以绑定多个值<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

##### 19.v-if与v-show

```
v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。key:Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染(一般重复的元素会找到相同元素替换)		这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一		   值的 key attribute 即可v-show 不支持 <template> 元素，也不支持 v-else。
```



### 2.vue3.0相关

#### 1.1ref使用

```vue
ref只能监听简单类型的变化，不能监听复杂类型的变化
<template>
	<div>
		<input type="text" v-model="num1" @keyup="add()"/>
		<text>+</text>
		<input type="text" v-model="num2" @keyup="add()"/>
		<text>=</text>
		<span>{{result}}</span>
	</div>
</template>
<script>
import { ref,reactive } from 'vue'
export default {
	setup(props) {
        //ref通常用作变量
		const num1 = ref(0)
		const num2 = ref(0)
    let result = ref(0)
    function add (){
        //ref重新绑定需要通过.value的形式
      result.value =parseInt(num1.value)+parseInt(num2.value)
    }
    return {
      num1,
      num2,
      result,
      add
    }
	},
}
</script>
<style scoped lang="scss">
</style>

```

#### 1.2reactive的使用

```vue
<template>
	<div>
		<input type="text" v-model="state.num1" @keyup="add()"/>
		<text>+</text>
		<input type="text" v-model="state.num2" @keyup="add()"/>
		<text>=</text>
		<span>{{state.result}}</span>
	</div>
</template>
<script>
import { ref,reactive } from 'vue'
export default {
	setup(props) {
    const state = reactive({
      num1:0,
      num2:0,
      result:0
    })
    function add (){
      state.result =parseInt(state.num1)+parseInt(state.num2)
    }
    return {
      state,
      add
    }
	},
}
</script>
<style scoped lang="scss">
</style>

```

#### 1.3computed的使用

```vue
<template>
	<div>
		<input type="text" v-model="state.num1" />
		<text>+</text>
		<input type="text" v-model="state.num2"/>
		<text>=</text>
		<span>{{state.result}}</span>
	</div>
</template>
<script>
import { ref,reactive,computed } from 'vue'
export default {
	setup(props) {
    const state = reactive({
      num1:0,
      num2:0,
      result:computed(()=>parseInt(state.num1)+parseInt(state.num2))
    })
    return {
      state
    }
	},
}
</script>
<style scoped lang="scss">
</style>

```

#### 1.4向上级传参

```vue
<template>
	<div>
		<input type="text" v-model="state.num1" />
		<text>+</text>
		<input type="text" v-model="state.num2"/>
		<text>=</text>
		<span>{{state.result}}</span>
    <button @click="event"> 向上级传参</button>
	</div>
</template>
<script>
import { ref,reactive,computed } from 'vue'
export default {
  // props父级属性绑定值 ctx代表上下文里面有三个值attrs slots emit
	setup(props,ctx) {
    const state = reactive({
      num1:0,
      num2:0,
      result:computed(()=>parseInt(state.num1)+parseInt(state.num2))
    })
    function event(){
        ctx.emit('sendMsg',state.result)
    }
    return {
      state,
      event
    }
	},
}
</script>
<style scoped lang="scss">
</style>

```

#### 1.5生命周期

```
beforeCreate -> use setup() beforeCreate//禁用

created -> use setup() beforeCreate//禁用

beforeMount -> onBeforeMount

mounted -> onMounted

beforeUpdate -> onBeforeUpdate

updated -> onUpdated

beforeUnmount -> onBeforeUnmount

unmounted -> onUnmounted  //不在当前组件会触发 vue3.0没有destroyed相当于onunmouted

errorCaptured -> onErrorCaptured  //当捕获一个来自子孙组件的错误时被调用

renderTracked -> onRenderTracked  //跟踪虚拟 DOM 重新渲染时调用

renderTriggered -> onRenderTriggered //当虚拟 DOM 重新渲染为 triggered.Similarly
```

#### 1.6ref引用

```
在一个组件中ref引用是通过
1.使用
<input type="text" v-model="editValue" ref="myinput" />
2.导入ref
import { ref } from "vue";
3.定义ref
const myinput = ref(null);
4.最后返回
return {myinput};
```

#### 1.7Vue3.0的优点

```
1.性能比vue2.0快1.2~2倍
	1.1 diff方法优化：
		vue3.0添加静态标记，数据更新看是否有静态标记来是否更新dom树
	1.2静态提升hositStatic：
		vue2.0会对每一个无论是否参与更新都会重新创建渲染
		vue3.0对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染是直接复用即可
	1.3cacheHandlers事件侦听器缓存：
		vue3.0默认情况下onclick会被视为动态绑定，所以每次都会去追踪它的变化，但是因为是同一个函数所以没有去追踪变化
		直接复用即可
	1.4ssr渲染
2.按需编译体积比vue2.x更小
3.使用composition API
4.更好的支持ts
5.暴露了自定义渲染的Api
6.更多更先进的组件
```

#### 1.8.组合api

```js
1.可以将方法抽离出来，里面包含对应的数据，和方法
<template>
    <input type="text" v-model="stateAdd.list.name"> <button @click="add">添加</button>
	<ul>
		<li
			v-for="(item, index) in state.lists"
			:key="index"
			@click="remove(index)"
		>
			{{ item.name }}
		</li>
	</ul>
</template>

<script>
import { reactive } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		const { state, remove } = removeList();
		const { stateAdd, add } = addList(state);
		return {
			state,
            stateAdd,
			remove,
            add
		};
	},
};
//删除方法
function removeList() {
	const state = reactive({
		lists: [
			{ name: 1 },
			{ name: 2 },
			{
				name: 3,
			},
		],
	});
	function 
    (index) {
		state.lists.splice(index, 1);
	}
	return {
		state,
		remove,
	};
}
//添加方法
function addList(state){
    const stateAdd =reactive({
        list:{
            name:''
        }
    })
    function add(){
        state.lists.push(stateAdd.list)
    }
    return {
        stateAdd,
        add
    }
}
</script>

```

#### 1.9compositionApi的实质

```js
1.compositionAPI可以和optionApi混用
<template>
  <p>{{name}}</p>
  <p>{{state.name1}}</p>
</template>

<script>
import { reactive } from "vue";
export default {
	name: "HelloWorld",
    data() {
        return {
            name:'zs'
        }
    },
	setup() {
        const state =reactive({
            name1:'lisi'
        })
        return {
            state
        }
	},
};


</script>

2.实质
comsitionApi在运行中将暴露的属性注入到Data中，将方法注入到methods中
```

#### 2.0.setUp注意点

```
1.执行时间
在beforeCreated和created之间执行
beforeCreated：组件被刚刚创建出来，组件的data和methods还没有初始化
setUp  所以setup不能使用data和methos
created：组件被创建出来，并且组件的data和methods已经初始化好
2.注意点
-由于在执行setup函数时还没有执行created方法，所以setup中无法使用data和methods方法
-vue直接将setup函数中的this变成了undefined
-setup函数只能是同步的不能是异步的
```

#### 2.1compositionApi路由跳转

![composition路由跳转](D:\web\note\img\composition路由跳转.png)

#### 2.2reactive注意点

```
1.vue2.0是通过属性监听defineProperty
  vue3.0中响应式数据是通过es6的Proxy来实现的
2.reactive注意点
  reactive参数必须是对象（json/arr）
  如果reactive传递了其他对象：
  默认情况下修改对象，界面不会自动更新
  如果想更新，可通过重新赋值的方式
```

![reactive](D:\web\note\img\reactive.png)

#### 2.3ref和reactive的区别

```
1.ref在template中要通过.value的形式展示，reactive则不用.value的形式展示
2.vue中是否自动添加.value是通过创建类型里面是够含有v_ref来决定，有v_ref就不自动添加，没有就自动添加
3.ref和reactive的类型可以通过isRef和isReative决定
```

#### 2.4非递归监听

```js
1.递归监听就是通过ref,reactive创建的，每一层发生变化都会去更新
2.非递归监听就是通过 shallowReactive, shallowRef创建的，只监听第一层，而且shallowRef只监听第一层的.value
<template>
	<p>{{ state.a }}</p>
	<p>{{ state.gf.b }}</p>
	<p>{{ state.gf.f.c }}</p>
	<p>{{ state.gf.f.s.d }}</p>
    <button @click="myFn">button</button>
</template>

<script>
import { shallowReactive, shallowRef } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		let state = shallowReactive({
			a: "a",
			gf: {
				b: "b",
				f: {
					c: "c",
					s: {
						d: "d",
					},
				},
			},
		});
		function myFn() {
            state.a=1  //非监听就是只监听第一层如果第一次层发生变化就会去更新,如果这里注释掉就不会更新了
            state.gf.b =2
            state.gf.f.c = 3
            state.gf.f.s.d=4
			console.log(state);
			console.log(state.gf);
			console.log(state.gf.f);
			console.log(state.gf.f.s);
		}
		return {
			state,
            myFn
		};
	},
};
</script>


3.shallowRef监听的是state.value的变化
<template>
	<p>{{ state.a }}</p>
	<p>{{ state.gf.b }}</p>
	<p>{{ state.gf.f.c }}</p>
	<p>{{ state.gf.f.s.d }}</p>

	<button @click="myFn">button</button>
</template>

<script>
import { shallowReactive, shallowRef } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		let state = shallowRef({
			a: "a",
			gf: {
				b: "b",
				f: {
					c: "c",
					s: {
						d: "d",
					},
				},
			},
		});
		function myFn() {
            state.value.a= '1' //无效
			state.value={ //有效  shallowRef监听的是value的变化，若果state.value发生变化就会去更新
			a: "1",
			gf: {
				b: "2",
				f: {
					c: "3",
					s: {
						d: "4",
					},
				},
			},
		}
            console.log(state)
			console.log(state.value);
			console.log(state.value.gf);
			console.log(state.value.gf.f);
			console.log(state.value.gf.f.s);
		}
		return {
			state,
			myFn,
		};
	},
};
</script>


//如果要里面某一个数据发生改变而更新就要用到triggerRef
state.value.gf.f.s.d ='4'
triggerRef(state)
```

#### 2.5vue3.0挂载全局属性和方法

```
app.config.globalProperties.$request = request
```

#### 2.6ref 和shallowRef的本质

```
1.ref定义最后是转化为reactive
ref(10)===>reactive({value:10})
2.shallowRef也是一样转化为shallowReactive
shallowRef(10)===>shallowReactive({value:10})
shallowRef监听的是.value的变化，因为shallowReactive监听的是第一次层value。
```

#### 2.7toRow

```js
1.用于获取reactive原始数据
<template>
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { reactive, toRaw } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		let obj = { name: "edg", age: 18 };
		let state = reactive(obj);
		console.log(obj === state); //false
		//    ref reactive的数据特点：
		// 每次修改都会被追踪，都会更新ui界面，但是这样非常消耗性能，如果有一些操作不需要追踪，不需要更新ui界面，那么这个时候就可以通过toRow拿到它的原始数据，对数据修改就不会被追踪，不会更新ui界面，性能就会得到提升
		let obj2 = toRaw(state);
		console.log(obj === obj2);
		//state的obj的关系：
		//引用关系，state的本质是一个Proxy对象，在这个对象中引用了obj
		function myFun() {
            //修改obj无法触发界面更新
			//只有修改包装之后的对象才可以触发界面的更新
			obj2.name = "lisi";
			console.log(obj);//{name: "lisi", age: 18}
			console.log(state);//Proxy {name: "lisi", age: 18}
		}
		return {
			state,
			myFun,
		};
	},
};
</script>
 2.获取ref的原始数据
 <template>
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { ref, toRaw } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		let obj = { name: "edg", age: 18 };
		let state = ref(obj);
        //获取ref的原始数据，需要.value才获取的是ref的原始数据
		let obj2 = toRaw(state.value);
		console.log(obj);
		console.log(state);
		console.log(obj2);
		return {
			state,
		};
	},
};
</script>
```

#### 2.8markRow

```js
<template>
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { reactive, markRaw } from "vue";
export default {
	name: "HelloWorld",
	setup() {
		let obj = { name: "edg", age: 18 };
        //markRow用于不允许追踪渲染，用markRow处理后的对象就不会被追踪修改
        obj = markRaw(obj)
		let state = reactive(obj);
		function myFun() {
			state.name = "sss";
            alert('ss')
		}
		return {
			state,
            myFun
		};
	},
};
</script>
```

#### 2.9toRef

````js
<template>
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { ref, toRef } from "vue";
export default {
	name: "HelloWorld",
	// setup() {
	// 	let obj = { name: "edg"};
	//     let state = ref(obj.name)
	//     /**
	//      * 结论：如果利用ref将某一个对象得属性变成响应式数据，我们修改响应式得数据是不会影响到原始数据得
	//      */
	// 	function myFun() {
	//         state.value='zs'
	//         console.log(state)
	//         console.log(obj)
	// 	}
	// 	return {
	// 		state,
	//         myFun
	// 	};
	// },

	setup() {
		let obj = { name: "edg" };
		let state = toRef(obj, "name");
		/**
		 * 结论：如果利用toRef将某一个对象得属性变成响应式数据，我们修改响应式得数据是会影响到原始数据得,并且ui视图不会更新
		 */
		function myFun() {
			state.value = "zs";
			console.log(state);
			console.log(obj);
		}
		return {
			state,
			myFun,
		};
	},
    /**
     * ref和toRef得区别：
     * ref->复制，修改响应式数据不会影响以前得数据
     * toRef->引用，修改响应是数据会影响以前得数据
     * ref数据发生改变就会自动更新
     * toRef数据发生改变界面也不会自动更新
     * toRef得应用场景：
     * 如果想让响应式得数据和以前得数据关联起来，并且响应式数据之后还不想更新ui，那么就可以用toRef
     */
};
</script>

````

#### 3.0 toRef和ref得区别

```js
 * ref和toRef得区别：
     * ref->复制，修改响应式数据不会影响以前得数据
     * toRef->引用，修改响应是数据会影响以前得数据
     * ref数据发生改变就会自动更新
     * toRef数据发生改变界面也不会自动更新
     * toRef得应用场景：
     * 如果想让响应式得数据和以前得数据关联起来，并且响应式数据之后还不想更新ui，那么就可以用toRef
```

#### 3.1toRefs

```js
<template>
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { toRefs } from "vue";
export default {
	name: "HelloWorld",


	setup() {
		let obj = { name: "edg",age:18 };
		let state = toRefs(obj);
        /**
         * toRefs可以不用分开定义响应式数据，如果是toRef就要一个一个定义，toRefs也是响应式数据会变，视图不会更新
         */
		function myFun() {
			state.name.value = "zs";
			state.name.age = "666";
			console.log(state);
			console.log(obj);
		}
		return {
			state,
			myFun,
		};
	},

};
</script>

```



#### 3.2customRef

```js
定义：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制
<template>
	<!-- <ul>
		<li v-for="item in state" :key="item.id">{{ item.name }}</li>
	</ul> -->
	{{ state }}
	<button @click="myFun">button</button>
</template>

<script>
import { ref, customRef } from "vue";
//对于异步可以自定义ref简化setup里面的代码
function myRef(value) {
	return customRef((track, trigger) => {
		fetch(value)
			.then((res) => {
				return res.json();
			})
			.then((data) => {
				value = data;
                trigger()//告诉vue触发界面更新
			})
			.catch((err) => {
				console.log(err);
			});
		return {
			get() {
				track(); //告诉vue这个数据是需要追踪变化的
				return value;
			},
			set(newValue) {
				value = newValue;
				trigger(); //告诉vue触发界面更新
			},
		};
	});
}
export default {
	name: "HelloWorld",
	//setup函数是只能支持同步的，不能支持异步的
	setup() {
		// let state = ref([]);
		// fetch("../../public/data.json")
		// 	.then((res) => {
		// 		return res.json();
		// 	})
		// 	.then((data) => {
		// 		state.value = data;
		// 		console.log(data);
		// 	})
		// 	.catch((err) => {
		// 		console.log(err);
		// 	});
		let state = myRef("../../public/data.json");
		return {
			state,
		};
	},
};
</script>

```

# ======react

##### 1.react有三个依赖

![image-20211022105728414](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211022105728414.png)

##### 2.react的基本使用

```react
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app"></div>
	//引入依赖
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        let message = 'hello world'
        function btnClick() {
            message = 'hello React'
            //由于数据改变，只会改变数据，但不会自动更新dom,所以这里要react来重新调用更新
            render()
        }
        function render() {
            //react的渲染
            ReactDOM.render(
                <div>
                    <h2>{message}</h2>
                    <button onClick={btnClick}>改变文本</button>
                </div>,
                document.getElementById('app')
            )
        }
        render()


    </script>
</body>
</html>
```

##### 3.react的组件封装使用 

```react
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        //react封装一个组件是基于一个类实现
        class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    message: 'hello world'
                }
            }
            render() {
                //这里绑定this是因为点击事件绑定的this是undefined
                return (
                    <div>
                        <h2>{this.state.message}</h2>
                        <button onClick={this.btnClick.bind(this)}>改变文本</button>
                    </div>
                )

            }
            btnClick() {
                //修改值要用setState
                this.setState({
                    message: 'hello React'
                })
            }
        }
        //引入一个组件
        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>

</html>
```

##### 4.jsx便利列表

```react
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        //react封装一个组件是基于一个类实现
        class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    message: ['金刚1', '金刚2', '金刚3']
                }
            }
            render() {
                return (
                    <div>
                        <ul>
                            {
                                //这里数组包含li包裹可以直接便利生成
                                this.state.message.map((item) => {
                                    return <li>{item}</li>
                                })
                            }
                        </ul>
                    </div>
                )

            }

        }
        //引入一个组件
        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>

</html>
```

##### 5.jsx的语法

```react
1.注释
  render() {
                return (
                    <div>
                        {/*这是一个注释*/}
                        <h2>{this.state.num}</h2>
                        <button onClick={this.add.bind(this)}>+</button>
                        <button onClick={this.dele.bind(this)}>-</button>
                    </div>
                )

            }
2.变量
//一些变量在{}语法中会被忽略
 class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    name:'zs',
                    age:18,
                    names:['zs','lisi'],
                    // 以下会被忽略
                    test1:null,
                    test2:undefined,
                    test3:true
                }
            }
            render() {
                return (
                    <div>
                        <span>{this.state.name}</span>
                        <span>{this.state.age}</span>
                        <span>{this.state.names}</span>
                        (/*会展示为空*/)
                        <span>{this.state.test1}</span>
                        <span>{this.state.test2}</span>
                        <span>{this.state.test3}</span>
                        (/*如果要展示可以将以上特殊的转化为字符串*/)
                        <span>{String(this.state.test1)}</span>
                        <span>{this.state.test2+""}</span>
                        <span>{this.state.test3.toString()}</span>

                        
                    </div>
                )

            }

        }
3.对象在jsx中无法直接使用
  class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    obj:{
                        name:'zs',
                        age:18
                    }
                }
            }
            render() {
                return (
                    <div>
                        <span>{this.state.obj}</span>
                    
                        
                    </div>
                )

            }

        }
```

##### 6.jsx一些常用属性绑定

```react
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <div id="app"></div>

  <div style="color: red; font-size: 30px;"></div>

  <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script type="text/babel">
    function getSizeImage(imgUrl, size) {
      return imgUrl + `?param=${size}x${size}`
    }

    class App extends React.Component {
      constructor(props) {
        super(props);

        this.state = {
          title: "标题",
          imgUrl: "http://p2.music.126.net/L8IDEWMk_6vyT0asSkPgXw==/109951163990535633.jpg",
          link: "http://www.baidu.com",
          active: true
        }
      }

      render() {
        const { title, imgUrl, link, active } = this.state;
        return (
          <div>
            {/* 1.绑定普通属性 */}
            <h2 title={title}>我是标题</h2>
            <img src={getSizeImage(imgUrl, 140)} alt=""/>
            <a href={link} target="_blank">百度一下</a>

            {/* 2.绑定class */}
            {/* 这里是className是因为class是关键字，jsx用className识别 */}
            <div className="box title">我是div元素</div>
            <div className={"box title " + (active ? "active": "")}>我也是div元素</div>
            <label htmlFor=""></label>

            {/* 3.绑定style  
                jsx里面不能直接用html的css书写形式
             */}
            <div style={{color: "red", fontSize: "50px"}}>我是div,绑定style属性</div>
          </div>
        )
      }
    }

    ReactDOM.render(<App />, document.getElementById("app"));
  </script>

</body>

</html>
```

##### 7.jsx事件绑定

```react
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        //react封装一个组件是基于一个类实现
        class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    message: 'hello world'
                }
            }
            render() {
                return (
                    <div>
                        { /*方案一：bind绑定this*/}
                        <button onClick={this.btnClick.bind(this)}>bin点击</button>
                        {/*方案二:使用箭头函数*/}
                        <button onClick={this.btnClick1}>箭头函数点击</button>
                        {/*方案三:函数里面放入一个箭头函数*/}
                        <button onClick={()=>{this.btnClick2()}}>嵌套调用点击</button>

                    </div>
                )

            }
            btnClick() {
                console.log(this.state.message)
            }
            btnClick1 = () => {
                console.log(this.state.message)
            }
            btnClick2() {
                console.log(this.state.message)
            }

        }
        //引入一个组件
        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>

</html>
```

##### 8.jsx事件参数传递

```react
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        //react封装一个组件是基于一个类实现
        class App extends React.Component {
            constructor() {
                super()
                //state来管理数据
                this.state = {
                    arr: ['哆啦A梦', '天线宝宝', '喜洋洋与灰太狼']
                }
            }
            render() {
                return (
                    <div>
                        <ul>
                            {this.state.arr.map((item, index) => {
                                return (
                                    <li onClick={() => {this.btnClick(item,index,event) }}>
                                        {item}
                                    </li>
                                )
                            })}
                        </ul>
                    </div>
                )

            }
            btnClick(item,index,e){
                console.log('我点击了li'+item+','+index,e)
            }

        }
        //引入一个组件
        ReactDOM.render(<App />, document.getElementById('app'))
    </script>
</body>

</html>
```

##### 9.jsx条件渲染方式

```
1.if else
2.三元运算符            
<button onClick={e => this.loginClick()}>{isLogin ? "退出" : "登录"}</button>
3.逻辑与 
  {/* 3.方案三: 逻辑与&& */}
  {/* 逻辑与: 一个条件不成立, 后面的条件都不会进行判断了 */}
   <h2>{ isLogin && "你好啊, coderwhy" }</h2>
   { isLogin && <h2>你好啊, coderwhy</h2> }
```

##### 10.jsx的本质

```react
本质：jsx最终都会转化成React.createElement(component, props, ...children)//component代表标签类型，props代表值和属性，children代表里面嵌套的层级也是通过React.createElement来创建的
	//1.这个就代表一个jsx
  	render() {
        return (
          <div>
            <div className="header">
              <h1 title="标题">我是标题</h1>
            </div>
            <div className="content">
              <h2>我是页面的内容</h2>
              <button>按钮</button>
              <button>+1</button>
              <a href="http://www.baidu.com">百度一下</a>
            </div>
            <div className="footer">
              <p>我是尾部的内容</p>
            </div>
          </div>
        )
      }

	//2.jsx最终会形成一个React.createElement组成的react可以识别的层级嵌套形式
 	render() {
        return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
          className: "header"
        }, /*#__PURE__*/React.createElement("h1", {
          title: "\u6807\u9898"
        }, "\u6211\u662F\u6807\u9898")), /*#__PURE__*/React.createElement("div", {
          className: "content"
        }, /*#__PURE__*/React.createElement("h2", null, "\u6211\u662F\u9875\u9762\u7684\u5185\u5BB9"), 				/*#__PURE__*/React.createElement("button", null, "\u6309\u94AE"), 								             /*#__PURE__*/React.createElement("button", null, "+1"), /*#__PURE__*/React.createElement("a", {
          href: "http://www.baidu.com"
        }, "\u767E\u5EA6\u4E00\u4E0B")), /*#__PURE__*/React.createElement("div", {
          className: "footer"
        }, /*#__PURE__*/React.createElement("p", null, "\u6211\u662F\u5C3E\u90E8\u7684\u5185\u5BB9")));
      }

	//3.React.createElement 最终创建出来一个 ReactElement对象
	//React利用ReactElement对象组成了一个JavaScript的对象树====>虚拟Dom
	render() {
        // jsx -> createElement函数 -> ReactElement(对象树) -> ReactDOM.render -> 真实DOM
        // jsx -> createElement函数 -> ReactElement(对象树) -> ReactDOM.render -> 原生的控件(UIButton/Button)
        var elementObj = (
          <div>
            <div className="header">
              <h1 title="标题">我是标题</h1>
            </div>
            <div className="content">
              <h2>我是页面的内容</h2>
              <button>按钮</button>
              <button>+1</button>
              <a href="http://www.baidu.com">百度一下</a>
            </div>
            <div className="footer">
              <p>我是尾部的内容</p>
            </div>
          </div>
        )
        console.log(elementObj); //这里就是一个虚拟Dom（由一个js对象组成）
        return elementObj;
      }
```

##### 11.jsx不要直接操作state原数据

```react

                this.state = {
                    books: [
                        {
                            id: 1,
                            name: '《算法导论》',
                            date: '2006-9',
                            price: 85.00,
                            count: 1
                        },
                        {
                            id: 2,
                            name: '《UNIX编程艺术》',
                            date: '2006-2',
                            price: 59.00,
                            count: 1
                        },
                        {
                            id: 3,
                            name: '《编程珠玑》',
                            date: '2008-10',
                            price: 39.00,
                            count: 1
                        },
                        {
                            id: 4,
                            name: '《代码大全》',
                            date: '2006-3',
                            price: 128.00,
                            count: 1
                        },
                    ]
                }
                
 方式一：通过filter形式不会修改原数组
  this.setState({
                    books: this.state.books.filter((item, indey) => index != indey)
                })
方式二：用新的数组接受，在新数组上面修改
 changeCount(index,cooperation){
                let newBooks = [...this.state.books]
                newBooks[index].count = newBooks[index].count+cooperation
                this.setState({
                    books:newBooks
                })
            }
```

##### 12.jsx对模板的显示隐藏

```react
   //存在数据
            isExistData() {
                return (
                    <div>
                        <table>
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>书籍名称</th>
                                    <th>出版日期</th>
                                    <th>价格</th>
                                    <th>购买数量</th>
                                    <th>操作</th>
                                </tr>
                            </thead>
                            <tbody>
                                {this.state.books.map((item, index) => {
                                    return (
                                        <tr>
                                            <td>{index + 1}</td>
                                            <td>{item.name}</td>
                                            <td>{item.date}</td>
                                            <td>{item.price}</td>
                                            <td>
                                                <button onClick={() => this.changeCount(index, -1)}>-</button>
                                                <span className="count">{item.count}</span>
                                                <button onClick={() => this.changeCount(index, 1)}>+</button>
                                            </td>
                                            <td><button onClick={() => this.removeBook(index)}>移除</button></td>
                                        </tr>
                                    )
                                })}
                            </tbody>
                        </table>
                        <h2>总价：{this.getTotalPrice()}</h2>
                    </div>
                )
            }
            //不存在数据
            isNotExistData() {
                return (<h2>暂无数据！</h2>)
            }
(/*可以通过函数的形式抽离出去*/)
            render() {
                return this.state.books.length > 0 ? this.isExistData() : this.isNotExistData()
            }
```

##### 13.react脚手架

###### 13.1脚手架目录

![react目录](D:\web\note\img\react目录.png)

###### 13.2组件化开发

```
1.类组件：
组件名是大写字符开头
继承自React.Component类
组件必须包含render函数
2.使用class定义一个类组件：
	constructor是可选的，通常在constructor初始化一些数据
	this.state中维护的就是组件内部的数据
	render()方法是calss组件中唯一必须实现的方法
```

##### 14.函数式组件

```react
特点：1.没有this对象
	 2.没有内部的状态
	 
import React from 'react'

export default function App() {
    return (
        <div>
            
        </div>
    )
}

```

##### 15.render函数的返回值

![render函数的返回值](D:\web\note\img\render函数的返回值.png)

##### 16.react生命周期

###### 16.1常用生命周期函数

![react生命周期](D:\web\note\img\react\react生命周期.png)

```react
1.最先创建类要执行constrcutor,然后执行render函数渲染,当组件实例被创建并插入 DOM 中挂载完毕执行componentDidMount
2.如果修改render的相关属性，会触发componentDisUpdate
3.当组件从 DOM 中移除，最后销毁会触发componentWillUnmount()

import React, { Component } from 'react';

class Cpn extends Component {
  render() {
    return <h2>我是Cpn组件</h2>
  }

  componentWillUnmount() {
    console.log("调用了Cpn的componentWillUnmount方法");
  }
}

export default class App extends Component {

  constructor() {
    super();

    this.state = {
      counter: 0,
      isShow: true
    }

    console.log("执行了组件的constructor方法");
  }

  render() {
    console.log("执行了组件的render方法");

    return (
      <div>
        我是App组件
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <hr/>
        <button onClick={e => this.changeCpnShow()}>切换</button>
        {this.state.isShow && <Cpn/>}
      </div>
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }

  changeCpnShow() {
    this.setState({
      isShow: !this.state.isShow
    })
  }

  componentDidMount() {
    console.log("执行了组件的componentDidMount方法");
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log("执行了组件的componentDidUpdate方法");
  }
}

```

###### 16.2不常用的生命周期函数

![不常用周期函数](D:\web\note\img\react\不常用周期函数.png)

```
getDerivedStateFromProps：state 的值在任何时候都
依赖于 props时使用；该方法返回一个对象来更新state； p getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如
说滚动位置）；
p shouldComponentUpdate：该生命周期函数很常用，但是我们等待讲性能优化时再来详细讲解；
```



##### 17.组件间的通信

###### 17.1组件间的嵌套

```react
import React, { Component } from 'react'
function Header() {
    return <h2>header</h2>
}
// Main
function Banner() {
    return <h3>我是Banner组件</h3>
  }
  
  function ProductList() {
    return (
      <ul>
        <li>商品列表1</li>
        <li>商品列表2</li>
        <li>商品列表3</li>
        <li>商品列表4</li>
        <li>商品列表5</li>
      </ul>
    )
  }
function Main(){
    return (
        <div>
            <Banner />
            <ProductList/>
        </div>
    )
}
function Footer(){
    return <h2>footer</h2>
}
export default class App extends Component {

    render() {
        return (
            <div>
                <Header />
                <Main />
                <Footer />
            </div>
        )
    }
}

```

###### 17.2父传子-类组件

```react
import React, { Component } from 'react'
class Children extends Component{
    //1.这里constructor可以不用写，因为父传递过来的props默认会作为参数传递到super执行函数中传递给父级(不写的原因)
    //而父级里面又将this指向子类（这里就是子组件）所以render里面的this.props就是保存在父类的值（所以可以直接调用）
    // constructor(props){
    //     super()
    //     this.props = props
    // }
    render(){
        let {name,age} = this.props
        return(
            <h2>我叫{name}我已经{age}岁了</h2>
        )
    }
}
export default class App extends Component {
    render() {
        return (
            <div>
                <Children name="张三" age="18" />
            </div>
        )
    }
}

```

17.3父传子-函数组件

```react
import React, { Component } from 'react'
function Children(props){
    let {name,age} = props
    return(
        <h2>我叫{name}我已经{age}岁了</h2>
    )
}
export default class App extends Component {
    render() {
        return (
            <div>
                <Children name="张三" age="18" />
            </div>
        )
    }
}

```

###### 17.4父传子属性类型校验

```react
import React, { Component } from 'react'
import propTypes from 'prop-types'
function Children(props) {
    let { name, age, hobby } = props
    return (
        <div>
            <h2>我叫{name}我已经{age}岁了</h2>
            <h2>爱好</h2>
            <ul>
                {
                    hobby.map((item,index)=>{
                        return <li>{item}</li>
                    })
                }
            </ul>
        </div>

    )
}
//属性值类型验证
Children.propTypes = {
    name: propTypes.string.isRequired,//必填
    age: propTypes.number,
    hobby: propTypes.array
}
//设置默认传递属性值
Children.defaultProps={
    name:'李四',
    age:103,
    hobby:['乒乓球']
}
export default class App extends Component {
    render() {
        return (
            <div>
                <Children name="张三" age={18} hobby={['篮球','足球']}/>
                <Children age={18} hobby={['篮球','足球']}/>
                <Children/>
            </div>
        )
    }
}



//如果是类组件，除了用propTypes之外还可以用static
class ChildCpn2 extends Component {
  // es6中的class fields写法
  static propTypes = {

  }

  static defaultProps = {

  }
}
```

###### 17.5子组件传递给父组件

```react
在React中同样是通过props传递消息，只是让父组件给子组件传递一个回调函数，在子组件中调用这个函数即可

import React, { Component } from 'react';


class CounterButton extends Component {
  render() {
    const {onClick} = this.props;
    return <button onClick={onClick}>+1</button>
  }
}


export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+</button>
        <CounterButton onClick={e => this.increment()} name="why"/>
      </div>
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}

```

##### 18.react插槽的使用

```react
1.子组件填充内容，可以在子组件内通过this.props.children进行获取
2.子组件可以通过jsx绑定的形式传递，子组件内通过this.props进行获取


import React, { Component } from 'react'
import NavBar from './navBar'
import NavBar2 from './navBar2'
import './index.css'
export default class App extends Component {
    render() {
        const leftSlot = <span>左边</span>
        return (
            <div>
                <NavBar>
                    <span>左边</span>
                    <span>中间</span>
                    <span>右边</span>
                </NavBar>

                <NavBar2 leftSlot={leftSlot} rightSlot={<a href="#">右边的内容</a>} centerSlot={<span>中间的内容</span>}>
                </NavBar2>
            </div>
        )
    }
}



import React, { Component } from 'react'

export default class navBar extends Component {
    render() {
        //这里父组件内装的数据放在this.props.children中
        return (
            <div className="navBar">
                <div className="bar-left">{this.props.children[0]}</div>
                <div className="bar-center">{this.props.children[1]}</div>
                <div className="bar-right">{this.props.children[2]}</div>
            </div>
        )
    }
}




import React, { Component } from 'react'

export default class navBar extends Component {
    render() {
        let {leftSlot,centerSlot,rightSlot} = this.props
        return (
            <div className="navBar">
                <div className="bar-left">{leftSlot}</div>
                <div className="bar-center">{centerSlot}</div>
                <div className="bar-right">{rightSlot}</div>
            </div>
        )
    }
}



```

##### 19.不同组件之间的通信

###### 19.1通过props通信

```react
import React, { Component } from 'react';

function ProfileHeader(props) {
  return (
    <div>
      <h2>用户昵称: {props.nickname}</h2>
      <h2>用户等级: {props.level}</h2>
    </div>
  )
}

function Profile(props) {
  return (
    <div>
      {/* <ProfileHeader nickname={props.nickname} level={props.level}/> */}
      <ProfileHeader {...props}/>
      <ul>
        <li>设置1</li>
        <li>设置2</li>
        <li>设置3</li>
        <li>设置4</li>
      </ul>
    </div>
  )
} 

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      nickname: "kobe",
      level: 99
    }
  }

  render() {
    // const {nickname, level} = this.state;

    return (
      <div>
        <Profile {...this.state}/>
      </div>
    )
  }
}

```

###### 19.2通过context类的形式实现组件通信

```react
1.定义一个共享的context对象
2.每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化
3.挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象
4.最后contextType挂载的类，可以通过this.context使用

import React, { Component } from 'react'

//创建一个context共享
let UserContext = React.createContext({
    nickname: 'zs',
    level: '三级'
})

function Profile() {
    return (
        <div>
            <ProfileHeader></ProfileHeader>
            <ul>
                <li>设置1</li>
                <li>设置2</li>
                <li>设置3</li>
                <li>设置4</li>
            </ul>
        </div>
    )
}

class ProfileHeader extends Component {
    render() {
      console.log(this.context);
      // jsx -> 
      return (
        <div>
          <h2>用户昵称: {this.context.nickname}</h2>
          <h2>用户等级: {this.context.level}</h2>
        </div>
      )
    }
  }
  //可以给类下contextType属性指定context对象，该类可以通过this.context来消费
  ProfileHeader.contextType =UserContext

export default class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            nickname: "kobe",
            level: 101
        }
    }
    render() {
        return (
            <div>
                (/**context对象下提供Provider来包裹组件，包裹组件可以消费这个对象 */)
                <UserContext.Provider value={this.state}>
                    <Profile />
                </UserContext.Provider>

            </div>
        )
    }
}

```

###### 19.3通过context函数的形式实现组件通信

```react
1.定义一个共享的context对象
2.每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化
3.可以通过context.Consumer属性包裹，通过回调函数来获取返回值

import React, { Component } from 'react'

//创建一个context共享
let UserContext = React.createContext({
    nickname: 'zs',
    level: '三级'
})

function Profile() {
    return (
        <div>
            <ProfileHeader></ProfileHeader>
            <ul>
                <li>设置1</li>
                <li>设置2</li>
                <li>设置3</li>
                <li>设置4</li>
            </ul>
        </div>
    )
}

class ProfileHeader extends Component {
    render() {
      console.log(this.context);
      // jsx -> 
      return (
          //这里函数组件通过Consumer来指定利用一个回到的函数返回值来获取context的value
        <UserContext.Consumer>
          <h2>用户昵称: {this.context.nickname}</h2>
          <h2>用户等级: {this.context.level}</h2>
        </UserContext.Consumer>
      )
    }
  }
  //这里是指定类组件的，函数组件不用这个
//   ProfileHeader.contextType =UserContext

export default class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            nickname: "kobe",
            level: 101
        }
    }
    render() {
        return (
            <div>
                {/*context对象下提供Provider来包裹组件，包裹组件可以消费这个对象 */}
                <UserContext.Provider value={this.state}>
                    <Profile />
                </UserContext.Provider>

            </div>
        )
    }
}

```

###### 19.4多个context

```react
import React, { Component } from 'react'

//创建一个context共享
let UserContext = React.createContext({
    nickname: 'zs',
    level: '三级'
})
let ColorContext = React.createContext({
    color: 'black'
})

function Profile() {
    return (
        <div>
            <ProfileHeader></ProfileHeader>
            <ul>
                <li>设置1</li>
                <li>设置2</li>
                <li>设置3</li>
                <li>设置4</li>
            </ul>
        </div>
    )
}

function ProfileHeader() {
    return (
        //这里函数组件通过Consumer来指定利用一个回到的函数返回值来获取context的value
        <UserContext.Consumer>
            {value => {
                return (
                    <ColorContext.Consumer>
                        {
                            color => {
                                return (
                                    <div>
                                        <h2>
                                            用户昵称: {value.nickname}
                                        </h2>
                                        <h2>用户等级: {value.level}</h2>
                                        <h2>颜色:{color.color}</h2>
                                    </div>

                                )
                            }
                        }
                    </ColorContext.Consumer>
                )
            }}

        </UserContext.Consumer>
    )

}
//这里是指定类组件的，函数组件不用这个
//   ProfileHeader.contextType =UserContext

export default class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            nickname: "kobe",
            level: 101
        }
    }
    render() {
        return (
            <div>
                {/*context对象下提供Provider来包裹组件，包裹组件可以消费这个对象 */}
                <UserContext.Provider value={this.state}>
                    <ColorContext.Provider value={{color:"red"}}>
                        <Profile />
                    </ColorContext.Provider>
                </UserContext.Provider>

            </div>
        )
    }
}

```

20.setState相关

```react
1.修改值要用setState
2.setState是一个异步更新 优点：1.可以显著提高效率（获取多个更新，之后批量更新）2.如果同步更新了state，有可能state和props不能保持同步，所以是异步更新
3.获取异步更新的state值
// 方式一: 获取异步更新后的数据
    // setState(更新的state, 回调函数)
    this.setState({
      message: "你好啊,李银河"
    }, () => {
      console.log(this.state.message);
    })
//方式二：生命周期更新事件中
  componentDidUpdate() {
    // 方式二: 获取异步更新的state
    console.log(this.state.message);
  }

4.setState不一定都是异步
在组件生命周期或React合成事件中，setState是异步； 
在setTimeout或者原生dom事件中，setState是同步

5.setState数据会发生合并
import React, { Component } from 'react';

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      message: "Hello World",
      name: "coderwhy"
    }
  }

  render() {
    return (
      <div>
        <h2>{this.state.message}</h2>
        <h2>{this.state.name}</h2>
        <button onClick={e => this.changeText()}>改变文本</button>
      </div>
    )
  }

  changeText() {
    this.setState({
      message: "你好啊,李银河"//这里没有name但是赋值后的name依然存在
    });

    // Object.assign({}, this.state, {message: "你好啊,李银河"})
  }
}
6.setState可以自己多次调用会合并
import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
      </div>
    )
  }

  increment() {
    // 1.setState本身被合并
    // this.setState({
    //   counter: this.state.counter + 1
    // });
    // this.setState({
    //   counter: this.state.counter + 1
    // });
    // this.setState({
    //   counter: this.state.counter + 1
    // });

    // 2.setState合并时进行累加
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1
      }
    });
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1
      }
    });
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1
      }
    });
  }
}


```

##### 20.key的作用

```
react列表渲染时，新值会一次从列表当中去比较，这样会照成性能损耗

在默认条件下，当递归 DOM 节点的子元素时，React 会同
时遍历两个子元素的列表；当产生差异时，生成一个
mutation。 
1.我们来看一下在最后插入一条数据的情况： p 前面两个比较是完全相同的，所以不会产生mutation；
最后一个比较，产生一个mutation，将其插入到新的DOM树中即可；

但是如果我们是在中间插入一条数据：
2.React会对每一个子元素产生一个mutation，而不是保 持 <li>星际穿越</li>和<li>盗梦空间</li>的不变；
这种低效的比较方式会带来一定的性能问题；
```

##### 21.render的渲染

```react
1.嵌套组件，如果主组件更新，嵌套组件也会发生更新
2.只要state或props数据发生改变，就会更新
```

###### 21.1shouldComponentUpdate处理

```react
1. React给我们提供了一个生命周期方法 shouldComponentUpdate（很多时候，我们简称为SCU），这个方法接受参数，并且
需要有返回值： n 该方法有两个参数：
p 参数一：nextProps 修改之后，最新的props属性
p 参数二：nextState 修改之后，最新的state属性
n 该方法返回值是一个boolean类型 p 返回值为true，那么就需要调用render方法； p 返回值为false，那么久不需要调用render方法； p 默认返回的是true，也就是只要state发生改变，就会调用render方法
import React, {Component} from 'react';

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
      message: "Hello World"
    }
  }

  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <button onClick={e => this.changeText()}>改变文本</button>
      </div>
    )
  }
  //这个函数如果返回true就是要render渲染，false就不渲染，但是这样的缺点就是每一个组件都需要去定义这个生命周期函数
  shouldComponentUpdate(nextProps, nextState) {
    if (this.state.counter !== nextState.counter) {
      return true;
    }
    
    return false;
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }

  changeText() {
    this.setState({
      message: "你好啊,李银河"
    })
  }
}

```

###### 12.2 PureComponent处理类组件更新

```react
2.只要将class继承PureComponent组件，这样继承这个组件得就不需要更新render
import React, { PureComponent } from 'react';

// Header
function Header() {
  console.log("Header被调用");
  return <h2>我是Header组件</h2>
}

// Main
class Banner extends PureComponent {
  render() {
    console.log("Banner render函数被调用");
    return <h3>我是Banner组件</h3>
  }
}

function ProductList() {
  console.log("ProductList被调用");
  return (
    <ul>
      <li>商品列表1</li>
      <li>商品列表2</li>
      <li>商品列表3</li>
      <li>商品列表4</li>
      <li>商品列表5</li>
    </ul>
  )
}

class Main extends PureComponent {
  render() {
    console.log("Main render函数被调用");
    return (
      <div>
        <Banner/>
        <ProductList/>
      </div>
    )
  }
}

// Footer
function Footer() {
  console.log("Footer被调用");
  return <h2>我是Footer组件</h2>
}


export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <Header/>
        <Main/>
        <Footer/>
      </div>
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}

```

###### 12.3  mome处理函数组件更新

```react
3.如果是函数组件那么不渲染需要mome
import React, { PureComponent, memo } from 'react';

// Header
const MemoHeader = memo(function Header() {
  console.log("Header被调用");
  return <h2>我是Header组件</h2>
})


// Main
class Banner extends PureComponent {
  render() {
    console.log("Banner render函数被调用");
    return <h3>我是Banner组件</h3>
  }
}

const MemoProductList = memo(function ProductList() {
  console.log("ProductList被调用");
  return (
    <ul>
      <li>商品列表1</li>
      <li>商品列表2</li>
      <li>商品列表3</li>
      <li>商品列表4</li>
      <li>商品列表5</li>
    </ul>
  )
})

class Main extends PureComponent {
  render() {
    console.log("Main render函数被调用");
    return (
      <div>
        <Banner/>
        <MemoProductList/>
      </div>
    )
  }
}

// Footer
const MemoFooter = memo(function Footer() {
  console.log("Footer被调用");
  return <h2>我是Footer组件</h2>
})


export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <MemoHeader/>
        <Main/>
        <MemoFooter/>
      </div>
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}


```

##### 22.setState数据的不可变性

```react
import React, { PureComponent } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    // 引用类型
    this.state = {
      friends: [
        { name: "lilei", age: 20 },
        { name: "lily", age: 25 },
        { name: "lucy", age: 22 }
      ]
    }
  }

  // shouldComponentUpdate(newProps, newState) {
  //   if (newState.friends !== this.state.friends) {
  //     return true;
  //   }

  //   return false;
  // }

  render() {
    return (
      <div>
        <h2>好友列表:</h2>
        <ul>
          {
            this.state.friends.map((item, index) => {
              return (
                <li key={item.name}>
                  姓名: {item.name} 
                  年龄: {item.age}
                  <button onClick={e => this.incrementAge(index)}>age+1</button>
                </li>
              )
            })
          }
        </ul>
        <button onClick={e => this.insertData()}>添加数据</button>
      </div>
    )
  }

  insertData() {
    // 1.在开发中不要这样来做
    // const newData = {name: "tom", age: 30}
    // this.state.friends.push(newData);
    // this.setState({
    //   friends: this.state.friends
    // });

    // 2.推荐做法
    const newFriends = [...this.state.friends];
    newFriends.push({ name: "tom", age: 30 });
    this.setState({
      friends: newFriends
    })
  }

  incrementAge(index) {
    const newFriends = [...this.state.friends];
    newFriends[index].age += 1;
    this.setState({
      friends: newFriends
    })
  }
}

```

##### 23.全局事件传递

```react
yarn install event

import React, { PureComponent } from 'react';

import { EventEmitter } from 'events';

// 事件总线: event bus
const eventBus = new EventEmitter();

class Home extends PureComponent {
  componentDidMount() {
    eventBus.addListener("sayHello", this.handleSayHelloListener);
  }

  componentWillUnmount() {
    eventBus.removeListener("sayHello", this.handleSayHelloListener);
  }

  handleSayHelloListener(num, message) {
    console.log(num, message);
  }

  render() {
    return (
      <div>
        Home

      </div>
    )
  }
}

class Profile extends PureComponent {
  render() {
    return (
      <div>
        Profile
        <button onClick={e => this.emmitEvent()}>点击了profile按钮</button>
      </div>
    )
  }

  emmitEvent() {
    eventBus.emit("sayHello", 123, "Hello Home");
  }
}

export default class App extends PureComponent {
  render() {
    return (
      <div>
        <Home/>
        <Profile/>
      </div>
    )
  }
}


```

##### 24.ref的使用

```react
import React, { Component, createRef } from 'react'

class Counter extends Component {
    constructor(props){
        super(props)
        this.state = {
            counter:0
        }
    }
    render() {
        return (
            <div>
                <h2>当前计数: {this.state.counter}</h2>
                <button onClick={e => this.increment()}>+1</button>
            </div>
        )
    }
    increment(){
        this.setState({
            counter:this.state.counter+1
        })
    }
}

export default class App extends Component {
    constructor(props) {
        super(props)
        this.titleRef = createRef() //创建一个ref容器
        this.titleEl = null;

        this.CounterRef = createRef()
    }
    render() {
        return (
            <div>
                {/* // ref方式一 */}
                <h2 ref="titleRef">React Hello</h2>
                {/*方式二 目前React推荐的方式 */}
                <h2 ref={this.titleRef}>React Hello</h2>
                {/* 方式三: 回调函数方式  agrs就是获取的dom元素*/}
                <h2 ref={agrs => this.titleEl = agrs}>React Hello</h2>
                <button onClick={e => { this.changeText() }}>改变文本</button>


                <Counter ref={this.CounterRef} />
                <button onClick={e => { this.changeNum() }}>改变数量</button>
            </div>
        )
    }
    changeText() {
        // ref方式一
        this.refs.titleRef.innerHTML = 'React Hello1'
        //ref方式二
        this.titleRef.current.innerHTML = 'React Hello2'
        // 3.使用方式三: 回调函数方式
        this.titleEl.innerHTML = "Hello TypeScript";
    }
    changeNum(){
        //父组件通过ref调用子组件的方法
        this.CounterRef.current.increment()
    }
}

```

##### 25.控件事件的使用

```react
import React, { Component } from 'react'

export default class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            username: ""
        }
    }
    render() {
        return (
            <div>
                <form onSubmit={e => this.handleSubmit(e)}>
                    <label htmlFor="username">
                        <input type="text" id="username" onChange={e => this.handleChange(e)} value={this.state.username} />
                    </label>
                    <input type="submit" value="提交" />
                </form>
            </div>
        )
    }
    handleSubmit(event) {
        //阻止默认事件
        event.preventDefault();
    }
    handleChange(event) {
        this.setState({                                                                                          
            username: event.target.value
        })
    }
}
```

##### 26.高阶组件

```react
import React, { PureComponent } from 'react'

class App extends PureComponent {
  render() {
    return (
      <div>
        App: {this.props.name}
      </div>
    )
  }
}

function enhanceComponent(WrappedComponent) {
  class NewComponent extends PureComponent {
    render() {
      return <WrappedComponent {...this.props}/>
    }
  }

  NewComponent.displayName = "Kobe";
  return NewComponent;
}

function enhanceComponent2(WrappedComponent) {
  function NewComponent(props) {
    return <WrappedComponent {...props}/>
  }

  NewComponent.displayName = "Kobe";
  return NewComponent;
}

const EnhanceComponent = enhanceComponent2(App);

export default EnhanceComponent;


```

##### 27.ref的补充 *forwardRef*

```react
由于函数组件不能直接通过ref来获取，如果想要获取函数组件里的内容，需要forwardRef来进行一个转发

import React, { PureComponent, createRef, forwardRef } from 'react';

class Home extends PureComponent {
  render() {
    return <h2>Home</h2>
  }
}

// 高阶组件forwardRef
const Profile = forwardRef(function(props, ref) {
  return <p ref={ref}>Profile</p>
})

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.titleRef = createRef();
    this.homeRef = createRef();
    this.profileRef = createRef();
  }

  render() {
    return (
      <div>
        <h2 ref={this.titleRef}>Hello World</h2>
        <Home ref={this.homeRef}/>

        <Profile ref={this.profileRef} name={"why"}/>

        <button onClick={e => this.printRef()}>打印ref</button>
      </div>
    )
  }

  printRef() {
    console.log(this.titleRef.current);
    console.log(this.homeRef.current);
    console.log(this.profileRef.current);
  }
}

```

##### 28.portals的使用

```react
//子组件独立于父组件
import React, { PureComponent } from 'react';
import ReactDOM from 'react-dom';

class Modal extends PureComponent {
  render() {
      //这里接受两个参数一个是节点，另一个是挂载的dom
    return ReactDOM.createPortal(
      this.props.children,
      document.getElementById("modal")
    )
  }
}

class Home extends PureComponent {
  render() {
    return (
      <div>
        <h2>Home</h2>
        <Modal>
          <h2>Title</h2>
        </Modal>
      </div>
    )
  }
}

export default class App extends PureComponent {
  render() {
    return (
      <div>
        <Home/>
      </div>
    )
  }
}

```





##### 33.redux的定义

```react
1.首先要定义一个创建一个store来管理
import redux from 'redux';
import reducer from './reducer.js';
const store = redux.createStore(reducer);//这里就使用reducer，当store dispatch的时候就是去调用reducer
export default store;

2.创建action通过action来定义改变store的方式
一个action的形式:{type: ADD_NUMBER, num}

import {
  ADD_NUMBER,
  SUB_NUMBER,
  INCREMENT,
  DECREMENT
} from './constants.js';

export const addAction = num => ({
  type: ADD_NUMBER,
  num
});

export const subAction = num => ({
  type: SUB_NUMBER,
  num
});

export const incAction = () => ({
  type: INCREMENT
});

export const decAction = () => ({
  type: DECREMENT
});

3.通过reducer来建立state与action的联系  创建reducer
import {
  ADD_NUMBER,
  SUB_NUMBER,
  INCREMENT,
  DECREMENT
} from './constants.js';

const defaultState = {
  counter: 0
}
//这里state参数就是状态管理的state，如果调用reducer的state为空就赋值一个初始值，action就是执行的action
function reducer(state = defaultState, action) {
  switch (action.type) {
    case ADD_NUMBER:
      return { ...state, counter: state.counter + action.num };
    case SUB_NUMBER:
      return { ...state, counter: state.counter - action.num };
    case INCREMENT:
      return { ...state, counter: state.counter + 1 };
    case DECREMENT:
      return { ...state, counter: state.counter - 1 };
    default:
      return state;
  }
}
4.store.subscribe是用来监听store发生变化时调用
store.subscribe(() => {
  console.log(store.getState());
})

export default reducer;

5.//最后使用redux
import store from './store/index.js';

import {
  addAction,
  subAction,
  incAction,
  decAction
} from './store/actionCreators.js';

store.subscribe(() => {
  console.log(store.getState()); //获取state的数据
})

store.dispatch(addAction(10));
store.dispatch(addAction(15));
store.dispatch(subAction(8));
store.dispatch(subAction(5));
store.dispatch(incAction());
store.dispatch(decAction());


```

###### 33.1redux结合react

```react
import React, { useState, useEffect } from 'react'
import store from '../store/index'
import { addAction, subAction } from '../store/createAction'
export default function About() {
    const [counter, setCounter] = useState(store.getState().counter)
    const AddCount = (num) => {
        store.dispatch(addAction(num));
        console.log('sss')
    }
    const SubCount = (num) => {
        store.dispatch(subAction(num));
        console.log('sss')
    }
   
    useEffect(() => {
       let unsubscribe = store.subscribe(() => {
            setCounter(store.getState().counter)
        })
        return ()=>{
            unsubscribe()
        }
    })
    return (
        <div>
            <h2>Home:</h2>{counter}
            <button onClick={()=>{AddCount(3)}}>+1</button>
            <button onClick={()=>{SubCount(3)}}>-1</button>
        </div>
    )
}

```

###### 33.2自定义redux-connect初使用

```react
1.建立一个共享的context
import React from 'react'
const StoreContext = React.createContext()
//导出一个共享context
export {
    StoreContext
}
2.在index.js中使用，共享store
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { StoreContext } from './utils/context';
import store from './store/index'
ReactDOM.render(
  <StoreContext store={store}>
    <App />
  </StoreContext>,
  document.getElementById('root')
);

3.定义一个connect
import React, { PureComponent } from "react";

import { StoreContext } from './context';

export function connect(mapStateToProps, mapDispachToProp) {
    return function enhanceHOC(WrappedComponent) {
        class EnhanceComponent extends PureComponent {
            //通过context共享的stroe东西
            constructor(props, context) {
                super(props, context);

                this.state = {
                    storeState: mapStateToProps(context.getState())
                }
            }
			//包裹connect的组件通过dispatch操作store后，会执行更新connect包裹的组件，实现更新
            componentDidMount() {
                this.unsubscribe = this.context.subscribe(() => {
                    this.setState({
                        storeState: mapStateToProps(this.context.getState())
                    })
                })
            }

            componentWillUnmount() {
                this.unsubscribe();
            }

            render() {
                //返回这个组件，这个组件里面就可以通过props接收
                return <WrappedComponent {...this.props}
                    {...mapStateToProps(this.context.getState())}
                    {...mapDispachToProp(this.context.dispatch)} />
            }
        }

        EnhanceComponent.contextType = StoreContext;

        return EnhanceComponent;
    }
}
4.使用connect 
import React, { PureComponent } from 'react';

import {connect} from '../utils/connect';
import {
  incAction,
  addAction
} from '../store/actionCreators'

class Home extends PureComponent {
  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={e => this.props.increment()}>+1</button>
        <button onClick={e => this.props.addNumber(5)}>+5</button>
      </div>
    )
  }
}

const mapStateToProps = state => ({
  counter: state.counter
})

const mapDispatchToProps = dispatch => ({
  increment() {
    dispatch(incAction());
  },
  addNumber(num) {
    dispatch(addAction(num));
  }
})

export default connect(mapStateToProps, mapDispatchToProps)(Home);

```

###### 33.3使用官方connect

```react
1.导入东西有变
import React from 'react';
import ReactDOM from 'react-dom';
import store from './store';
import { Provider } from 'react-redux';

import App from './App';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
2.使用connect有变
import React, { PureComponent } from 'react';

// import {connect} from '../utils/connect';
import { connect } from 'react-redux';

import axios from 'axios';

import {
  incAction,
  addAction,
  changeBannersAction,
  changeRecommendAction
} from '../store/actionCreators'

class Home extends PureComponent {
  componentDidMount() {
     //异步获取数据
    axios({
      url: "http://123.207.32.32:8000/home/multidata",
    }).then(res => {
      const data = res.data.data;
      this.props.changeBanners(data.banner.list);
      this.props.changeRecommends(data.recommend.list);
    })
  }

  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={e => this.props.increment()}>+1</button>
        <button onClick={e => this.props.addNumber(5)}>+5</button>
      </div>
    )
  }
}

const mapStateToProps = state => ({
  counter: state.counter
})

const mapDispatchToProps = dispatch => ({
  increment() {
    dispatch(incAction());
  },
  addNumber(num) {
    dispatch(addAction(num));
  },
  changeBanners(banners) {
    dispatch(changeBannersAction(banners));
  },
  changeRecommends(recommends) {
    dispatch(changeRecommendAction(recommends));
  }
})

export default connect(mapStateToProps, mapDispatchToProps)(Home);

```

###### 33.4 redux-thunk处理异步

![image-20211201220927737](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20211201220927737.png)

```react
1.为了异步请求能够暴露在redux内部，这里需要运用中间件思想
默认情况下的dispatch(action)，action需要是一个JavaScript的对象；
redux-thunk可以让dispatch(action函数)，action可以是一个函数；
该函数会被调用，并且会传给这个函数一个dispatch函数和getState函数；dispatch函数用于我们之后再次派发action；
getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态

2.创建store时接受第二个参数
import { createStore, applyMiddleware, compose } from 'redux';
import thunkMiddleware from 'redux-thunk';
import reducer from './reducer.js';
// 应用一些中间件
// 1.引入thunkMiddleware中间件(上面)
const storeEnhancer = applyMiddleware(thunkMiddleware);
const store = createStore(reducer, storeEnhancer);
export default store;

3.创建action里面定义的action就返回一个函数，接受两个参数，重儿实现异步
// redux-thunk中定义的action函数
export const getHomeMultidataAction = (dispatch, getState) => {
  axios({
    url: "http://123.207.32.32:8000/home/multidata",
  }).then(res => {
    const data = res.data.data;
    dispatch(changeBannersAction(data.banner.list));
    dispatch(changeRecommendAction(data.recommend.list));
  })
}

4.调用异步action
import React, { PureComponent } from 'react';

// import {connect} from '../utils/connect';
import { connect } from 'react-redux';


import {
  incAction,
  addAction,
  getHomeMultidataAction
} from '../store/actionCreators'

class Home extends PureComponent {
  componentDidMount() {
    this.props.getHomeMultidata();
  }

  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={e => this.props.increment()}>+1</button>
        <button onClick={e => this.props.addNumber(5)}>+5</button>
      </div>
    )
  }
}

const mapStateToProps = state => ({
  counter: state.counter
})

const mapDispatchToProps = dispatch => ({
  increment() {
    dispatch(incAction());
  },
  addNumber(num) {
    dispatch(addAction(num));
  },
    //调用异步action
  getHomeMultidata() {
    dispatch(getHomeMultidataAction);
  }
})

export default connect(mapStateToProps, mapDispatchToProps)(Home);


```

###### 33.5redux-devtools工具的使用

```react
浏览器添加devtools后
1.添加一个composeEnhancers
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({trace: true}) || compose;
2.在createStore里面调用composeEnhancers
import { createStore, applyMiddleware, compose } from 'redux';
import thunkMiddleware from 'redux-thunk';
import createSagaMiddleware from 'redux-saga';

import saga from './saga';
import reducer from './reducer.js';

// composeEnhancers函数
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({trace: true}) || compose;

// 应用一些中间件
// 1.引入thunkMiddleware中间件(上面)
// 2.创建sagaMiddleware中间件
const sagaMiddleware = createSagaMiddleware();

const storeEnhancer = applyMiddleware(thunkMiddleware, sagaMiddleware);

const store = createStore(reducer, composeEnhancers(storeEnhancer));

sagaMiddleware.run(saga); 

export default store;

这样就可以在浏览器开发模式中看到数据了
```

###### 33.6generator的认识

```react
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    // generator: 生成器
    // 1.普通函数
    // function foo() {
    //   console.log("foo被执行");
    // }

    // foo();
    // 2.生成器函数的定义
    // 生成器函数
    function* foo() {
      console.log("111");
      yield "Hello";
      console.log("222");
      yield "World";
      console.log("333");
      yield "coderwhy";
      console.log("444");
    }

    // iterator: 迭代器
    const result = foo();
    console.log(result);

    // 3.使用迭代器
    // 调用一次next, 就会消耗一次迭代器
    // const res1 = result.next();
    // console.log(res1);
    // const res2 = result.next();
    // console.log(res2);
    // const res3 = result.next();
    // console.log(res3);
    // const res4 =result.next();
    // console.log(res4);

    // 4.生成器函数中代码的执行顺序

    // 5.练习: 定义一个生成器函数, 依次可以生成1~10的数字
    function* generateNumber() {
      for (var i = 1; i <= 10; i++) {
        yield i;
      }
    }

    // const numIt = generateNumber();
    // console.log(numIt.next().value);

    // 6.generator和Promise一起来使用
    function* bar() {
      console.log("1111");
      const result = yield new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("Hello Generator");
        }, 3000);
      });
      console.log(result);
    }

    const it = bar();
    it.next().value.then(res => {
       //走到这里在.next就是对result赋值，执行console
      it.next(res)
    })

    (preValue = 0, item) => {};
    (preState = defaultState, action) => {};

    ["abc", "cba"].reduce((preValue, item) => {}, 0)

  </script>
</body>

</html>
```

###### 33.6redux-sage

```react
1.安装
yarn add redux-saga
2.导入创建中间件的函数
import createSagaMiddleware from 'redux-saga';
3.创建sagaMiddleware中间件
const sagaMiddleware = createSagaMiddleware();
4.使用中间件  applyMiddleware可以传入多个中间件
const storeEnhancer = applyMiddleware(thunkMiddleware, sagaMiddleware);
5.store中使用
const store = createStore(reducer, composeEnhancers(storeEnhancer));
6.运行定义的saga
sagaMiddleware.run(saga);

//代码
import { createStore, applyMiddleware, compose } from 'redux';
import thunkMiddleware from 'redux-thunk';
import createSagaMiddleware from 'redux-saga';

import saga from './saga';
import reducer from './reducer.js';

// composeEnhancers函数
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true }) || compose;

// 应用一些中间件
// 1.引入thunkMiddleware中间件(上面)
// 2.创建sagaMiddleware中间件
const sagaMiddleware = createSagaMiddleware();

const storeEnhancer = applyMiddleware(thunkMiddleware, sagaMiddleware);
const store = createStore(reducer, composeEnhancers(storeEnhancer));

sagaMiddleware.run(saga);

export default store;

//saga的编写
import { takeEvery, put, all, takeLatest } from 'redux-saga/effects';
import axios from 'axios';
import {
  FETCH_HOME_MULTIDATA, ADD_NUMBER
} from './constants';
import {
  changeBannersAction,
  changeRecommendAction
} from './actionCreators';

function* fetchHomeMultidata(action) {
  const res = yield axios.get("http://123.207.32.32:8000/home/multidata");
  const banners = res.data.data.banner.list;
  const recommends = res.data.data.recommend.list;
  // yield put(changeBannersAction(banners));
  // yield put(changeRecommendAction(recommends));
  yield all([
    yield put(changeBannersAction(banners)),
    yield put(changeRecommendAction(recommends))
  ])
}

function* mySaga() {
  // takeLatest takeEvery区别:
  // takeLatest: 依次只能监听一个对应的action
  // takeEvery: 每一个都会被执行
    ///这里是监听action如果是ADD_NUMBER，就执行fetchHomeMultidata迭代从而调用对应的action
  yield all([
    takeLatest(FETCH_HOME_MULTIDATA, fetchHomeMultidata),
    // takeLatest(ADD_NUMBER, fetchHomeMultidata),
  ]);
}

export default mySaga;
```

###### 33.7redux-hooks

```react
1.mapStateToProps=====>useSelector
2.mapDispatchToProps====>useDispatch


import { connect, shallowEqual, useDispatch, useSelector } from 'react-redux'
//state
const { topBanners } = useSelector((state) => ({
        topBanners: state.recommend.topBanners
    }),shallowEqual)
//dispatch
    const dispatch = useDispatch()
    useEffect(() => {
        dispatch(getTopBannerAction())
 }, [dispatch])
```





##### 36.react hooks

###### 36.1react的使用

```react
import React, { useState } from 'react';

export default function CounterHook() {
  /**
   * Hook: useState
   *  > 本身是一个函数, 来自react包
   *  > 参数和返回值
   *    1.参数: 作用是给创建出来的状态一个默认值
   *    2.返回值: 数组
   *      * 元素1: 当前state的值
   *      * 元素2: 设置新的值时,使用的一个函数
   */
  const arr = useState(0);
  const state = arr[0];
  const setState = arr[1];

  return (
    <div>
      <h2>当前计数: {state}</h2>
      <button onClick={e => setState(state + 1)}>+1</button>
      <button onClick={e => setState(state - 1)}>-1</button>
    </div>
  )
}


import React, {useState} from 'react';

export default function CounterHook() {
  const [count, setCount] = useState(() => 10);

  console.log("CounterHook渲染");

  function handleBtnClick() {
    // setCount(count + 10);
    // setCount(count + 10);//这里setCount会合并
    // setCount(count + 10);
    // setCount(count + 10);
    setCount((prevCount) => prevCount + 10);
    setCount((prevCount) => prevCount + 10);
    setCount((prevCount) => prevCount + 10);
    setCount((prevCount) => prevCount + 10);
  }

  return (
    <div>
      <h2>当前计数: {count}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
      <button onClick={e => setCount((prevCount) => prevCount + 10)}>+10</button>
      <button onClick={handleBtnClick}>+10</button>
      <button onClick={e => setCount(count - 1)}>-1</button>
    </div>
  )
}

```

###### 36.2react修改复杂数据

```react
import React, { useState } from 'react'

export default function ComplexHookState() {

  const [friends, setFrineds] = useState(["kobe", "lilei"]);
  const [students, setStudents] = useState([
    { id: 110, name: "why", age: 18 },
    { id: 111, name: "kobe", age: 30 },
    { id: 112, name: "lilei", age: 25 },
  ])

  function addFriend() {
    friends.push("hmm");
    setFrineds(friends);
  }

  function incrementAgeWithIndex(index) {
    const newStudents = [...students];
    newStudents[index].age += 1;
    setStudents(newStudents);
  }

  return (
    <div>
      <h2>好友列表:</h2>
      <ul>
        {
          friends.map((item, index) => {
            return <li key={index}>{item}</li>
          })
        }
      </ul>
      <button onClick={e => setFrineds([...friends, "tom"])}>添加朋友</button>
      {/* 错误的做法 */}
      <button onClick={addFriend}>添加朋友</button>

      <h2>学生列表</h2>
      <ul>
        {
          students.map((item, index) => {
            return (
              <li key={item.id}>
                <span>名字: {item.name} 年龄: {item.age}</span>
                <button onClick={e => incrementAgeWithIndex(index)}>age+1</button>
              </li>
            )
          })
        }
      </ul>
    </div>
  )
}

```

###### 36.3 Effect Hook

```
Effect Hook 可以让你来完成一些类似于class中生命周期的功能,类似于网络请求、手动更新DOM、一些事件的监听，都是React更新DOM的一些副作用（Side Effects）,所以对于完成这些功能的Hook被称之为 Effect Hook
```

###### 36.4 Effext Hook的useEffect

```react
useEffect默认接受两个参数，一个是一个函数（React执行完更新DOM操作之后，就会回调这个函数。无论是第一次渲染之后，还是每次更新之后，都会执行这个 回调函数），一个是数组（默认第二传递一个空数组，在重新渲染的时候不会去调用这个回调函数,如果数组里面指定了某个state就是指当指定的state发生改变时才执行回调）
import React, { useEffect, useState } from 'react'

export default function EffectHookCancelDemo() {

  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("订阅一些事件");

    return () => {
      console.log("取消订阅事件")
    }
  }, []);

  return (
    <div>
      <h2>EffectHookCancelDemo</h2>
      <h2>{count}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
    </div>
  )
}

```

###### 36.5 useEffect使用多个

```react
import React, { useState, useEffect } from 'react'

export default function MultiEffectHookDemo() {
  const [count, setCount] = useState(0);
  const [isLogin, setIsLogin] = useState(true);

  useEffect(() => {
    console.log("修改DOM", count);
  }, [count]);  //这里指count发生改变时才执行回调

  useEffect(() => {
    console.log("订阅事件");
  }, []); //这里指任何时候都不发生回调，只执行第一次

  useEffect(() => {
    console.log("网络请求");
  }, []);

  return (
    <div>
      <h2>MultiEffectHookDemo</h2>
      <h2>{count}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
      <h2>{isLogin ? "coderwhy": "未登录"}</h2>
      <button onClick={e => setIsLogin(!isLogin)}>登录/注销</button>
    </div>
  )
}

```

###### 36.6 userContext在hooks中的使用

App.js定义context

```react
import React, { useState, createContext } from 'react';
import ContextHookDemo from './04_useContext使用/useContext的使用';


export const UserContext = createContext();
export const TokenContext = createContext();

export const ThemeContext = createContext();

export default function App() {
  const [show, setShow] = useState(true);

  return (
    <div>
    

      {/* 4.useContext */}
       <UserContext.Provider value={{name: "why", age: 18}}>
        <ThemeContext.Provider value={{fontSize: "30px", color: "red"}}>
          <ContextHookDemo/>
        </ThemeContext.Provider>
      </UserContext.Provider> 

     
  )
}
```

ContextHookDemo

```react
//导入useContext并引用对应的context
import React, { useContext } from 'react';

import { UserContext, ThemeContext } from "../App";

export default function ContextHookDemo(props) {
  const user = useContext(UserContext);
  const theme = useContext(ThemeContext);

  console.log(user, theme);

  return (
    <div>
      <h2>ContextHookDemo</h2>
    </div>
  )
}

```

###### 36.7 useReducer（不常用）

```react
在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分； 
或者这次修改的state需要依赖之前的state时，也可以使用

//1.
import React, { useReducer } from 'react';

import reducer from './reducer';

export default function Profile() {
  // const [count, setCount] = useState(0);
  const [state, dispatch] = useReducer(reducer, { counter: 0 });

  return (
    <div>
      <h2>Profile当前计数: {state.counter}</h2>
      <button onClick={e => dispatch({ type: "increment" })}>+1</button>
      <button onClick={e => dispatch({ type: "decrement" })}>-1</button>
    </div>
  )
}
//2.export default function reducer(state, action) {
  switch(action.type) {
    case "increment":
      return {...state, counter: state.counter + 1};
    case "decrement":
      return {...state, counter: state.counter - 1};
    default:
      return state;
  }
}

```

###### 36.8 userCallback优化（不常用）

```react
import React, {useState, useCallback, memo} from 'react';

/**
 * useCallback在什么时候使用?
 * 场景: 在将一个组件中的函数, 传递给子元素进行回调使用时, 使用useCallback对函数进行处理.
 */

const HYButton = memo((props) => {
  console.log("HYButton重新渲染: " + props.title);
  return <button onClick={props.increment}>HYButton +1</button>
});

export default function CallbackHookDemo02() {
  console.log("CallbackHookDemo02重新渲染");

  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);
  //当点击show切换时由于useCallback指定了依赖，所以只有count改变时，HYButton属性才会改变，组件才会刷新
  const increment1 = () => {
    console.log("执行increment1函数");
    setCount(count + 1);
  }
	//useCallback只能是一个函数
  const increment2 = useCallback(() => {
    console.log("执行increment2函数");
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <h2>CallbackHookDemo01: {count}</h2>
      {/* <button onClick={increment1}>+1</button>
      <button onClick={increment2}>+1</button> */}
      <HYButton title="btn1" increment={increment1}/>
      <HYButton title="btn2" increment={increment2}/>

      <button onClick={e => setShow(!show)}>show切换</button>
    </div>
  )
}

```

###### 36.9useMemo的使用（不常用，也是用于性能优化）

```react

useMemo定义：返回一个memoized值，将创建的函数和依赖项数组作为参数传入useMemo，它仅会在某个依赖项改变时才重新计算memoized

//1.第一个作用：复杂计算的应用
//点击show切换不会执行calcNumber函数，因为用了useMemo
import React, {useState, useMemo} from 'react';

    function calcNumber(count) {
      console.log("calcNumber重新计算");
      let total = 0;
      for (let i = 1; i <= count; i++) {
        total += i;
      }
      return total;
    }

export default function MemoHookDemo01() {
  const [count, setCount] = useState(10);
  const [show, setShow] = useState(true);

  // const total = calcNumber(count);
  const total = useMemo(() => {
    return calcNumber(count);
  }, [count]);

  return (
    <div>
      <h2>计算数字的和: {total}</h2>
      <button onClick={e => setCount(count + 1)}>+1</button>
      <button onClick={e => setShow(!show)}>show切换</button>
    </div>
  )
}


//第二个作用：传入子组件应用类型
//当传递给子组件的对象用useMemo后，切换show该改变state不会引起重新渲染
import React, { useState, memo, useMemo } from 'react';

const HYInfo = memo((props) => {
  console.log("HYInfo重新渲染");
  return <h2>名字: {props.info.name} 年龄: {props.info.age}</h2>
});

export default function MemoHookDemo02() {
  console.log("MemoHookDemo02重新渲染");
  const [show, setShow] = useState(true);

  // const info = { name: "why", age: 18 };
  const info = useMemo(() => {
    return { name: "why", age: 18 };
  }, []);

  return (
    <div>
      <HYInfo info={info} />
      <button onClick={e => setShow(!show)}>show切换</button>
    </div>
  )
}

```

无限循环的产生

```react
import { useEffect } from "react";
import "./styles.css";
//这样不会产生无限循环，只会挂载的时候执行一次
export default function App() {
  const obj = {name:'zs'}
  useEffect(()=>{
    console.log('eeee')
  },[obj])
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}


import { useEffect, useState } from "react";
import "./styles.css";

//会产生无限循环
export default function App() {
   //setNum后组件会重新加载，obj是一个对象，引用地址不一样，useEffect依赖发生改变，会一直执行setNum
  const obj = { name: "zs" };
  const [num, setNum] = useState(0);
  useEffect(() => {
    console.log("eeee");
    setNum(num + 1);
  }, [obj]);
  return (
    <div className="App">
      {num}
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}


结论：基本类型，可以放到依赖里；组件状态（useState），可以放到依赖里，非组件状态（【】，{}），不能放到依赖里
```



###### 36.10 useRef

```react
//定义：用于引用Dom元素
import React, { useEffect, useRef } from 'react';

class TestCpn extends React.Component {
  render() {
    return <h2>TestCpn</h2>
  }
}

function TestCpn2(props) {
  return <h2>TestCpn2</h2>
}

export default function RefHookDemo01() {

  const titleRef = useRef();
  const inputRef = useRef();
  const testRef = useRef();
  const testRef2 = useRef();

  function changeDOM() {
    titleRef.current.innerHTML = "Hello World";
    inputRef.current.focus();
    console.log(testRef.current);
    console.log(testRef2.current);
  }

  return (
    <div>
      <h2 ref={titleRef}>RefHookDemo01</h2>
      <input ref={inputRef} type="text"/>
      <TestCpn ref={testRef}/>
      <TestCpn2 ref={testRef2}/>

      <button onClick={e => changeDOM()}>修改DOM</button>
    </div>
  )
}

```

###### 36.11 forwardRef

```react
import React, { useRef, forwardRef } from 'react';

const HYInput = forwardRef((props, ref) => {
  return <input ref={ref} type="text"/>
})

export default function ForwardRefDemo() {
  const inputRef = useRef();

  return (
    <div>
      <HYInput ref={inputRef}/>
      <button onClick={e => inputRef.current.focus()}>聚焦</button>
    </div>
  )
}

```



###### 36.12 useImperativeHandle

```react
用处：如果父组件通过useRef引用子组件，那么父组件就可以完全使用子组件，这样不好，所以要用到useImperativeHandle来管理子组件的处理

import React, { useRef, forwardRef, useImperativeHandle } from 'react';

const HYInput = forwardRef((props, ref) => {
  const inputRef = useRef();
	//这个ref就是外层的ref，里面的第一个回调函数代表current,调用回调函数执行对应操作
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }), [inputRef])

  return <input ref={inputRef} type="text"/>
})

export default function UseImperativeHandleHookDemo() {
  const inputRef = useRef();

  return (
    <div>
      <HYInput ref={inputRef}/>
      <button onClick={e => inputRef.current.focus()}>聚焦</button>
    </div>
  )
}

```

36.13 useLayoutEffect

```react
useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新；
useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新

import React, { useState, useEffect, useLayoutEffect } from 'react'

export default function LayoutEffectCounterDemo() {
  const [count, setCount] = useState(10);

  useLayoutEffect(() => {
    if (count === 0) {
      setCount(Math.random() + 200)
    }
  }, [count]);

  return (
    <div>
      <h2>数字: {count}</h2>
      <button onClick={e => setCount(0)}>修改数字</button>
    </div>
  )
}

//在Dom加载完毕之前会输出很多随机数
```

###### 36.14自定义hook

```react
用useEffect把某些功能抽离出来，供其他组件使用
import React, { useEffect } from 'react';

const Home = (props) => {
  useLoggingLife("Home");
  return <h2>Home</h2>
}

const Profile = (props) => {
  useLoggingLife("Profile");
  return <h2>Profile</h2>
}

export default function CustomLifeHookDemo01() {
  useLoggingLife("CustomLifeHookDemo01");
  return (
    <div>
      <h2>CustomLifeHookDemo01</h2>
      <Home/>
      <Profile/>
    </div>
  )
}
//使用use开头就支持函数使用
function useLoggingLife(name) {
  useEffect(() => {
    console.log(`${name}组件被创建出来了`);

    return () => {
      console.log(`${name}组件被销毁掉了`);
    }
  }, []);
}



//useContext的共享
1.userHook.js
import { useContext } from "react";
import { UserContext, TokenContext } from "../App";

function useUserContext() {
  const user = useContext(UserContext);
  const token = useContext(TokenContext);

  return [user, token];
}

export default useUserContext;

2.App.js
import React, { useContext } from 'react';
import useUserContext from '../hooks/user-hook';

export default function CustomContextShareHook() {
  const [user, token] = useUserContext();
  console.log(user, token);

  return (
    <div>
      <h2>CustomContextShareHook</h2>
    </div>
  )
}



```

##### 37虚拟Dom到真实Dom

```
1.基于babel-preset-react-app把jsx转化成React.createElement()
2.执行React.createElement()方法创建jsx虚拟Dom对象
3.通过ReactDom.render()方法将虚拟Dom转化为真实Dom
```

##### 38.react路由懒加载

```react
缓解打包生成后的首屏加载的压力以及出现的延时问题，将打包的生成的文件分模块生成，可以通过路由懒加载

router:
const HYDiscover = React.lazy(() => import("@/pages/discover"));
//使用路由懒加载后，切换路由会去加载对应组件，如果组件过大放到服务器里面可能出现延迟，所以要用到Suspense来处理加载前的行为
<HashRouter>
        <HYAppHeader />
        <Suspense fallback={<div>page loading</div>}> //页面没有加载完展示对应的文字信息
          {renderRoutes(routes)}
        </Suspense>
        <HYAppFooter />
        <HYAppPlayerBar/>
 </HashRouter>
```

##### 39.reactSSR

###### 39.1react创建

```
npm install –g create-next-app
//创建项目
create-next-app next-demo
//启动
npm run dev
```

###### 39.2跳转

```react
1.服务端跳转
  <a href="/about">关于a</a>
2.前端路由条状
import Link from 'next/link'
<Link href="/about">
    关于link
 </Link>
```

###### 39.3公共处理

```react
1.通过react的插槽的方式
import React, { memo } from 'react'
import Head from 'next/head'
export default memo(function CommonLayout(props) {
    return (
        <div>
            <Head>
                <title>首页</title>
            </Head>
            <header>公共头部</header>
            <hr />
            {props.children}  //内容部分
            <hr />
            <footer>公共尾部</footer>
        </div>


    )
})

2.在_app.js插入公共部分
import '../styles/globals.css'
import Head from 'next/head'
function MyApp({ Component, pageProps }) {
    return (
        <>
            <Head>
                <title>首页</title>
            </Head>
            <header>公共头部</header>
            <hr />
            <Component {...pageProps} />

            <hr />
            <footer>公共尾部</footer>
        </>

    )
}

export default MyApp

```

###### 39.4 css创建的三种方式

```react
1.通过导入全局样式的形式
	在_app.js中引入统一进行打包
2.在模块中导入局部样式
import Link from 'next/link'
import styles from '../styles/Home.module.css'
export default function Home() {
  return (
    <div>
        <h1>home</h1>
        <a className={styles.title} href="/about">关于a</a>
        <Link href="/about">
            关于link
        </Link>
    </div>
  )
}
3.css in js
css in js有两种样式方式 styled-jsx（next默认集成了）  styled-components


styled-jsx:

import Image from 'next/image'
import Link from 'next/link'
import styles from '../styles/Home.module.css'
// import AppLayout  from './components/app-layout/index'
export default function Home() {
  return (
    <div>
        <h1>home</h1>
        <a className={styles.title} href="/about">关于a</a>
        <Link href="/about">
            关于link
        </Link>
        <p>styled-jsx</p>
        <style>
            {
                `p{
                    color:blue
                }`
            }
        </style>
    </div>
  )
}


styled-components:
1.安装style-components :yarn add styled-components
2.使用
import React, { memo } from 'react'
import {ContainterWarpper} from  './style'
const index = memo(function index() {
  return (
    <ContainterWarpper>
        <span>aaaa</span>
    </ContainterWarpper>
  )
})
export default index

import styled  from 'styled-components'
export const ContainterWarpper = styled.div`
    span{
        color:orange;
    }
`

3.浏览器刷新后样式不生效，原因刷新是触发服务器渲染，服务器渲染不能识别对应的className这里需要安装插件转化
yarn add  -D babel-plugin-styled-components 使styled-components在服务端渲染时能生效
还需要进行配置：创建.babelrc 添加：
{
    "presets": [
        "next/babel"
    ],
    "plugins": [
        ["styled-components"]
    ]
}
```

###### 39.5路由传参

```
 Next.js中无法通过 /user/:id的方式传递参数；
 只能通过 /user?id=123的方式来传递参数
```

![1649925072093](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1649925072093.png)

![1649925127915](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1649925127915.png)

通过import Router from '/next/router'导入，实现函数时跳转



###### 39.6、请求数据

请求数据通过组件名称挂载 getInitialProps方法进行初始调用

![1649925378601](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1649925378601.png)

##### 40.useRoutes统一管理路由

```react
1.导入
import { useRoutes } from 'react-router-dom'
2.在统一Router中使用
import { HashRouter as Router } from 'react-router-dom'
 <Router>
            <App />
 </Router>

//App.js
import { useRoutes } from 'react-router-dom'
import routes from '@/router'
function App() {
    return (
        <div>
            {useRoutes(routes)}
        </div>
    );
}

export default App;

3.编写routes
//在react-router-dom6版本中element替换原来component组件
import Home from '@/pages/home'
const routes = [{
    path:'/',
    element:<Home></Home>
}]
export default routes

```

##### 41.react概念

41.1 区分react element 和react compoent 和react instance

```
1.react elment
react element 是由：
	React.createElement()创建，
	实际上是一个Object,有key,ref,props,$$typeof等属性
	$$typeof是一个分类标签属性
2.react component
	区分为函数组件和类组件。
3.react instance
	组件实例：
		提供this变量，追踪组件，调用组件的属性和方法，
		存在生命周期方法和组件状态
```

42.2 Reconciliation协调（虚拟dom）

```
1.虚拟dom的产生：
	通过react.createElement将react代码转化为一个有层级的对象
2.虚拟dom的好处：
	转化为js对象，用js对象的高计算，来开辟一个内存，形成一个虚拟dom，通过局部更新的方法来对比两次dom的不同的地方，从而达到减少页面的刷新次数。
3.虚拟dom怎样对比的：
	通过指定key值，给对应的dom提供唯一标识（不要用列表的index，如果在每次添加的dom的index放在数组前index不同会产生不必要的更新）
```

##### 42.路由的两种模式

```
一、react中有两种路由模式：

1.BrowserRouter 浏览器历史记录路由: 使用H5的history API

2.HashRouter 哈希路由: 使用url的hash值

二、BrowserRouter和HashRouter的不同点

1.兼容性不同

BrowserRouter 因为使用了H5的history API,不兼容IE9及以下
HashRouter 因为使用了url的哈希值兼容性更好
2.表现形式不同

HashRouter 地址栏带 #, BrowserRouter则不带 #
3.刷新对路由state参数的影响

 BrowserRouter无影响，路由state保存在history对象中
HashRouter有影响，刷新后导致路由state参数丢失,所以会配合redux使用
```

##### 43.路由传参的三种方式

```react
    1.params参数
                  路由链接(携带参数)：<Link to='/demo/test/tom/18'}>详情</Link>
                  注册路由(声明接收)：<Route path="/demo/test/:name/:age" component={Test}/>
                  接收参数：this.props.match.params
    2.search参数
                  路由链接(携带参数)：<Link to='/demo/test?name=tom&age=18'}>详情</Link>
                  注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>
                  接收参数：this.props.location.search
                  备注：获取到的search是urlencoded编码字符串，需要借助querystring解析
    3.state参数
                  路由链接(携带参数)：<Link to={{pathname:'/demo/test',state:	
                  {name:'tom',age:18}}}>详情</Link>
                  注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>
                  接收参数：this.props.location.state
                  
  对应ts的获取方式：
    //1.获取params参数：使用useParams
      import React from "react";
	  import { useParams } from "react-router-dom";

        export const DetailPage: React.FC<any> = (props) => {
            const { touristRouteId } = useParams<{touristRouteId:string}>();
            return <h1>路游路线详情页面, 路线ID:{touristRouteId}</h1>;
        };
		//注册路由
 		 <Route path="/detail/:touristRouteId" element={<DetailPage/>}></Route>
		//使用地址
		http://localhost:3000/detail/123 或者
		<navLink to="/detail/123"></navLink>
		
    //2.获取search对应的参数：使用useSearchParams
        import React from "react";
        import { useSearchParams } from "react-router-dom";

        export const DetailPage: React.FC<any> = (props) => {
            const [search，setSearch] = useSearchParams();
            return <h1>路游路线详情页面, 路线ID:{search.get('id')}</h1>;
        };
		//注册路由
 		<Route path="/detail" element={<DetailPage/>}></Route>
		//使用地址
        http://localhost:3000/detail?id=123 或者
		<navLink to="/detail？id="+id></navLink>
	//3.获取state类型参数 ：使用useLocation 但需要安装querystring处理参数：npm install --save 		querystring  
		import React from 'react'
		import { useLocation } from 'react-router-dom'
		import qs from "querystring";

        export default function Detail() {
          const {search} = useLocation();
          const {id} = qs.parse(search.slice(1));

          return (
            <ul>
              <li>消息编号：{id}</li>
            </ul>
          )
        }
		//使用地址
        http://localhost:3000/detail?id=123 或者
		<navLink to="/detail？id="+id></navLink>

```

##### 44.Link和NavLink的区别

```react
1.Link
    // to为string
    <Link to="/about">关于</Link>

    // to为obj
    <Link to={{
      pathname: '/courses',
      search: '?sort=name',
      hash: '#the-hash',
      state: { fromDashboard: true }
    }}/>
2.NavLink
    是的一个特定版本，会在匹配上当前的url的时候给已经渲染的元素添加参数，组件的属性有：

    activeClassName(string)：设置选中样式，默认值为active
    activeStyle(object)：当元素被选中时，为此元素添加样式
    exact(bool)：为true时，只有当导致和完全匹配class和style才会应用
    strict(bool)：为true时，在确定为位置是否与当前URL匹配时，将考虑位置pathname后的斜线
    isActive(func)判断链接是否激活的额外逻辑的功能

    // activeClassName选中时样式为selected
    <NavLink
      to="/faq"
      activeClassName="selected"
    >FAQs</NavLink>

    // 选中时样式为activeStyle的样式设置
    <NavLink
      to="/faq"
      activeStyle={{
        fontWeight: 'bold',
        color: 'red'
       }}
    >FAQs</NavLink>

    // 当event id为奇数的时候，激活链接
    const oddEvent = (match, location) => {
      if (!match) {
        return false
      }
      const eventID = parseInt(match.params.eventID)
      return !isNaN(eventID) && eventID % 2 === 1
    }

    <NavLink
      to="/events/123"
      isActive={oddEvent}
    >Event 123</NavLink>
```

##### 45.常见的路由跳转

```react
1.函数式组件，使用hooks钩子,使用useNavigate来跳转
	import { useNavigate, useParams, useSearchParams } from "react-router-dom";
    console.log(useNavigate(), "useNavigate");
    console.log(useParams(), "useParams");
    console.log(useSearchParams(), "useSearchParams");
    const navigate = useNavigate();
      <div onClick={() => navigate(`/detail/${id}`)}>
      </div>

	navigate(-1) //后退
	navigate(1) //向前
	navigate('/SSS')//跳转
	navigate('/SSS'，{replace:true})//replace跳转
2.Link跳转
```



# ======typescript

##### 1.typescript环境

```
安装 npm i typescript -g
	 npm install -g  @types/node
运行编译 tsc-node  npm i tsc-node -g

tsc -init 初始化配置文件

tsc 编译
tsc -w 监听编译

为了避免不同ts文件变量重复申明可以加export来解决
export class Person {}  
```



##### 2.typescript静态类型

```typescript
//typescript通过在JavaScript的基础上添加静态类型定义构建而成
let a = 123
a='123'  //a等于字符串123是错误的，a是一个number的静态类型只能赋值number类型
a=1234

let a:number = 123
```

##### 3.typescript的基本类型

```typescript
//基础类型 null,undefined,symbol ,boolean,void ,number ,string
const count: number = 123;

//对象类型
class Person {}
//对象
const teacher: { name: string; age: number } = {
    name: "zs",
    age: 12,
};
//对象类型 数组
const numbers: number[] = [1, 2];

//对象类型 类
const dell: Person = new Person();

//对象类型 函数
const func: () => number = () => {
    return 22;
};

```

##### 4.类型推断和类型注解

```
// type annotation 类型注解, 我们来告诉 TS 变量是什么类型
// type inference 类型推断, TS 会自动的去尝试分析变量的类型
// 如果 TS 能够自动分析变量类型，我们就什么也不需要做了
// 如果 TS 无法分析变量类型的话，我们就需要使用类型注解

// let count: number; //类型注解
// count = 123;

// let countInference = 123; //类型推断


//类型无法推断的时候就要手动添加类型注解，函数需要手动添加注解
function getTotal(firstNumber: number, secondNumber: number) {
  return firstNumber + secondNumber;
}

const total = getTotal(1, 2);

const obj = {
  name: 'dell',
  age: 18
};

```

##### 5.函数类型注解

```typescript
function add(first: number, second: number) {
    //定义函数返回值类型
    return first + second;
}

function sayHello(): void {
    //void类型没有返回值
    console.log("sss");
}

// function errorEmitter(): never {  //有限执行，不会执行输出
//   while(true) {}
//console.log('sss')
// }

function add1({ first, second }: { first: number; second: number }) {
    return first + second;
}
const addSum = add1({ first: 1, second: 2 });

```

##### 6.函数的基础语法

```typescript
// 基础类型, boolean, number, string, void, undfined, symbol, null
let count: number; //分行写需要先定义类型，这里类型推断无法生效
count = 123;

// 对象类型, {}, Class, function, []
const func = (str: string) => {
    return parseInt(str, 10);
};

const func1: (str: string) => number = (str) => {
    return parseInt(str, 10);
};

const date = new Date();

// 其他的 case
interface Person {
    name: "string";
}
const rawData = '{"name": "dell"}';
const newData: Person = JSON.parse(rawData);

let temp: number | string = 123;
temp = "456";

```

##### 7.数组和元组

```typescript
//数组
const arr: (number | string)[] = [1, "2", 3];
const undefinedArr: undefined[] = [undefined];

//type alias 类型别名
type User = { name: string; age: number };

class Teacher {
    name: string;
    age: number;
}

const objArr: Teacher[] = [new Teacher(), { name: "zs", age: 18 }]; //可以定义的类型是一个类

//元组  在有限个数内指定对应的类型
// 元组 tuple
const teacherInfo: [string, string, number] = ["Dell", "male", 18];
// csv
const teacherList: [string, string, number][] = [
    ["dell", "male", 19],
    ["sun", "female", 26],
    ["jeny", "female", 38],
];

```

##### 8.interface接口

```typescript
export interface Person {
    readonly hobby: string; //只读
    name: string;
    age?: number; //可选
    [propName: string]: any; //其他属性名为string类型的任意类型值
    say(): string; //定义函数类型
}

const getPersonName = (person: Person): void => {
    console.log(person.name);
};

const setPersonName = (person: Person, name: string) => {
    person.name = name;
    person.sex = 1;
};

const person = {
    name: "zs",
    sex: "0",
    hobby: "ball",
    say: () => "ss",
};
getPersonName(person);
setPersonName(person, "ls");

//类型接口继承
export interface Teacher extends Person {
    teach(): string;
}

const teacher = {
    name: "zs",
    sex: "0",
    hobby: "ball",
    say: () => "ss",
    teach: () => "ss",
};

const setTeacher = (teacher: Teacher, name: string) => {
    teacher.name = name;
};

setTeacher(teacher, "sss");

//可以实现对应的Person类
class User implements Person {
    name: "ss";
    hobby: "0";
    say: () => "ss";
}

//定义函数接口
export interface SayHi {
    (word: string): string;
}

const say: SayHi = (word: string) => {
    return "ss";
};

```

##### 9.类的继承

```typescript
class Person {
    name = "dell";
    getName() {
        return this.name;
    }
}

export class Teacher extends Person {
    getTeacherName() {
        return "teacher";
    }
    getName() {
        return super.getName() + "hi"; //super复用父类的方法
    }
}

const t = new Teacher();
console.log(t.getName());
```

##### 10.类属性的访问类型

```typescript
//访问类型：private,protected,public
// public 允许内外部使用
// private 允许内部使用
// protected 允许在内以及继承的子类内中使用

class Person {
    public name: string = "zs";
    private age: number = 18;
    private sayHi() {
        console.log("hi");
    }
    protected hello() {
        this.sayHi();
        console.log(",hello");
    }
}

const person = new Person();
person.name = "zs";
console.log(person.name);
// console.log(person.hello); //private和protected不允许在外部调用

class Teacher extends Person {
    public sayBay() {
        this.hello();
    }
}

const teacher = new Teacher();
person.name = "zs";
teacher.sayBay();

```

##### 11.constructor

```typescript
// class Person {
//   // 传统写法
//   // public name: string;
//   // constructor(name: string) {
//   //   this.name = name;
//   // }
//   // 简化写法
//   constructor(public name: string) {}
// }

class Person {
    constructor(public name: string) {}
    sayHi() {
        console.log(this.name);
    }
}

class Student extends Person {
    constructor(public name1: string, public age: number) {
        super("ss");
    }
}

const student = new Student("zs", 18);
console.log(student.name1);
console.log(student.sayHi());

```

##### 12.getter和setter

```typescript
//getter setter  通过get和set属性可以访问到私有属性，起到保护私有变量的作用

class Person {
  constructor(private _name: string) {}
  get name() {
      return this._name;
  }
  set name(name: string) {
      this._name = name;
  }
}

const person = new Person("zs");
console.log(person.name);
person.name = "ls";
console.log(person.name);

```

##### 13.简单单例模式

```typescript
//单例模式每一个类只允许产生一个实例
class Single {
    private static instance: Single;
    private constructor(public name: string) {}
    static getInstance(singlename: string) {
        //static允许外部访问
        // return new Single("sss"); //还是生成了不同的实例

        if (!this.instance) {
            this.instance = new Single(singlename);
        }
        return this.instance;
    }
}

const s1 = Single.getInstance("zs");
const s2 = Single.getInstance("ls");
console.log(s1.name);
console.log(s2.name);

```

##### 14.抽象类和interface接口

```typescript
abstract class Gemo {
    //抽象类主要是提取公共的方法属性
    width: number;
    getType() {
        return "sss";
    }
    abstract getArea(): number;
}

class Square extends Gemo {
    getArea() {
        //需要重写
        return 123;
    }
}
// class Square {}
// class Triangle {}

//interface
interface Person {
    name: string;
    age: number;
}
interface Student extends Person {
    homework: string;
}
interface Teacher extends Person {
    teachingAge: number;
}

//interface可以继承就包揽了所有的类型，简写了类型(Student|Teacher)
const getUserInfo = (user: Person) => {
    console.log(user.name);
    // console.log(user.teachingAge)
};

const teacher = {
    name: "dell",
    age: 12,
    teachingAge: 3,
};

const student = {
    name: "lee",
    age: 18,
};
getUserInfo(teacher);

```

##### 15.ts项目编译配置项

```js
1.ts编译时可以设置配置项，通过tsc init初始化会生成一个tsconfig.json的配置项
2.tsc xx.ts文件执行时是不会编译配置项内容，需要不指定特定文件执行而是通过tsc直接编译（ts-node直接可以编译利用配置文件）
3.tsc里面也可以通过设置includes,excludes,files来设置你想要编译的文件
4.配置项是存放在compilerOptions里面的，常用的配置项如下：
	 "noImplicitAny": false  //false代表若果是any类型可以不用声明，反之需要声明，一般是需要的
	 "strictNullChecks": false //默认null是可以赋值给其他类型的，设置为true就只能赋值给null类型
	 "outDir": "./"  //编译输出文件地址
     "rootDir": "./",  //编译输入文件
     "allowJs": true,  //是否编译js文件              
     "checkJs": true,  //js语法检验
     "noUnusedLocals": true  //未使用变量的检验
     "noUnusedParameters": true //未使用函数参数的检验
```

##### 16.类型保护

```typescript
class Bird {
    fly: Boolean;
    sing: () => {};
}
class Dog {
    fly: Boolean;
    bark: () => {};
}
//组合类型：两个类型以上
//组合类型中如果调用不同的东西无法调用会ts报错,所以可以用如下的类型保护

//1.类型断言
function trainAnial(animate: Bird | Dog) {
    // animate.sing()
    if (animate.fly) {
        (animate as Bird).sing();
    } else {
        (animate as Dog).bark();
    }
}

//2. in 语法做保护类型
function trainAnial1(animate: Bird | Dog) {
    if ("sing" in animate) {
        animate.sing();
    } else {
        animate.bark();
    }
}

//3.typeof 语法做类型保护
function add(first: string | number, second: string | number) {
    // return first + second;  //运算符“+”不能应用于类型“string | number”和“string | number”
    if (typeof first === "string" || typeof second === "string") {
        return `${first}${second}`;
    }
    return first + second;
}

//4.instanceof 语法做类型保护
class NumberObj {
    count: number;
}

function addSecond(first: object | NumberObj, second: object | NumberObj) {
    // return first.count + second.count; //类型“object | NumberObj”上不存在属性“count”
    if (first instanceof NumberObj && second instanceof NumberObj) {
        return first.count + second.count;
    }
    return 0;
}

```

##### 17.泛型

```typescript
// 泛型 generic 泛指的类型

function join<T, P>(first: T, second: P) {
  return `${first}${second}`;
}

function anotherJoin<T>(first: T, second: T): T {
  return first;
}

// T[]
function map<T>(params: Array<T>) {
  return params;
}

// join<number, string>(1, '1');
// map<string>(['123']);
join(1, '1');

```

##### 18.泛型的使用

```typescript
class DataManager {
    constructor(private data: string[] | number[]) {} //多个不同类型时，会成列很多，可以用泛型
    getItem(index: number): string | number {
        return this.data[index];
    }
}

class DataManager<T> {
    constructor(private data: T[]) {}
    getItem(index: number): T {
        return this.data[index];
    }
}

// const data = new DataManager(['1'])

// 泛型可以继承，需要实现继承的类型
class DataManager<T extends number | string> {
    constructor(private data: T[]) {}
    getItem(index: number): T {
        return this.data[index];
    }
}
const data = new DataManager<number>([1]); //泛型指定了number类型

//用泛型做一个具体的类型注解
function hello<T>(params: T) {
    return params;
}

const func: <T>(params: T) => T = hello;

```

##### 19.namespace命名空间

```typescript
namespace Home {
    //namespace提供一个命名空间可以选择性提供空间的东西
    class Header {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is header";
            document.body.appendChild(ele);
        }
    }

    class Content {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is content";
            document.body.appendChild(ele);
        }
    }

    class Footer {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is footer";
            document.body.appendChild(ele);
        }
    }

    export class Page {
        //暴露某一个类用export
        constructor() {
            const header = new Header();
            const content = new Content();
            const footer = new Footer();
        }
    }
}

```

##### 20.namespace嵌套使用

```typescript
1.多个namespace使用需要在编译完成后index.html中引入打包后不同编译文件
2.可以通过修改配置文件来使所有编译文件到一个当中去
 "outFile": "./dist"

eg:page.ts
namespace Home {
    //namespace提供一个命名空间可以选择性提供空间的东西

    export class Page {
        //暴露某一个类用export
        constructor() {
            const header = new Components.Header();  
            const content = new Components.Content();
            const footer = new Components.Footer();
        }
    }
}


components.ts
namespace Components {
    export class Header {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is header";
            document.body.appendChild(ele);
        }
    }

    export class Content {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is content";
            document.body.appendChild(ele);
        }
    }

    export class Footer {
        constructor() {
            const ele = document.createElement("div");
            ele.innerText = "this is footer";
            document.body.appendChild(ele);
        }
    }
}
    
    
3.namespace嵌套interface
namespace Components {
  export interface user {
    name: string;
  }

  export class Header {
    constructor() {
      const elem = document.createElement('div');
      elem.innerText = 'This is Header';
      document.body.appendChild(elem);
    }
  }

  export class Content {
    constructor() {
      const elem = document.createElement('div');
      elem.innerText = 'This is Content';
      document.body.appendChild(elem);
    }
  }

  export class Footer {
    constructor() {
      const elem = document.createElement('div');
      elem.innerText = 'This is Footer';
      document.body.appendChild(elem);
    }
  }
}
    
///<reference path="components.ts" />
namespace Home {
    //namespace提供一个命名空间可以选择性提供空间的东西
    export namespace Dell {
        export const teacher: Components.User = {
            //使用了components提供User接口
            name: "zs",
        };
    }
    export class Page {
        //暴露某一个类用export
        constructor() {
            const header = new Components.Header();
            const content = new Components.Content();
            const footer = new Components.Footer();
        }
    }
}


```

##### 21.parcel打包

```js
1.默认index.html引入ts文件是不能编译的，浏览器不能识别ts语法
2.借助parcel可以直接引入Ts文件在浏览识别
安装
npm install -g parcel-bundler
在package中定义运行index.html
{
    "name": "19.parcel",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
        "test": "parcel ./index.html"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
        "typescript": "^4.6.4"
    }
}
npm run test会启动一个服务运行index.html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
        <script src="./src/page.ts"></script>
    </head>
    <body></body>
</html>


```

##### 22.ts全局配置

```typescript
我们对于js的文件可以自己定义类型注解，使用全局配置
例如jquery没有$定义	

page.ts

 $(function(){  //这里$会报错
    console.log('sss')
 })

jquery.d.ts  
declare var $:(param:()=>void)=>void  //用declare定义一个全局变量
declare function $(readyFunc: () => void): void; //定义一个全局函数



page.ts
$(function(){
    $('body').html('sss')
})

jquery.d.ts 
declare function $(readyFunc:string): {
    html:(param:string)=>void
};



```

##### 23.interface函数重载

```typescript
//函数重载：可以对同一个函数只要参数类型不一样可以进行重载
declare function $(readyFunc: () => void): void; //定义全局变量

interface JqueryInstance {
    html: (html: string) => {};
  }
declare function $(readyFunc:string):JqueryInstance


//使用interface对函数重载
interface JqueryInstance {
    html: (html: string) => {};
  }

interface JqueryType{
    (readyFunc: () => void): void
    (selector: string): JqueryInstance
}
declare var $:JqueryType

```

##### 24.如何对类以及对象进行全局定义

```typescript
$(function(){
    new $.fn.init()
})


//如何对对象以及类进行定义
declare namespace ${
    namespace fn{
        class init{
            
        }
    }
}
```

##### 25.es6模块化的描述文件

```typescript
page.ts
import $ from 'jquery';

$(function() {
  $('body').html('<div>123</div>');
  new $.fn.init();
});


juqery.d.ts
// Es6 模块化
declare module 'jquery' {
  interface JqueryInstance {
    html: (html: string) => JqueryInstance;
  }
  // 混合类型
  function $(readyFunc: () => void): void;
  function $(selector: string): JqueryInstance;
  namespace $ {
    namespace fn {
      class init {}
    }
  }
  export = $;
}

```

##### 26.ts中的keyof遍历

```typescript
interface Person {
    name:string,
    age:number,
    gender:string,
}


class Teacher {
    constructor(private info:Person){

    }
    // getInfo(key:string){
    //     return this.info[key]  //这里会报错,不缺定当前返回值是什么类型
    // }

    //结合泛型进行类型保护,通过keyof来便利对应的key
    //定义不一定是一个固定的类型还可以是对应类型的具体值
    // type T = 'name'
    // type T = 'age'
    // type T = 'gender'
    getInfo<T extends keyof Person>(key:T):Person[T]{
        return this.info[key]
    }
}

const teacher = new Teacher({name:'zs',age:18,gender:'女'})
const info = teacher.getInfo('age')  
```

##### 27.类装饰器

```typescript
//类的装饰器
//装饰器本身也是一个函数
//装饰器接受的参数是一个构造函数
//装饰器通过@来使用

//  function testDecorator(constructor:any){
//         console.log('dddd')
//  }

//  @testDecorator
// class Test{}

// const test = new Test()

//装饰器可以写成接受参数的形式
function testDecorator(flag: Boolean) {
    if (flag) {
        return function (constructor: any) {
            constructor.prototype.getName = function () {
                console.log("hi,song");
            };
        };
    } else {
        return function (constructor: any) {};
    }
}

@testDecorator(true)
class Test {}

const test = new Test();
(test as any).getName(); 




//但是这个并不规范，test并不存在getName这个方法，方法是装饰器上的
//完善的装饰器，不需要@
function testDecorator() {
    return function <T extends new (...args: any[]) => any>(constructor: T) {
        //new (...args: any[]) => any 相当于test  =》  const test = new Test('dell',18) 相当于一个够着函数返回也是一个类
        return class extends constructor {
            name = "dell"; //这里可以进行装饰
            getName() {
                return this.name;
            }
        };
    };
}

const Test = testDecorator()(//返回装饰器装饰后的类
    class {
        name: string;
        age: number;
        constructor(name: string, age: number) {
            this.name = name;
            this.age = age;
        }
    }
);

const test = new Test("dell", 18);
console.log(test);
console.log(test.getName()); //这里的getName就是装饰器里面定义的类

```

##### 28.函数装饰器

```typescript
// 普通方法，target 对应的是类的 prototype
// 静态方法，target 对应的是类的构造函数
//descriptor 对应当前函数
function getNameDecorator(
    target: any,
    key: string,
    descriptor: PropertyDescriptor
) {
    // console.log(target, key);
    // descriptor.writable = true;
    descriptor.value = function () {
        return "decorator";
    };
}
class Test {
    name: string;
    age: number;
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    @getNameDecorator
     getName() {
        return "sss";
    }
}
const test = new Test("zs", 18);
console.log(test.getName())

```

##### 29.访问器的装饰器

```typescript
// 普通方法，target 对应的是类的 prototype
// 静态方法，target 对应的是类的构造函数
//descriptor 对应当前函数
function setNameDecorator(
    target: any,
    key: string,
    descriptor: PropertyDescriptor
) {
    // console.log(target, key);
    descriptor.writable = true;
}
class Test {
    _name: string;
    constructor(name: string) {
        this._name = name;
    }
    get name(){
        return this._name
    }
    @setNameDecorator
    set name(name:string){
        this._name = name
    }
}
const test = new Test("dell");
test.name = 'hi dell'
console.log(test.name)
```

##### 30.属性装饰器

```typescript
//属性装饰器没有descriptor这个参数，但可以重构descriptor
// function nameDecorator(target: any,key: string):any {
//     const descriptor:PropertyDescriptor={
//         writable: false
//     }
//     return descriptor
// }


//注意属性装饰器不能直接修改属性的值，装饰器修改的是原型上的name
function nameDecorator(target: any,key: string):any {
    target[key] ='hi dell'
}
class Test {
    @nameDecorator
    name='dell'
}
const test = new Test();
console.log(test.name) //dell  
console.log((test as any).__proto__.name)//hi dell
```

##### 31.参数的装饰器

```typescript
//target代表原型，key代表函数名,paramIndex代表参数索引
function paramDecorator(target: any,key: string,paramIndex:number):any {
    console.log(target,key,paramIndex)
}
class Test {
   getInfo (name:string,@paramDecorator age:number){

   }
}
const test = new Test();
```



##### 32.装饰器的小实例

```typescript
const userInfo: any = undefined;

// class Test {
//     getName(){
//         return userInfo.name
//     }
//     getAge(){
//         return userInfo.age
//     }
// }
// const test = new Test()
// test.getName()  //userInfo.name不存在

//解决
// class Test {
//     getName() {
//         try {
//             return userInfo.name;
//         } catch (error) {
//             console.log('name error')
//         }
//     }
//     getAge() {
//       try {
//         return userInfo.age;
//       } catch (error) {
//         console.log('age error')
//       }
//     }
// }
// const test = new Test()
// test.getName() //但也不能重复使用try catch

//使用装饰器优化
function catchError(msg:string){
   return  function (target: any, key: string, descriptor: PropertyDescriptor) {
        const fn = descriptor.value; //getName这个方法
        descriptor.value = function () { //将装饰的这个方法等于包含try catch的新方法
            try {
                fn();
            } catch (error) {
                console.log(msg);
            }
        };
    }
}

class Test {
    @catchError('name is undefined')
    getName() {
        return userInfo.name
    }
    @catchError('age is undefined')
    getAge() {
        return userInfo.age
    }
}
const test = new Test();
test.getName()
test.getAge()

```

##### 33.创建react-typescript项目

```
npx create-react-app my-app --template typescript
```

##### 34.interface取里面的类型

```typescript
export interface User {
  id: string;
  name: string;
  email: string;
  title: string;
  organization: string;
}
interface SearchPanelProps {
  users: User[];
  param: {
    name: string;
    personId: string;
  };
  setParam: (param: SearchPanelProps["param"]) => void;
}
```

##### 35.unknown类型

```js
unknown类型可以替换any，unknown多了一些限制：
任何值可以赋值给unknown，但unknown不能赋值给任何值
let value:unknown
unknown = 1
let valueNumber = 1
valueNumber =value 报错
```

##### 36. Utility Types（ts高级类型）

###### 36.1 Partial<T>

```typescript
将泛型中的T转化为可选的类型
形式：type Partial<T> = { [P in keyof T]?: T[P]; } //keyof 取到 T 中的属性名，in 操作符遍历属性名
interface Person {
    name:string,
    age:number
}
function Teacher(p:Partail<Person>,p1:Person){}
const t1 = new  Teacher({name:'zs'},{name:'ls',age:18}) //第二个参数必须完全符合定义类型
```

###### 36.2 Required<T>

```typescript
Required通过将T的所有属性设置为必选属性来构造一个新的类型
形式：type Required<T> = { [P in keyof T]-?: T[P]; };// 与partial相似，遍历T中属性，并将所有属性置为必选属性
interface Example {
  a?: string;
  b?: string;
}

const example1: Example = { a: 'aaa' }; // right

const example2: Required<Example> = { a: 'aaa' };
// error: Property 'b' is missing in type '{ a: string; }' but required in type 'Required<Example>'
```

36.3 Readonly<T>

```typescript
将T中所有属性设置为只读 
形式：type Readonly<T> = { readonly [P in keyof T]: T[P]; };

interface Todo {
  title: string;
}

const todo: Readonly<Todo> = { title: 'First Todo' };

todo.title = 'New Title'; // Cannot assign to 'title' because it is a read-only property.
```

###### 36.4 Record<K,T>

```typescript
构造一个类型，该类型具有一组属性K，每个属性的类型为T。可用于将一个类型的属性映射为另一个类型。
形式：type Record<K extends keyof any, T> = { [P in K]: T; };

type TodoProperty = 'title' | 'description';

type Todo = Record<TodoProperty, string>;

const todo: Todo = {
  title: 'First Todo',
  description: 'this is the first todo'
};
```

###### 36.5 Pick<T,K>

```typescript
通过在T中抽取一组属性K构建一个新类型.
形式：type Pick<T, K extends keyof T> = { [p in K]: T[p] };// K是T的属性集合的子集
interface Todo {
  title: string;
  description: string;
  done: boolean;
}

type TodoBase = Pick<Todo, 'title' | 'done'>;

const todo: TodoBase = {
  title: 'First Todo',
  done: false
};
```

###### 36.6Exclude<T,U>

```typescript
从T中排除可分配给U的属性，剩余的属性构成新的类型
形式：type Exclude<T, U> = T extends U ? never : T;

type T0 = Exclude<'a' | 'b' | 'c', 'a'>;  // "b" | "c"

type T2 = Exclude<string | number | (() => void), Function>;  // string | number
```

###### 36.7Extract<T,U>

```typescript
从T中抽出可分配给U的属性构成新的类型。与Exclude相反
形式：type Extract<T, U> = T extends U ? T : never;

type T0 = Extract<'a' | 'b' | 'c', 'a'>;  // "a"

// 多参数类型约束
interface StringItem {
  type: 'stringItem'
  value: string;
}

interface NumberItem {
  type: 'numberItem'
  value: number;
}

type Item = StringItem | NumberItem;

function addCase<IType extends Item['type']>(type: IType, value: Extract<Item, { type: IType }>['value']): void {
  console.log(type, ':', value);
}

addCase('stringItem', 'value1'); // right
addCase('numberItem', 2); // right
addCase('stringItem', 1); // error:类型“1”的参数不能赋给类型“string”的参数
addCase('numberItem', 'value2'); // error:类型“"value2"”的参数不能赋给类型“number”的参数
```

###### 36.7Omit<T,K>

```typescript
从T中取出除去K的其他所有属性。与Pick相对。
形式：// 结合Exclude和Pick实现
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

interface Todo {
  title: string;
  description: string;
  done: boolean;
}

type TodoBase = Omit<Todo, 'description'>;

const todo: TodoBase = {
  title: 'First Todo',
  done: false
};
```

###### 36.8Parameters<T>

```
返回类型为T的函数的参数类型所组成的数组
形式：type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
```







# ======项目笔记

#### 网易云音乐

##### 1.项目添加别名

```react
通过cracol来配置别名
1.安装yarn add craco
2.craco修改package.json的启动方式
"scripts": {
        "start": "craco start",
        "build": "craco build",
        "test": "craco test",
        "eject": "react-scripts eject"
    },
3.设置别名的配置
const path = require("path");

const resolve = dir => path.resolve(__dirname, dir);

module.exports = {
  webpack: {
     //设置别名
    alias: {
      "@": resolve("src"),
      "components": resolve("src/components")
    }
  }
}
//引入文件的时候就可以@
```

##### 2.redux的创建

1.编写store

```react
import { createStore, applyMiddleware, compose } from 'redux'
import thunk from 'redux-thunk'  //处理异步action
import reducer from './reducer'  //导入的reducer(是一个纯函数)
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose //浏览器调试（需要安装浏览器插件redux-DevTools）
const store = createStore(reducer, composeEnhancers(
    applyMiddleware(thunk)
))
export default store
```

###### 2.reducer创建

```react
//合并多个reducer
import { combineReducers } from 'redux'
//某一个reducer
import { reducer as recommendReducer } from '../pages/discover/cPages/recommend/store'

const cReducer = combineReducers({
    recommend: recommendReducer
})
export default cReducer
```

###### 3.创建Provider共享store

```react
import { Provider } from 'react-redux';
import store from './store'
 <Provider store={store}>
            <HashRouter>
                <AppHeader />
                {renderRoutes(routes)}
                <AppFooter />
            </HashRouter>
 </Provider>
```

###### 4.建立分支store

1.分支reducer

```react
import * as actionTypes from './constants' //定义action常量
const defaultState = {
    topBanners: []
}
function reducer(state = defaultState, action) {
    switch (action.type) {
        case actionTypes.CHANGE_TOP_BANNERS:
            return { ...state, topBanners: action.topBanners }
        default:
            return state;
    }
}

export default reducer
```

2.分支store/index

```react
//这个是每一个分支reducer在上面总的Reducer中汇总通过combineReducer整合
import reducer from './reducer'

export {
    reducer
}
```

3.分支store/contants

```
export const CHANGE_TOP_BANNERS = 'CHANGE_TOP_BANNERS'
```

4.分支store/actionCreator

```react
import * as actionTypes from './constants'
import { getTopBanners } from '@/services/recommend'
//请求数据banner action
const  changeTopBannerAction = (res)=>({
    type:actionTypes.CHANGE_TOP_BANNERS,
    topBanners:res.banners
})
//异步请求返回一个函数
export const getTopBannerAction = () => {
    return dispatch => {
        getTopBanners().then(res => {
            dispatch(changeTopBannerAction(res))
        })
    }
}
```

5.分支index(使用redux)

```react
import React, { memo, useEffect } from 'react'
import { connect, shallowEqual, useDispatch, useSelector } from 'react-redux'
import { getTopBannerAction } from './store/actionCreator'
// --------------------------redux-hooks操作
function HYRecommend(props) {
    //useSelector接受一个参数为函数，函数的返回值，就是useSelector的返回值
    //shallowEqual用于浅层比较，是否数据发生改变，如果不加，redux-hooks默认会刷新造成性能损耗(不加是深层比较===，useSelector返回一个全新的对象，所以默认会改变)
    const { topBanners } = useSelector((state) => ({
        topBanners: state.recommend.topBanners
    }),shallowEqual)
    const dispatch = useDispatch()
    useEffect(() => {
        dispatch(getTopBannerAction())
    }, [dispatch])
    return (
        <div>recommend:{topBanners.length}</div>
    )
}
export default memo(HYRecommend)

//-----------------------------------connect方法
// const mapStateToProps = (state) => ({
//     topBanners: state.recommend.topBanners
// })


// const mapDispatchToProps = (dispatch) => ({
//     getBanners: () => {
//         dispatch(getTopBannerAction())
//     }
// })

// export default connect(mapStateToProps, mapDispatchToProps)(memo(HYRecommend))
```

##### 3.Immutable的使用

```html
出现为了优化在我们改变某个数据时，会去使用其他数据，为了节省内存空间
作用:提供很多api每次生成新的对象，和原对象分开


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  	//导入immutable
  <script src="https://cdnjs.cloudflare.com/ajax/libs/immutable/3.8.2/immutable.min.js"></script>
  <script>
      //导入提供的变量
    const im = Immutable;

------------------------Map的使用（作用于浅层）
    // const info = {
    //   name: "kobe",
    //   age: 30,
    //   friend: {
    //     name: "james",
    //     age: 25
    //   }
    // }

    // const infoIM = im.Map(info);

    // const obj = infoIM;
    // const infoIM2 = infoIM.set("name", "why");
    // console.log(obj.get("name"));
    // console.log(infoIM2.get("name"));

------------------------ List的使用
    // const names = ["abc", "cba", "nba"];
    // // const arr = names;
    // // names[0] = "why";
    // // console.log(arr);
    // const namesIM = im.List(names);
    // const arrIM = namesIM.set(0, "why");
    // console.log(namesIM.get(0));
    // console.log(arrIM.get(0));

    const info = {
      name: "kobe",
      age: 30,
      friend: {
        name: "james",
        age: 25
      }
    }
-----------------------------fromJS用于深层新建对象（friend里面也会改变）
    // const infoIM = im.Map(info);
    const infoIM = im.fromJS(info);
    console.log(infoIM.get("friend"));

  </script>
</body>
</html>
```

##### 4.Immutable在redux中的优化以

###### 4.1修改某个分支的reducer

```react
//安装immutable引入处理Map，这里会生成一个新的集合，每次操作Map只会生成新的集合
import * as actionTypes from './constants'
import { Map } from 'immutable'
// const defaultState = {
//     topBanners: []
// }
const defaultState = Map({
    topBanners: []
})
function reducer(state = defaultState, action) {
    switch (action.type) {
        case actionTypes.CHANGE_TOP_BANNERS:
            // return { ...state, topBanners: action.topBanners }
            return state.set('topBanners', action.topBanners)
        default:
            return state;
    }
}

export default reducer
```

###### 4.2修改合并分支的地方

```react

// import { combineReducers } from 'redux'    不做immutable优化
import { combineReducers } from 'redux-immutable' //immutable提供了用于处理多个reducer的包，最后返回一个处理过后的多个reducer
import { reducer as recommendReducer } from '../pages/discover/cPages/recommend/store'

const cReducer = combineReducers({
    recommend: recommendReducer
})
export default cReducer
```

4.3获取state数据方式调整

```react
import React, { memo, useEffect } from 'react'
import { connect, shallowEqual, useDispatch, useSelector } from 'react-redux'
import { getTopBannerAction } from './store/actionCreator'
// --------------------------redux-hooks操作
function HYRecommend(props) {
    //useSelector接受一个参数为函数，函数的返回值，就是useSelector的返回值
    //shallowEqual用于浅层比较，是否数据发生改变，如果不加，redux-hooks默认会刷新造成性能损耗(不加是深层比较===，useSelector返回一个全新的对象，所以默认会改变)
    const { topBanners } = useSelector((state) => ({
        // topBanners: state.recommend.topBanners
        // topBanners: state.get('recommend').get('topBanners') //获取通过immutable处理过后map集合
        topBanners: state.getIn(['recommend', 'topBanners']) //链式获取
    }), shallowEqual)
    const dispatch = useDispatch()
    useEffect(() => {
        dispatch(getTopBannerAction())
    }, [dispatch])
    return (
        <div>recommend:{topBanners.length}</div>
    )
}
export default memo(HYRecommend)

//-----------------------------------connect方法
// const mapStateToProps = (state) => ({
//     topBanners: state.recommend.topBanners
// })


// const mapDispatchToProps = (dispatch) => ({
//     getBanners: () => {
//         dispatch(getTopBannerAction())
//     }
// })

// export default connect(mapStateToProps, mapDispatchToProps)(memo(HYRecommend))
```

##### 5.useCallBack优化

```react
useCallback使用用于将一个函数缓存到一个变量上，与useState相似可以根据依赖的变化来判断是否更新，有优化性能的作用

//1.避免轮播组件频繁更新，用useCallback优化
  <Carousel effect="fade" autoplay ref={bannerRef} beforeChange={beforeChange}>
           {topBanners.map(item => {
                 return (<div className='banner-item' key={item.imageUrl}>
                      	 <img className="image" src={item.imageUrl} alt=											{item.typeTitle} />
                      </div>)
            })}
                    </Carousel>
//2.用useCallback包裹，没有特指依赖就是所有参数
 const beforeChange =useCallback((from,to)=>{
        setCurrentIndex(to)
    },[])                 

```

##### 6.style in js传参

```react
//1.往样式中传递一个参数bgImage
<BannerWrapper bgImage={bgImage}>  
//2.样式中使用  通过一个函数的获取，并返回
import styled from 'styled-components';
export const BannerWrapper = styled.div`
  background: url(${props => props.bgImage}) center center/6000px;

  .banner {
    height: 270px;
    background-color: red;

    display: flex;
    position: relative;
  }
`
```

#### jir

###### 1.配置全局变量

```
在.env和.env.development文件中添加全局变量，比如请求地址

要以REACT_APP_开头：
.env
REACT_APP_API_URL=http://localhost:3001
.env.development

一个是开发环境时，一个打包环境生成时

通过 process.env.REACT_APP_API_URL获取
```

###### 2.自定义hook

```js
import { useEffect, useState } from "react";
//起到减少次数，提高性能
export const useDebounce = (value, delay) => {
  const [debounce, setDebounce] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebounce(value), delay);
    //每次在useEffect执行完后运行
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debounce;
};

export const useMount = (callback) => {
  useEffect(() => {
    callback();
  }, []);
};

```

###### 3.useContext的使用

```typescript
import React, { ReactNode, useState } from "react";
import { User } from "../pages/project-list/searh-panel";
import * as auth from "../auth.provider";
interface Form {
  username: string;
  password: string;
}

//创建useContext
const AuthContext = React.createContext<
  | {
      user: User | null;
      register: (form: Form) => Promise<void>;
      login: (form: Form) => Promise<void>;
      loginOut: () => Promise<void>;
    }
  | undefined
>(undefined);

AuthContext.displayName = "AuthContext";

/**
 * 定义Provider共享
 * @param  {ReactNode} children  传入的全局共享子组件
 * @returns 
 */
export const AuthProvider = ({children}:{children:ReactNode}) => {
  const [user, setUser] = useState<User | null>(null);
  const login = (form: Form) => auth.login(form).then((user) => setUser(user));
  const register = (form: Form) =>
    auth.register(form).then((user) => setUser(user));
  const loginOut = () => auth.loginOut().then(() => setUser(null));

  return (
    <AuthContext.Provider children={children}
      value={{ user, login, register, loginOut }}
    ></AuthContext.Provider>
  );
};

//自定义hook
export const useAuth = () => {
  //使用组件
  const context = React.useContext(AuthContext);
  if(!context){
    throw new Error('useAuth必须在AuthProvider中使用')
  }
  return context
};

```

###### 4.css in js emotion

```react
安装
npm i @emotion/react @emotion/styled

vscode-styled-components vscode提示插件

1.修改antd组件样式
import styled from "@emotion/styled";
const ShadowCard = styled(Card)`
    width: 40rem;
    min-height: 56rem;
    padding: 3.2rem 4rem;
    border-radius: 0.3rem;
    box-sizing: border-box;
`

2.引用图片
import logo from "@/assets/logo.svg";
const Header = styled.header`
  width: 100%;
  background: url(${logo}) no-repeat center;
  padding: 5rem 0;
  background-size: 8rem;
`;

3.样式化组件的两种形式：
	3.1.模板字符串形式
		const Button1 = styled.button`
		color:blue`
    3.2普通函数调用
    	const Button2 = styled.button({
            color:'red'
        })
        const Button3 = styled('button')`
		color:red;
		`
        const Button4 = styled('button')({
            color:green
        })
4.props使用
	4.1	模板字符串中可以在 ${} 中使用一个函数，函数接收一个 props 参数，最终返回一段 css
   		 //在ts中就要设置props的变量类型  const Div = styled.div<{bgColor?:string}>
		 const Div = styled.div` 
		 width:200px;
		 background:${props=>props.bgColor}`
     4.2普通函数调用时，可以传递一个函数，函数接收一个 props 参数，最终返回一个对象或数组对象
     	const Button =styled.button(props=>({
            borderRaduis:10,
            fontSize:props.fontSize||20
        }))
        
        
       // 或者可以在函数里面再使用样式化组件
        import { HeaderContainer } from "./components/lib";
        const Header = styled(HeaderContainer)`
  		grid-area: header;
		`;
		const HeaderLeft = styled(HeaderContainer)``;

		//lib.tsx
        import styled from "@emotion/styled";
        export const HeaderContainer = styled.div<{
          gap?: number | boolean;
          between?: boolean;
          marginBottom?:number
        }>`
          display: flex;
          align-items: center;
          justify-content: ${(props) => (props.between ? "space-between" : undefined)};
          margin-bottom: ${(props) => props.marginBottom + "rem"};
          > * {
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            margin-right: ${(props) => (props.gap ? "20rem" : undefined)};
          }
        `;

		//header传递props参数
		 <Header between={true}>
		 <HeaderLeft gap={20}>
           <h3>项目</h3>
           <h3>用户</h3>
         </HeaderLeft>
```

###### 5.gird布局

```
import styled from "@emotion/styled";
import { useAuth } from "./context/auth_context";
import ProjectList from "./pages/project-list";

export const AuthenticatedApp = () => {
  const { loginOut } = useAuth();
  return (
    <Container>
      <Header>
        {" "}
        <HeaderLeft>
          <h3>项目</h3>
          <h3>用户</h3>
        </HeaderLeft>
        <HeaderRight>
          {" "}
          <button onClick={loginOut}>登出</button>
        </HeaderRight>
      </Header>
      <Nav>nav</Nav>
      <Main>
        <ProjectList></ProjectList>
      </Main>
      <Aside>aside</Aside>
      <Footer></Footer>
    </Container>
  );
};

const Container = styled.div`
  display: grid;
  grid-template-rows: 6rem 1fr 6rem;
  grid-template-columns: 20rem 1fr 20rem;
  grid-template-areas: "header header header" "nav main aside" "footer footer footer";
  height: 100vh;
`;

const Header = styled.header`
  grid-area: header;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;
const HeaderLeft = styled.div`
  display: flex;
`;
const HeaderRight = styled.div``;
const Main = styled.main`
  grid-area: main;
`;
const Nav = styled.nav`
  grid-area: nav;
`;
const Aside = styled.aside`
  grid-area: aside;
`;
const Footer = styled.footer`
  grid-area: footer;
`;

```

###### 6.日期处理dayjs

```js
format已经停止更新
npm install dayjs --save

dayjs(project.created).format('YYYY-mm-DD') : ""
```



###### 7.react定义标题

```react
1.安装插件 react-helmet,在需要使用的组件中引入	
import { Helmet } from "react-helmet";

    <Helmet>
            <title>请先登陆或者注册</title>
     </Helmet>
2.通过document.title自定义设置
export const useDocumentTitle = (
  title: string,
  keepOnUnmount: boolean = true
) => {
  const oldTitle = useRef(document.title).current; //useRef可以不跟随组件的变化而改变
  useEffect(() => {
    document.title = title;
  }, [title]);
  useEffect(() => {
    return () => {
      //判断是否要初始title
      if (!keepOnUnmount) {
        document.title = oldTitle;
      }
    };
  }, [keepOnUnmount, oldTitle]);
};

```

#### react api

 项目创建： npm init vite react-hooks --template react

##### 5.useReducer和useRef的使用

App.jsx

```react
import { useState, createContext } from "react";
import "./App.css";
import useReducerWrite from "../components/useReducerWrite";
import Child1 from "../components/01.useContext";
import Child2 from "../components/02.useRef";
export const AppContext = createContext();
function App() {
    const [appState, dispatch] = useReducerWrite();
    return (
        <AppContext.Provider value={{...appState,dispatch }}>
            <div className="App">
                <Child1></Child1>
                <Child2></Child2>
            </div>
        </AppContext.Provider>
    );
}

export default App;
```

useReducerWrite.jsx

```react
import React, { useReducer } from "react";

const initalState = {
    color: "blue",
    count: 0,
};
const counteReducer = (state = initalState, action) => {
    switch (action.type) {
        case "increment":
            return { ...state, count: state.count + 1 };
        case "decrement":
            return { ...state, count: state.count - 1 };
        case "changeColor":
            return { ...state, color: action.color };
        default:
            break;
    }
};
export default function useReducerWrite() {
    return useReducer(counteReducer, initalState);
}

```

01.useContext

```react
import React, { useContext } from "react";
import { AppContext } from "../src/App";
export default function Child1() {
    const context = useContext(AppContext);
    return (
        <div>
            <p style={{color:context.color}}>改变文本颜色</p>
            cout：{context.count}
            <br />
            <button
                onClick={() =>
                    context.dispatch({
                        type: "increment",
                    })
                }
            >
                +
            </button>
            <button
                onClick={() =>
                    context.dispatch({
                        type: "decrement",
                    })
                }
            >
                -
            </button>
        </div>
    );
}

```

02.useRef

```react
import React, { useContext,useRef } from "react";
import { AppContext } from "../src/App";
export default function Child2() {
    const context = useContext(AppContext);
    const inputRef = useRef()
    return (
        <div>
            <input ref={inputRef} placeholder="请输入颜色"></input>
            <button onClick={()=>context.dispatch({
                type:'changeColor',
                color:inputRef.current.value
            })}>提交</button>
        </div>
    );
}

```

##### 6.useMemo

```react
import React, { useMemo, useEffect, useState } from "react";

const Child3 = (props) => {
    const [color, setColor] = useState("blue");
    const [count, setCount] = useState(1);
    //useMemo类似于计算属性，具有缓存效果，只有对应的依赖属性发生改变时才会调用，有利于性能优化，如果这里是普通函数每次调用无关的setColor也都会调用
    const doubleCount = useMemo(() => {
        console.log('ssss')
        return count * 2;
    },[count]);
    return (
        <div>
            count: {count}
            <br />
            useCount:{doubleCount}
            <button onClick={() => setCount(count + 1)}>change count</button>
            <button onClick={() => setColor('red')}>change count</button>
        </div>
    );
};

export default Child3;

```

##### 7.memo

```react
当使用的组件props没有发生变化，或者没有调用set函数不会发生更新操作

import React, { memo,useState } from "react";
const Child4c = memo(() => {
    console.log("4c");
    return <div>child4c</div>;
});
const Child4 = () => {
    const [hobby, setHoby] = useState("basktball");
    const [color, setColor] = useState("red");
    return (
        <div>
            <Child4c color={color}></Child4c>
            <button onClick={() => setColor(color + "1")}>ChangeColor</button>
            <button onClick={() => setColor(hobby + "1")}>ChangeHobby</button>
        </div>
    );
};

export default Child4;
```

##### 8.useCallback

```react
定义：useCallback用于状态缓存，如果存在子组件传调用父组件的函数，可以用useCallback来指定函数改变依赖时才会调用

import React, { useCallback, useState } from "react";
import UseCallbackChild from "./05-1.useCallbackChild";
export default function Child5() {
    const [count, setCount] = useState(0);
    const [color, setColor] = useState("red");
    //当子组件需要调用父组件函数时，当依赖重新改变，才会调用回调
    const logCountValue = useCallback(() => {
        console.log("vvvvvvvvvvvvvvvvvvvvv");
        return count * 2;
    }, [count]);
    return (
        <div>
            <UseCallbackChild logCountValue={logCountValue}/>
            <button onClick={(e) => setColor(color + "s")}>change color</button>
            <button onClick={(e) => setCount(count + 1)}>change count</button>
        </div>
    );
}


import React, { memo } from "react";

const UseCallbackChild = memo((props) => {
    const { logCountValue } = props;
    logCountValue && logCountValue();
    return <div>sssss</div>;
});

export default UseCallbackChild;

```

##### 9.自定义hook

```react
import React,{useState} from "react";
//注意点： 1.自定义hook必须是以use开头，且函数里面的useState是相互独立的,里面可以套用其他的hook，最后会返回需要的操作
export default function useStorage(key, initailValue) {
    //进来初始值要获取localStorage里面的值
    const [stateValue, setStateValue] = useState(() => {
        try {
            return JSON.parse(localStorage.getItem(key)) || initailValue;
        } catch (error) {
            return initailValue;
        }
    });
    const setStorage = (newVal) => {
        let valueToStore;
        if (newVal instanceof Function) {
            valueToStore = newVal(stateValue);
        } else {
            valueToStore = newVal;
        }
        setStateValue(valueToStore)
        localStorage.setItem(key,JSON.stringify(valueToStore))
    };
    return [stateValue, setStorage];
}

//使用
import React from "react";
import useStorage from "./06.自定义hook";
export default function Child6() {
    const [count, setCount] = useStorage("count", 0);
    return (
        <div>
            localStorage缓存的值：{count}
            <button onClick={() => setCount(count + 1)}>+</button>
            <button onClick={() => setCount(count - 1)}>-</button>
        </div>
    );
}

```

#### 携程电商

```
项目创建 ：npx create-react-app 项目名 --template typescript
```

##### 1.tsconfig.json

```
体现ts项目的相关配置
```

##### 2.在react，ts中使用css in js 体现模块化

```react
1.创建一个*.module.css文件
2.要支持模块化，用import导入，需要申明类型（*.d.ts用于类型申明文件）
//导入模块css
import style from './App.module.css';
//申明类型
declare module "*.css" {
    const css: { [key: string]: string };
    export default css;
}

```

##### 3.css拥有ts智能化提示

```react
1.安装依赖包：npm install typescript-plugin-css-modules --save-dev
2.tsconfig中引入插件
{
  	......
    "plugins": [{"name": "typescript-plugin-css-modules"}]
  },
  "include": [
    "src"
  ]
}
3.在项目根目录下创建.vscode文件夹，里面创建一个settings.json,添加配置项：
{
    "typescript.tsdk":"node_modules/typescript/lib",
    "typescript.enablePromptUseWorkspaceTsdk":true
}

```

##### 4.自定义useState

```react
console.log("react hooks");

const useStateC = (() => {
    let state = [];
    let index = 0;
    const resetIndex = () => {
        index = 0;
    };
    const useState = (initalValue) => {
        let currentIndex = index;
        index++;
        if (state[currentIndex] === undefined) {
            state[currentIndex] = initalValue;
        }
        const setFunc = (newVal) => {
            state[currentIndex] = newVal;
        };
        return [state[currentIndex], setFunc];
    };
    return { useState, resetIndex };
})();

//使用
const { useState, resetIndex } = useStateC;
const Component = () => {
    const [count, setCount] = useState(0);
    const [count1, setCount1] = useState(2);
    if (count !== 1) {
        setCount(1);
    }
    if (count !== 4) {
        setCount1(4);
    }
    console.log(count);
    console.log(count1);
};
Component();
resetIndex();
Component();

```

##### 5.自定义useEffect

```react
console.log("react hooks");

const useStateC = (() => {
    let hooks = [];
    let index = 0;
    const resetIndex = () => {
        index = 0;
    };
    const useState = (initalValue) => {
        let currentIndex = index;
        index++;
        if (hooks[currentIndex] === undefined) {
            hooks[currentIndex] = initalValue;
        }
        const setFunc = (newVal) => {
            hooks[currentIndex] = newVal;
        };
        return [hooks[currentIndex], setFunc];
    };

    const useEffect = (callback, devProps) => {
        let hasChanged = true;
        //上一个依赖
        const oldDeps = hooks[index];
        if (oldDeps) {
            hasChanged = false;
            //便利数组里面的依赖
            devProps.forEach((dep, i) => {
                //比较当前依赖和上一次依赖
                const oldDep = oldDeps[i];
                const areTheSame = Object.is(dep, oldDep);
                if (!areTheSame) {
                    hasChanged = true;
                }
            });
        }
        if (hasChanged) {
            callback();
        }

        hooks[index] = devProps;
        index++;
    };
    return { useState, resetIndex,useEffect };
})();

const { useState, resetIndex, useEffect} = useStateC;
const Component = () => {
    const [count, setCount] = useState(0);
    const [count1, setCount1] = useState(2);
    useEffect(()=>{
        console.log('sss')
    },[])
    if (count !== 1) {
        setCount(1);
    }
    if (count !== 4) {
        setCount1(4);
    }
    console.log(count);
    console.log(count1);
};
Component();
resetIndex();
Component();

```

6.





# ======egg

##### 1.egg环境

```
$ mkdir egg-example && cd egg-example
$ npm init egg --type=simple
$ npm i
启动项目:


$ npm run dev
$ open http://localhost:7001
```

##### 2.egg 路由

```js
//app里面有router和control类

'use strict';

/**
 * @param {Egg.Application} app - egg application
 */
module.exports = app => {
  const { router, controller } = app;
  router.get('/', controller.home.index);
  router.post('/post', controller.home.post);
  router.put('/put', controller.home.put);
  router.patch('/patch', controller.home.patch);
  router.delete('/delete', controller.home.delete);

  router.get('/user', controller.user.index); // 另外一个controller
  router.resources('/user1', controller.user); // 启用RESTful风格的URL定义，就不要再指定对应control里面的方法，而是根据RESTful风格定义方法
};


controller
controller/user.js   //user.js里面是一些RESTful的一些方法

'use strict';
const { Controller } = require('egg');
class UserController extends Controller {
  async index() {
    const { ctx } = this;
    ctx.body = 'hi users1';
  }
  async new() {
    const { ctx } = this;
    ctx.body = 'hi user1 new';
  }
  async show() {
    const { ctx } = this;
    const id = ctx.params.id;
    ctx.body = 'hi user1 new' + id;
  }
}
module.exports = UserController;




```

##### 3.egg-view-ejs模板的简单使用

```js
1.安装 npm i egg-view-ejs --save
2.配置  在项目的config文件下
// {app_root}/config/plugin.js
exports.ejs = {
  enable: true,
  package: 'egg-view-ejs',
};
 
// {app_root}/config/config.default.js
exports.view = {
  mapping: {
    '.ejs': 'ejs',  //可以写成 '.html':'ejs'
  },
};
3.模板放在view文件夹下
4.渲染
 async getejs() {
    const { ctx } = this;
    await ctx.render('page.html', { data: '战三' });
  }
```

##### 4.service

```js
Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层
1.在app目录下创建service
'use strict';
const { Service } = require('egg');

class UserService extends Service {
  async getUserName(id) {
    const { service } = this;
    // const data = [
    //   { name: 'zs', age: 14 },
    //   { name: 'ls', age: 16 },
    // ];
    // return data;

    // 服务层可以接受参数
    // return id;

    // 服务层内可以调用服务层
    return await service.anotherUser.getAnotherUser() || id;
  }
  async getBaseUrl() {
    const { config } = this;
    return config.BASEURL;
  }
}
module.exports = UserService;

2.在controller中使用
 //service存在在this当中，service可以在service内部调用
'use strict';

const Controller = require('egg').Controller;

class HomeController extends Controller {
  async getUser() {
    const { ctx, service } = this;
    const data = await service.user.getUserName(1); // 可以给服务层传递参数
    await ctx.render('user', { data });
  }
  async getBaseUrl() {
    const { ctx, service } = this;
    ctx.body = await service.user.getBaseUrl();
  }
}

module.exports = HomeController;

3.在router中使用

//在config目录下config.default.js文件夹中配置通用变量，可以在this中的config使用

定义
/* eslint valid-jsdoc: "off" */

'use strict';

/**
 * @param {Egg.EggAppInfo} appInfo app info
 */
module.exports = appInfo => {
  /**
   * built-in config
   * @type {Egg.EggAppConfig}
   **/
  const config = exports = {};

  

  config.BASEURL = 'localhost:3000';


  return {
    ...config,
    ...userConfig,
  };
};

使用
  async getBaseUrl() {
    const { config } = this;
    return config.BASEURL;
  }


```

##### 5.修改favicon图标

```
config.siteFile = {
  '/favicon.ico':fs.readFileSync(favicon.ico)
};
```

##### 6.egg框架扩展

###### 6.1Application

```typescript
定义：app 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建
访问方式：
ctx.app

Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象，例如 this.app.config 访问配置对象

定义在app/extend/application.js

'use strict';
module.exports = {
  // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
  foo(param) {
    console.log(param);
    this.foo1();
  },
  foo1() {
    console.log('hi foo1');
  },
};

使用:controller
  const { ctx, app } = this;
   app.foo('hi song');
```

###### 6.2context

//扩展都会将扩展的方法与对应的原型进行合并

```typescript
定义：Context 指的是 Koa 的请求上下文，这是 请求级别 的对象，每次请求生成一个 Context 实例
访问方式：
	middleware 中 this 就是 ctx，例如 this.cookies.get('foo')。
	controller 有两种写法，类的写法通过 this.ctx，方法的写法直接通过 ctx 入参。
	helper，service 中的 this 指向 helper，service 对象本身，使用 this.ctx 访问 context 对象，例	如 this.ctx.cookies.get('foo')

定义在app/extend/context.js
'use strict';
module.exports = {
  ctxParam(param) {
    console.log('hi' + param);
    this.ctxParam1();
  },
  ctxParam1() {
    console.log('自己调用自己');
  },
};


使用：controller
ctx.ctxParam('小李子');
```

###### 6.3 Request

```
定义：Request 对象和 Koa 的 Request 对象相同，是 请求级别 的对象，它提供了大量请求相关的属性和方法供使用
访问方式：ctx.request	
ctx 上的很多属性和方法都被代理到 request 对象上，对于这些属性和方法使用 ctx 和使用 request 去访问它们是等价的，例如 ctx.url === ctx.request.url

// app/extend/request.js
'use strict';
module.exports = {
  get foo() {
    return this.url;
  },
};


使用：controller
const { ctx, app } = this;
console.log(ctx.request.foo, 'ccccc');
```

###### 6.4 Response

```
定义：Response 对象和 Koa 的 Response 对象相同，是 请求级别 的对象，它提供了大量请求相关的属性和方法供使用
访问方式：ctx.response	
ctx 上的很多属性和方法都被代理到 response 对象上，对于这些属性和方法使用 ctx 和使用 response 去访问它们是等价的，例如 ctx.status = 404 和 ctx.response.status = 404 是等价的

// app/extend/request.js
'use strict';
module.exports = {
  get foo() {
    return this.url;
  },
};


使用：controller
const { ctx, app } = this;
console.log(ctx.request.foo, 'ccccc');
```

##### 7.中间件

###### 7.1定义全局中间件

```js
1.在app下的middleware中建立中间件user.js
'use strict';
module.exports = options => {
  return async function(ctx, next) {
    ctx.body = options;
  };
};
2.在config中的config.default.js中配置全局中间件
config.middleware = ['user'];//与建立时的中间件名一致	
config.user = [{ name: 'zs', age: 18 }]; //配置对应的参数，这里对应中间件的options

这里全局中间件对所有的的路由生效
```

7.2局部中间件

```
1.在router中对于某个路由使用中间件 middleware存在在app中
module.exports = app => {
  const { router, controller, middleware } = app;
  const forbidRouter = middleware.user({ name: 'zs', age: 18 });//传递过去的options
  router.get('/', controller.home.index);
  router.post('/post', controller.home.post);
  router.put('/put', controller.home.put);
  router.patch('/patch', controller.home.patch);
  router.delete('/delete', controller.home.delete);
  router.get('/getejs', controller.home.getejs);

  router.get('/user', forbidRouter, controller.user.index); // 另外一个controller
  router.resources('/user1', controller.user); // 启用RESTful风格的URL定义，就不要再指定对应control里面的方法，而是根据RESTful风格定义方法

  router.get('/getUser', controller.home.getUser);
  router.get('/baseUrl', controller.home.getBaseUrl);
};
```

##### 8.定时器

```js
1.定义定时器
'use strict';
module.exports = {
  schedule: {
    interval: 2000, // 1 分钟间隔
    type: 'all', // 指定所有的 worker 都需要执行
    // disable 默认为false 自动启动，disable：为 true 时，这个定时任务不会被启动。
  },
  async task(ctx) {
    console.log('定时器每2s运行');
  },
};
2.手动执行定时器（只会手动执行一次）
1.首先disable设置为true
2.通过 app.runSchedule('time');//time定时器文件名
```





# ======配置

##### 1.统一格式化Prettier

```
//prettier提供统一的代码格式，可以更好的配合团队开发
1.安装prettier
npm install prettier -D
echo {}> .prettierrc.json //创建json文件
.prettierignore  //创建忽略文件   
	build
	coverage

//运行所有格式化文件
npx prettier --write . 
//运行单个格式化文件加上文件路径

//在.prettierrc.json中添加一些常规的配置
	printWidth. 条件允许时每行字符长度大于该值时进行换行（prettier不会强行换行：比如将一个引号包裹的字		符串折行）。默认为80
    tabWidth. 缩进空格数；默认为2
    semi. 语句末尾是否带分号
    singleQuote. 是否将双引号转换为单引号。双引号里包含单引号时不会被格式化。
    quoteProps. 对象属性引号的配置
    jsxSingleQuote. jsx文件里使用单引号
    bracketSpacing. 圆括号之间添加空格，如{ a: b }
    arrowParens. 箭头函数，参数添加圆括号，如(x)=>y
    parser. 指定解析器，我们一般不需要默认的就行
    
2.在git提交前进行格式化
//需要用到git集成git hooks

2.1安装pre-commit 发者完成代码，执行git add 文件名或路径后（即stage改变）的时候，会自动运行配置的prettier脚本，执行格式化，开发再将格式化后的新改变添加最后提交即可

npm install pre-commit -D

2.2 lint-staged初始化配置
安装依赖 npm install mrm@2 -D
通过mrm安装lint-staged:npx mrm lint-staged
安装完后package.json中添加了husky和lint-staged两个开发依赖和一个prepare的脚本
  "lint-staged": {
    "*.{js,css,md,ts,tsx}": "prettier --write"
  }
2.3 git add 修改后的文件,最后提交:git commit -m "first test"，就可以实现自动格式化
```

##### 2.json-server快速模拟mock启动服务

```
1.安装
npm install -g json-server
2.创建一个db.json文件，存放数据，参照restful风格每一个都是一个地址（例如：服务/post）
{
  "posts": [
    { "id": 1, "title": "json-server", "author": "typicode" }
  ],
  "comments": [
    { "id": 1, "body": "some comment", "postId": 1 }
  ],
  "profile": { "name": "typicode" }
}

3.启动json-server
json-server --watch .\db.json --port 5222

4.在浏览器中输入地址：http://localhost:+端口号/接口名称，即可查看数据。


5.配置到项目中添加一个
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "prepare": "husky install",
    "json-server":"json-server __json_server__/db.json --watch"
  },
```

##### 3.json-server里面配置中间件

```js
1.编写一个中间件文件
module.exports = (req, res, next) => {
  if (req.method === "POST" && req.path === "/login") {
    if (req.body.username === "zs" && req.body.password === "123456") {
      res.status(200);
      res.json({
        user: {
          token: "123",
        },
      });
    }else{
        res.status(400).json({message:'用户名或者密码错误'})
    }
  }
  next()
};

2.在package.json中启动服务的时候使用
 "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "prepare": "husky install",
    "json-server": "json-server __json_server__/db.json --watch --port 3001 --middlewares __json_server__/middleware.js"
  },


```

